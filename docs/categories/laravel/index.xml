<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>laravel on Scholer&#39;s Homapage</title>
    <link>http://0x1.im/categories/laravel/</link>
    <description>Recent content in laravel on Scholer&#39;s Homapage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Sun, 25 Oct 2015 23:50:33 +0000</lastBuildDate>
    
	<atom:link href="http://0x1.im/categories/laravel/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Laravel 模板引擎（Blade）原理简析</title>
      <link>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</link>
      <pubDate>Sun, 25 Oct 2015 23:50:33 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</guid>
      <description>上次提到过，模板引擎一般是要做三件事情：
 变量值的输出（echo） 条件判断和循环（if &amp;hellip; else、for、foreach、while） 引入或继承其他文件  现在就来看看 Laravel 的模板引擎是如何来处理这三件事情的。我是在 Laravel 5.1 的实现上来写这篇文章的。
1. 视图解析流程 Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：.blade.php 后缀的认为是模板视图文件，其他的 .php 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。
在使用 View 组件输出时，不管是调用 helpers 中提供的 view 函数还是使用 Facades 提供静态接口 View::make()，实际上执行的都是 Illuminate\View\Factory 中的 make 方法。以此为入口，很容易就能知道视图解析输出的流程：
 查找视图文件； 根据文件名后缀从 Container 中取出响应的引擎； 加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。  Factory 中的一些方法完成了以上第一步的过程，文件查找是调用的 FileViewFinder,其中使用了一些 Illuminate\Filesystem\Filesystem 中的方法，这个类中还有一些方法是跟 events 相关的，这里就忽略不表了。
在以上步骤中，如果中获取到的视图文件是需要“编译”的，引擎会调用 “Blade 编译器”将原视图进行“编译”并保存在 cache 目录中然后加载输出。下次调用时如果发现源文件并没有被修改过就不再重新编译而是直接获取缓存文件并输出。
CompilerEngine 调用的编译器是 CompilerInterface 接口的实现，默认情况下也就只有 BladeCompiler（如果不知道解析器是如何注入的，你需要去了解 Laravel 的服务容器，这里就不细表）。</description>
    </item>
    
  </channel>
</rss>