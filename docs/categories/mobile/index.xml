<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mobile on Scholer&#39;s Homapage</title>
    <link>http://0x1.im/categories/mobile/</link>
    <description>Recent content in mobile on Scholer&#39;s Homapage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Sat, 09 Aug 2014 15:50:00 +0000</lastBuildDate>
    
	<atom:link href="http://0x1.im/categories/mobile/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>iOS推送（Apple Push Notification Service）部署总结</title>
      <link>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</link>
      <pubDate>Sat, 09 Aug 2014 15:50:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</guid>
      <description>1. 基础部署  后端：PHP 依赖：zendframework/zendservice-apple-apns 本文中使用的PHP框架：laravel  2. 实现目标  实现中等规模批量设备的推送（1w设备以上），并且有可扩展的余地（十万到百万级） 推送的整体发送时间可控（半小时内，最好数分钟内） 保证推送的到达率能够达到**90%**以上 可以从设备列表中及时剔除无效的设备，并能够从APNs的服务器中及时获取反馈 可以获取到已经卸载的设备信息  3. 基础知识 关于APNs，我们首选需要知道：
 iOS的推送是通过socket链接将详细发送到苹果的服务器，然后由苹果像设备推送来实现的； 在服务的我们需要自己维护一个token的列表用于记录要向哪些设备发送推送； token是由系统提供的，但是有可能会失效，用户也可能会已经卸载应用； 苹果提供有获取feedback的服务器接口用于获取已经卸载应用的的设备token；  在实际操作中发现关于推送的部分：
 向一个已经打开的socket连接写入token和推送消息时，如果有一个token是无效的，socket会断开； 已经卸载应用的设备token不算是无效的token（不会导致连接断开），但是像它发送消息是没有意义的且会增加负担； socket断开之前会向连接中写入一个错误信息，可以捕捉错误的方式知道socket是在什么时候断开的，但是这个消息会有延时，无法保证100%接收到； 错误信息不会直接返回是哪个token，而是返回发送时设定的identifier； socket也会存在其它异常断开的情况； iOS6以下的设备无法通过feedback的接口获取到已卸载的token（测试结果，没有在文档中验证）； feedback的接口取到的是上次推送的过程中出现的已卸载应用的设备token，而且获取一次之后就会清空； 如果想获得卸载应用的feedback，该应用不能是卸载的设备上的仅有的推送应用（如果是最后一个，设备和苹果的推送服务连接会断开）；  4. 实际部署 实际部署中，需要对使用的库做出一些改动。
1.在ZendService\Apple\Apns\Client\Message中增加一个方法用于每次推送结束之后获取反馈：
&amp;lt;?php /** * Get Response * * @return ZendService\Apple\Apns\Response\Message */ public function getResponse(){ if (!$this-&amp;gt;isConnected()) { throw new Exception\RuntimeException(&amp;#39;You must first open the connection by calling open()&amp;#39;); } return new MessageResponse($this-&amp;gt;read()); } ?</description>
    </item>
    
    <item>
      <title>MQTT(使用mosquitto做broker)做Android推送总结</title>
      <link>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</link>
      <pubDate>Mon, 04 Aug 2014 18:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</guid>
      <description>“读万卷书，行万里路”。我觉得这句话用在程序员的工作中就是：在网络中找一万篇资料，在实践中做一万种尝试。
 由于Android的开放性，Android的推送解决方案有很多。这其中最便于使用的，应该是google提供的GCM的方案，但是GCM是基于GMS服务的。由于国内的ROM大多干掉了GMS，或者是由于某些众所周知的原因，我们无法使用这个方案获得稳定的推送服务（这个Apple的APNS不同，APNS是IOS的设备上唯一可用的推送解决方案，也是稳定的方案）。基于这些原因，我们选择了自建推送服务的方式。
###1. 基础建设： 纸上得来终觉浅 绝知此事要躬行
 理论支撑 ：使用MQTT作为Android实现方案的原因源于一篇四年前的文章：How to Implement Push Notifications for Android； 与Web管理的对接 ： 文章的作者同时也提供了PHP端的Client方案：PhpMQTTClient。 服务端 ： 当然，这只是Web端的实现方案，至于后端需要使用的Broker，我们找到了mosquitto。 客户端 ： 在客户端中，我们使用的是来自IBM的wmqtt.jar的包：wmqtt  以上四个基本条件是我们具备了部署基于MQTT协议的Android的推送服务的基本条件。在最初的测试中，也没有遇到过太大的问题，测试顺利，于是我们在我们的应用和服务器之间部署了这套解决方案。
###2. 从0到1的变化： 千里之行，始于足下
由于事先并没有做推送的经验，在实际实施的过程中我们明白的几个基础的概念：
 MQTT协议是一个即时通讯协议，推送实际上用到的只是它可以publish内容给topic的功能。topic是一个广播，所有订阅了这个topic的客户端都可以收到消息，为了实现针对设备的点对点推送，我们使用一个prefix+Client ID的方式给每个设备一个topic（如果没有这个需求，可以采取其它灵活的方式）。 为了保证客户端能够实时的收到推送消息，即使是程序退出，客户端用于接收消息的service也需要处于保持状态。 客户端与Broker、Broker和Web端的都是socket通信，推送的过程是用于Web端的client发布一个消息到Broker，Broker再将消息发送给当前其它连接到Broker的Client。所以能及时收到消息的只是现在和Broker保持连接状态的设备。 服务端需要维护一个设备id列表，这个列表中的id必须都是唯一的（在前期，我们选择使用Android ID，这也带来了很多麻烦）。  基于以上几点，我们也可以发现以下的问题：
 不是所有的设备都能够及时的获取到推送的内容。 客户端的service随时会有被各种安全软件干掉的风险。  通过前期的调研我们也发现，这些问题也是其它的第三方推送服务也都会遇到的问题。只要迈出第一步，让服务先work起来，其它的问题后续来优化。
###3. 从1到1万： 不积硅步，无以致千里
这个阶段主要是丰富推送的功能，解决一些前表面上的问题，我们做了以下的调整：
  在设备量到10000的时候，遇到了一个问题：推送10000个设备时间过长。这个问题很快得到了解决：这是由于没发送一个设备，都新建了一个从Web端到Broker的socket连接，这实际上是没有必要的，只要socket不断开所有Publish的工作都可以通过一个socket进行（这和APNS有些不一样的地方，在苹果的推送服务中，如果有一个设备id是无效的，整个推送都会断开），在前文提到过的Web端的库中，是有指定重连的操作的。
  丰富推送的内容。虽然推送的内容都是文本，但是文本的解析却是客户端维持的service来进行的，所以通过推送json的方式，实现了分别推送新闻、天气等富文本信息，并可以通过点击跳转到不同的页面。
  分地区推送的需求，这个实现方式经过一些迭代，最早是通过用户注册地来实现的，后来改为了用户安装应用时上报的地区的方式。
  ###4. 从1万到10万，必须做出的改变： 行百里者半于九十
数据量到达10万的时候，一些问题也逐渐凸显。
  Android ID重复的问题 ： 从网上查询来的资料，大部分都是使用Android的系统参数ANDROID_ID来做推送的。然而实践表明，这个参数并不是可靠的。生产环境中使用这个参数有极大的几率重复。由于一个相同的设备id连接到Broker的时候，之前的连接就会断开，这就会导致相同设备ID的设备只有一个会收到推送的消息。 在续的改造过程中，我们将设备ID换成了自己生成的一套唯一随机的ID。</description>
    </item>
    
  </channel>
</rss>