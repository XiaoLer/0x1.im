<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>php on Scholer&#39;s Homapage</title>
    <link>http://0x1.im/categories/php/</link>
    <description>Recent content in php on Scholer&#39;s Homapage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Sat, 06 Jan 2018 14:04:11 +0000</lastBuildDate>
    
	<atom:link href="http://0x1.im/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于 Redis 的 Pub/Sub 实现 Websocket 推送</title>
      <link>http://0x1.im/posts/2018-01-06-redis-websocket-push/</link>
      <pubDate>Sat, 06 Jan 2018 14:04:11 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2018-01-06-redis-websocket-push/</guid>
      <description>背景 微信小程序的生态越来越完善，而在技术上，小程序目前只支持两种通信协议：HTTPS 和 WebSocket，所以在需要使用双工通信的时候，除了 WebSocket 也没有别的选择。最近恰好有个这样的需求，所以我也花了点时间研究了一下。
项目上实现的目标就是小程序和服务器建立 WebSocket 建立连接，在服务端收到来自于第三方的事件推送之后，主动推送给客户端而不是靠客户端轮询来获取消息（这里就不介绍 WebSocket 的基础知识了）。因为我们项目组成员大多都是 PHP 开发，所以也是考虑用 PHP 来实现。
实现 这里会遇到的问题就是，用 PHP 的库来开一个 WebSocket 服务端口的时候，由于要保持连接，并接收的后续连接，所以服务本身是处于监听端口的状态。而如果程序同时要订阅来自 Redis 的事件，同样也需要监听 Redis 的消息。那么要如何实现呢？这里先直接抛出我所使用的两个库：
 Ratchet：一个 PHP 实现的异步 WebSocket 服务器 predis-async: PHP 实现的异步 Redis 客户端  仔细看上面的描述，除了 PHP 实现 外，他们还有一个相同的关键词：异步。没错，这里的异步和 node.js 描述的异步差不多是同一回事。实现异步的基础就是：EventLoop。这里我也不具体描述 EventLoop 到底是怎么一回事儿。其实 Ratchet 提供的 examples 里也有一个借用 zeromq 实现 push的例子：
$loop = React\EventLoop\Factory::create(); // Listen for the web server to make a ZeroMQ push after an ajax request $context = new React\ZMQ\Context($loop); $pusher = new MyApp\Pusher; $pull = $context-&amp;gt;getSocket(ZMQ::SOCKET_PULL); $pull-&amp;gt;bind(&amp;#39;tcp://127.</description>
    </item>
    
    <item>
      <title>使用 deployer 部署项目</title>
      <link>http://0x1.im/posts/2017-09-23-use-deployer/</link>
      <pubDate>Sat, 23 Sep 2017 08:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2017-09-23-use-deployer/</guid>
      <description>我一直都认为部署是持续集成或者 DevOps 中最重要的一个环节。受限于公司的网络环境，一直在这一块儿能做的事情很少。最近用腾讯云的机器做一些事情，才有机会好好研究一下 deployer 这个工具。
简介 deployer 主要的功能是创建一系列的工作流来执行部署任务。通过 task 函数定义一系列的操作，然后按照顺序执行，完成代码部署前后的工作。你可以自己定义任务，也可以直接使用 deployer 提供的一些已经写好的方法，deployer 称这些封装为 recipe。
举个例子 task 定义的例子：
task(&amp;#39;deploy&amp;#39;, [ &amp;#39;deploy:prepare&amp;#39;, &amp;#39;deploy:lock&amp;#39;, &amp;#39;deploy:release&amp;#39;, &amp;#39;rsync&amp;#39;, &amp;#39;deploy:shared&amp;#39;, &amp;#39;deploy:writable&amp;#39;, &amp;#39;deploy:symlink&amp;#39;, &amp;#39;deploy:unlock&amp;#39;, &amp;#39;cleanup&amp;#39;, &amp;#39;success&amp;#39;, ]); 在名为 deploy 的任务中定义了一系列的操作，这样执行 dep deployer 的时候，deployer 会按照顺序执行任务，完成部署工作。这一切执行动作本身是基于 ssh 的。
从上面的例子中也可以看出，虽然 deployer 本身主要是针对 git 项目的发布，但也可以通过 rsync 的方式同步代码。而名为 rsync 的 recipe具体的内容在github上也可以找到。
使用 deployer 进行代码部署是非常方便编写指令的，还有一个好处就是你可以在任何一次部署结束之后使用 rollback 命令进行回滚等操作。
起步 创建一个基于 deployer 的项目部署配置很简单，在安装完 deployer 后直接在目录中执行 dep init 即可。deployer 本身已经提供了一些知名开源项目的部署配置供选择，如果想高度自定义，选择通用配置（common）即可。
执行完成后会在当前目录中生成一个 deploy.php 的文件。 配置文件中最常见的两个函数就是 set 和 task，task 上文已经有过介绍。set 函数是用来配置参数用的。它既可以用来设置新的配置项，也可以替换默认的设置。</description>
    </item>
    
    <item>
      <title>如何学习 PHP 源码 - 从编译开始</title>
      <link>http://0x1.im/posts/2017-01-02-learn-compile-php/</link>
      <pubDate>Mon, 02 Jan 2017 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2017-01-02-learn-compile-php/</guid>
      <description>PHP Mailing Lists 上这两天有个好玩儿的问题：Introduction to the PHP source code，大概就是有人想知道如何学习 PHP 源码，可是这种事情不是应该自己去发掘的吗？
上面是玩笑话，现在我也说说如何学习 PHP 解释器的源码。
首选你要知道的是 PHP 解释器源码的 github 地址：https://github.com/php/php-src ，话说回来还有人不知道吗？这里有几乎所有 PHP 的代码提交记录、pull requests 和一些 issue 等。
创建编译脚本或者发布包 从 Branch 中选择一个版本 tag，和每次 PHP 发布出来的版本就是一致的。也许你会发现你想编译的的时候缺找不到 configure 文件，但是有 configure.in 文件。这时候需要先执行的是 buildconf（如果是在 Windows 下面可以执行 buildconf.bat，不过我从来没有尝试过在 Windows 下面编译 PHP，所以具体的步骤我就不清楚了）。buildconf 本身是个简单的 shell 脚本，你可以用记事本打开看看它（最终的执行文件在 build 目录里，这个目录里有一些与编译有关的文件）。
这里面涉及到一个系列的编译工具：Autotools。如果你有兴趣，可以简单的了解一下，没有兴趣的话也不用多考虑，因为这些工具绝大多数 Linux 系统上都是已经存在的。
如果你想将 Github 上的 PHP 源码做成一个可发布的源码包，你可以看看 makedist 这个文件，它也是一个 shell 脚本（实际上源码里几乎所有跟编译相关的脚本都是 shell 脚本）。但是如果想直接执行者这个脚本，你可能会收到缺少以下组件的提示：re2c 和 Bison。仔细看 makedist 的文件，里面有调用 genfiles 这个脚本的语句，上面两个工具就是在 genfiles 的脚本里被调用的。</description>
    </item>
    
    <item>
      <title>一个神奇的操作符即将加入PHP</title>
      <link>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</link>
      <pubDate>Thu, 22 Dec 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</guid>
      <description>我在翻看 PHP 的 RFC 列表的时候发现了一篇不算新的，但很有意思的 rfc：空合并赋值操作符 （姑且就这么翻译吧）。
它会引起我的注意的还有一个原因是我之前写过这样一篇文章：两行代码给 PHP7 添加一个“非空合并”语法糖，里面讲的是添加一个 ??: 操作符的方法， 而现在要讲的这个，已经被接受的 rfc 里添加的操作符是： ??=。
由于这个事情本身可说的不多，这里就根据 rfc 简单描述一下吧。以下部分是 rfc 的翻译。
 合并赋值操作符在上世纪七十年代就出现了，最早是在 C 语言里，比如 $x = $x + 3 可以被简写为 $x += 3。随着 PHP 成为一门专注于 Web 的语言，?? 操作符经常会被用去检查变量是否存在：比如：
$username = $_GET[&amp;#39;user&amp;#39;] ?? &amp;#39;nobody&amp;#39;; 但是由于大部分情况下变量的名称回避 $username 长很多，所以在使用 ?? 检查后讲变量本身赋值给自己的时候会需要些一些重复的代码，形如以下形式：
$this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? ‘value’; 这就是为什么需要一个能在自我赋值的时候进行空合并检查的赋值操作符的原因。
虽然 ?? 是一个比较操作符，??= 确实一个赋值操作符号。如果左值为 null，右值会被赋给左值，否则不做任何操作。
// 下面这一行有相同的效果 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? &amp;#39;value&amp;#39;; // 使用新操作符替代重复的代码 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?</description>
    </item>
    
    <item>
      <title>如何拯救一个有历史问题的PHP项目</title>
      <link>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</link>
      <pubDate>Sun, 18 Dec 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</guid>
      <description>本文未经许可禁止转载，如有转载意愿请与作者联系。
 1、项目历史 我们团队现在做的是一个微信第三方平台项目，项目起步时间不长，到现在差不多两年。起初是个探索性的小项目，但是随着业务的发展，已有的结构渐渐不能满足业务需求以及高峰时段的压力；不仅如此，一些历史问题也给我的开发流程带来了不少问题。所以这半年以来，再满足产品高速迭代的需求的前提下，我们也对后台框架以及服务器的结构做了持续的调整和优化。本文主要是针对后台部分的变动进行整理。
项目开始的时候，组里还有其他两个项目处于维护阶段。并且这个项目后台的起步也是直接从原来的项目里 copy 了部分结构代码并在这基础上进行改动，所以有很多历史遗留问题在里面。项目本身的框架还是 11 年左右的一个 cakePHP 的变种框架，项目框架从来没有更新过，甚至项目本身的 String 类封装每次调用都会触发 bug。
在服务器上，三个项目最开始的时候是共享所有的服务器资源的。而较老的项目由于只维护不开发，一些业务组件，比如 memcached、sphinx 中文版（Coreseek）以及一些 PHP 的扩展早已没有更新，但是每次服务器变更的时候还得考虑这些东西。
最近半年，通过不断的调整和修改，我们解决了大部分历史遗留问题，并成功升级到 PHP7。
2、基本能力 PHP 最近几年发展势头也是很快，Composer、Laravel 等组件和框架逐渐流行起来。借助第三方的力量能够很大程度的简化自己的工作、提高开发效率。
虽然以前项目中也有引入 PHPExcel 等第三方库，但都是通过下载源码丢到项目本身的方式来做的。这样做的问题是引入并不方便，并且一般不会及时通过升级来解决一些第三方库的 bug、漏洞等问题。为了提高框架的基础能力，我们在框架中引入了 Composer。
在 Compoer 的引入的同时我们也引入了一些优秀的库来解决基础问题。之前项目中的 cURL 封装到处都是，不统一并且使用起来也不方便，所以在有了 Composer 之后项目中直接加入了 guzzle。同样，为了解决异常日志栈的记录问题，monolog 也被加入到项目中。
这其中最大的一个变更是，受限于框架底层实现的问题，框架本身的 ORM 极其难用，并且整个是基于 mysql_query 来实现的。所以我们设法直接在框架中集成了 Laravel 的 ORM eloquent 减轻痛苦。
至此，项目解决了四个基本问题：
 第三方库的引入； 服务端发送请求的处理； 项目日志记录； ORM 的易用性。  这些改动都是为了解决开发上的问题。但开发上某些问题依旧存在：老的代码难以改动，并且 PHP 5.5 之后 mysql_query 系列的方法已经逐步被废弃。所以在后续的修改中一次性将这些方法都替换成了 mysqli 的实现，这也使得后续的 PHP7 升级工作能够继续进行下去。
3、项目拆分 项目的拆分分为两个部分，一个是逐步隔离两个老项目和新项目之间的资源、使新项目能够摆脱历史包袱快步前进；第二个是对新项目本身的拆分工作。</description>
    </item>
    
    <item>
      <title>一个关于 PHP 的 new 的小问题的探究</title>
      <link>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</link>
      <pubDate>Mon, 21 Nov 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</guid>
      <description>问题起因 前两天有人在群里说了一个关于 new 和 stdClass 的问题，具体表现如下：
&amp;lt;?php $a = new stdClass; $b = new $a; var_dump($a, $b); 这段代码是可以正确运行的，并且 $a 和 $b 是两个不同的空对象。即使在 new $a 之前给 $a 添加属性并赋值，$b 也始终是一个的空对象。
所以问题就是：为什么空对象还可以跟在 new 后面，stdClass 有什么特殊的地方吗？
实际表现 其实主要稍加验证就能知道，其实这和 stdClass 并没有什么关系，完全是 new 的行为决定的，比如在 psysh 上做一下简单的测试：
&amp;gt;&amp;gt;&amp;gt; $a = new Reflection; =&amp;gt; Reflection {#174} &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Reflection {#177} 这里我是 new 了一个 Reflection 类的实例，和 stdClass 的表现没有区别。当然也可以自定义一个类：
&amp;gt;&amp;gt;&amp;gt; class Test { public $foo = 1; } =&amp;gt; null &amp;gt;&amp;gt;&amp;gt; $a = new Test =&amp;gt; Test {#178 +foo: 1, } &amp;gt;&amp;gt;&amp;gt; $a-&amp;gt;foo = 2; =&amp;gt; 2 &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Test {#180 +foo: 1, } 从这个例子中我们可以清楚的看到，改变 $a 的属性对 $b 没有任何影响（到这里也可以顺便思考一下 PHP 的一个关键字：clone）。</description>
    </item>
    
    <item>
      <title>PHP 7.1 新特性一览</title>
      <link>http://0x1.im/posts/2016-09-14-features-of-php71/</link>
      <pubDate>Wed, 14 Sep 2016 00:29:02 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-09-14-features-of-php71/</guid>
      <description>PHP 7.1 release版本发布在即，本文整理一下 7.1 中的一些新特性以供了解。所有内容均选自官方 RFC 文档。
 可空类型 可空类型主要用于参数类型声明和函数返回值声明。
主要的两种形式如下：
&amp;lt;?php function answer(): ?int { return null; //ok } function answer(): ?int { return 42; // ok } function say(?string $msg) { if ($msg) { echo $msg; } } 从例子很容易理解，所指的就是通过 ? 的形式表明函数参数或者返回值的类型要么为指定类型，要么为 null。
此方法也可用于接口函数的定义：
&amp;lt;?php interface Fooable { function foo(?Fooable $f); } 但有一个需要注意的地方：如果函数本身定义了参数类型并且没有默认值，即使是可空的，也不能省略，否则会触发错误。如下：
&amp;lt;?php function foo_nullable(?Bar $bar) {} foo_nullable(new Bar); // 可行 foo_nullable(null); // 可行 foo_nullable(); // 不可行 但是如果以上函数的参数定义为 ?</description>
    </item>
    
    <item>
      <title>PHP 错误与异常的日志记录</title>
      <link>http://0x1.im/posts/2016-07-31-php-error-exception-log/</link>
      <pubDate>Sun, 31 Jul 2016 20:59:51 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-07-31-php-error-exception-log/</guid>
      <description>提到 Nginx + PHP 服务的错误日志，我们通常能想到的有 Nginx 的 access 日志、error 日志以及 PHP 的 error 日志。虽然看起来是个很简单的问题，但里面其实又牵扯到应用配置以及日志记录位置的问题，如果是在 ubuntu 等系统下使用 apt-get 的方式来安装，其自有一套较为合理的的配置文件可用。再者运行的应用程序中的配置也会影响到日志记录的方式及内容。
错误与异常的区别 关于错误与异常，我们可以用一个简单的例子来理解：
&amp;lt;?php try { 1 / 0; } catch (Exception $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 执行这个小示例会直接得到一个『PHP Warning: Division by zero …』错误。原因很简单：这是逻辑错误，并不是异常，所以不能被 try 捕获。同样，对于变量使用前未定义这种问题，也是同样的会产生 warning 而不是被捕获。
但是这个问题在 PHP7 中却有了一些改动，比如上面的例子中我把 / 改成 %，在 PHP7 的环境中执行会得到一个不一样的提示：
 PHP Fatal error: Uncaught DivisionByZeroError &amp;hellip;
 根据这个提示，如果我把 catch 中的条件修改一下：
&amp;lt;?php try { 1 / 0; } catch (DivisionByZeroError $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 这样就可以正常捕获到错误并输出 catched 了。</description>
    </item>
    
    <item>
      <title>PHP 共享内存使用与信号控制</title>
      <link>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</link>
      <pubDate>Sun, 01 May 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</guid>
      <description>共享内存 共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。
PHP 内置的 shmop 扩展 (Shared Memory Operations) 提供了一系列共享内存操作的函数（可能是用的人不多吧，这一块儿的文档还没有中文翻译）。在 Linux 上，这些函数直接是通过调用 shm* 系列的函数实现，而 Winodows 上也通过对系统函数的封装实现了同样的调用。
主要函数：
 shmop_close — 关闭共享内存块 shmop_delete — 删除共享内存块 shmop_open — 创建或打开共享内存块 shmop_read — 从共享内存块中读取数据 shmop_size — 获取共享内存块的大小 shmop_write — 向共享内存块中写入数据  与此相关的还有一个很重要的函数：ftok，通过文件的 inode 信息（*nix 上通过 stat 或 ls -i 命令查看）创建 IPC 的唯一 key（文件/文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。
一个简单的计数例子：
&amp;lt;?php # 创建一块共享内存 $shm_key = ftok(__FILE__, &amp;#39;t&amp;#39;); $shm_id = shmop_open($shm_key, &amp;#39;c&amp;#39;, 0644, 8); # 读取并写入数据 $count = (int) shmop_read($shm_id, 0, 8) + 1; shmop_write($shm_id, str_pad($count, 8, &amp;#39;0&amp;#39;, STR_PAD_LEFT), 0); // echo shmop_read($shm_id, 0, 8); # 关闭内存块，并不会删除共享内存，只是清除 PHP 的资源 shmop_close($shm_id); 以上这段代码没执行一次计数加 1，而且数据是在不同进程之间共享的。也就是说除非手动删除这块内存使用，否则这个数据是不会重置的。</description>
    </item>
    
    <item>
      <title>PHP 代码规范简洁之道</title>
      <link>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</link>
      <pubDate>Sun, 28 Feb 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</guid>
      <description>1. 统一的编码规范 编码规范往简单说其实就是三个方面：
 换行 空格 变量命名  放在 PHP 里面，还有一些附加的地方，比如关键字大小写，语法糖的使用（array() 与 [] 等）的问题。之前整理过 PSR 的标准，也找过 php-cs-fixer 这样的工具。这些都是规范代码的重要手段。有统一的标准，配合上工具的检查，形成统一的编码约束不是什么难题。
没有规范，不同的人甚至同一个人在空格、换行和命名上都有可能是十分随意的。代码一长，回使整个文件看起来无比杂乱。
典型的例子比如：if 和 else 的组合，可以写出无数种风格，比如：
&amp;lt;?php # 单语句不写大括号 if (true) doSomething(); # else 大括号换行 十分占篇幅 if (true) { doSomething(); } else { doElseThings(); } # 此外还有关键字后不带空格，随意缩进等等 # ... 再比如变量函数命名的问题上，各种混搭风格层出不穷：
&amp;lt;?php # 全小写 $someparam1 = null; # 首字母下环线 $_some_param_1 = null; # 某些库的类，下划线和大小写混用 class Abstract_ClassA { } 这里并不探讨各种写法的优缺点，只是风格需要保持统一，不要混用。
2. 良好的编码习惯 如果你仔细看过 PSR 的标准，可能也会注意到某些地方其实是标准无法涉及到的。比如一个超长的表达式在什么时候换行，如何缩进等。</description>
    </item>
    
    <item>
      <title>[译]变量在 PHP7 内部的实现（二）</title>
      <link>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</link>
      <pubDate>Sun, 20 Dec 2015 22:54:48 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</guid>
      <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
第一部分讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。
复杂的 zval 数据值有一个共同的头，其结构由 zend_refcounted 定义：
struct _zend_refcounted { uint32_t refcount; union { struct { ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) } v; uint32_t type_info; } u; }; 这个头存储有 refcount（引用计数），值的类型 type 和循环回收的相关信息 gc_info 以及类型标志位 flags。
接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。
字符串 PHP7 中定义了一个新的结构体 zend_string 用于存储字符串变量：
struct _zend_string { zend_refcounted gc; zend_ulong h; /* hash value */ size_t len; char val[1]; }; 除了引用计数的头以外，字符串还包含哈希缓存 h，字符串长度 len 以及字符串的值 val。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。</description>
    </item>
    
    <item>
      <title>php-cs-fixer (PHP Coding Standards Fixer)</title>
      <link>http://0x1.im/posts/2015-12-18-php-cs-fixer/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-18-php-cs-fixer/</guid>
      <description>php-cs-fixer 是个代码格式化工具，格式化的标准是 PSR-1、PSR-2 以及一些 symfony 的标准。这个工具也和 symfony、twig 等优秀的 PHP 库出自同门。
安装与更新 需要使用 PHP 5.3.6 以上的版本。
你可以直接下载封装好的 phar 包：php-cs-fixer.phar；
或者通过 wget 下载（下面的都是 OSX 和 Linux 上的用法）：
wget http://get.sensiolabs.org/php-cs-fixer.phar -O php-cs-fixer 或者通过 curl 下载：
curl http://get.sensiolabs.org/php-cs-fixer.phar -o php-cs-fixer 下载完成后给可执行的权限，然后移动到 bin 目录下面即可：
sudo chmod a+x php-cs-fixer sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer 这样就可以在任何地方直接使用 php-cs-fixer 命令来调用了。
也可以用过 Composer 来安装：
composer global require fabpot/php-cs-fixer 如果你是 Mac 用户、homebrew 用户并且已经 tap 过 homebrew/php 的话，也可以直接：
brew install php-cs-fixer 或者：
brew install homebrew/php/php-cs-fixer 如果后续需要更新的话：</description>
    </item>
    
    <item>
      <title>[译]变量在 PHP7 内部的实现（一）</title>
      <link>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</link>
      <pubDate>Thu, 10 Dec 2015 00:39:46 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</guid>
      <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。
PHP5 中的 zval PHP5 中 zval 结构体定义如下：
typedef struct _zval_struct { zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; } zval; 如上，zval 包含一个 value、一个 type 以及两个 __gc 后缀的字段。value 是个联合体，用于存储不同类型的值：
typedef union _zvalue_value { long lval; // 用于 bool 类型、整型和资源类型  double dval; // 用于浮点类型  struct { // 用于字符串  char *val; int len; } str; HashTable *ht; // 用于数组  zend_object_value obj; // 用于对象  zend_ast *ast; // 用于常量表达式(PHP5.</description>
    </item>
    
    <item>
      <title>PHP7 的抽象语法树（AST）带来的变化</title>
      <link>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</link>
      <pubDate>Fri, 20 Nov 2015 12:58:25 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</guid>
      <description>本文大部分内容参照 AST 的 RFC 文档而成：https://wiki.php.net/rfc/abstract_syntax_tree，为了易于理解从源文档中节选部分进行介绍。
本文并不会告诉你抽象语法树是什么，这需要你自己去了解，这里只是描述 AST 给 PHP 带来的一些变化。
新的执行过程 PHP7 的内核中有一个重要的变化是加入了 AST。在 PHP5中，从 php 脚本到 opcodes 的执行的过程是：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，在此阶段生成 op arrays。  PHP7 中在语法分析阶段不再直接生成 op arrays，而是先生成 AST，所以过程多了一步：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，从 token 流生成抽象语法树； Compilation：从抽象语法树生成 op arrays。  执行时间和内存消耗 从以上的步骤来看，这比之前的过程还多了一步，所以按常理来说这反而会增加程序的执行时间和内存的使用。但事实上内存的使用确实增加了，但是执行时间上却有所降低。
以下结果是使用小（代码大约 100 行）、中（大约 700 行）、大（大约 2800 行）三个脚本分别进行测试得到的，测试脚本： https://gist.github.com/nikic/289b0c7538b46c2220bc.
每个文件编译 100 次的执行时间（注意文章的测试结果时间是 14 年，PHP7 还叫 PHP-NG 的时候）：
    php-ng php-ast diff     SMALL 0.</description>
    </item>
    
    <item>
      <title>两行代码给 PHP7 添加一个“非空合并”语法糖</title>
      <link>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</link>
      <pubDate>Sun, 08 Nov 2015 18:22:26 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</guid>
      <description>我们知道从 PHP 5.3 起三元运算符 ? : 有一个写法简洁写法是这样的：
&amp;lt;?php $a = 0; $b = $a ?: 1; # $b === 1 这实际上相当于：
&amp;lt;?php $a = 0; $b = $a ? $a : 1; # $b === 1 在 PHP5 中，语法分析是这样写的：
| expr &amp;#39;?&amp;#39; { zend_do_begin_qm_op(&amp;amp;$1, &amp;amp;$2 TSRMLS_CC); } expr &amp;#39;:&amp;#39; { zend_do_qm_true(&amp;amp;$4, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } expr { zend_do_qm_false(&amp;amp;$$, &amp;amp;$7, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } | expr &amp;#39;?&amp;#39; &amp;#39;:&amp;#39; { zend_do_jmp_set(&amp;amp;$1, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } expr { zend_do_jmp_set_else(&amp;amp;$$, &amp;amp;$5, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } 在 PHP7 中，由于 AST（抽象语法树）的引入，语法分析有些简化：</description>
    </item>
    
    <item>
      <title>max/min 函数（PHP）的一个小 BUG</title>
      <link>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</link>
      <pubDate>Sat, 07 Nov 2015 13:30:22 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</guid>
      <description>先直接来看一段展示：
# Psy Shell v0.3.3 (PHP 5.5.30 — cli) by Justin Hileman &amp;gt;&amp;gt;&amp;gt; ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max(-0.0, 0) =&amp;gt; 0.0 &amp;gt;&amp;gt;&amp;gt; max(ceil(-0.5), 0) =&amp;gt; -0.0 上面的演示中，ceil 函数返回的是 -0.0，max 在将 ceil 函数调用的结果作为参数传入的时候，返回的也是一个 -0.0。
如果给 ceil 的结果赋值给变量，还是能得到 -0.0 的结果：
&amp;gt;&amp;gt;&amp;gt; $a = ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max($a, 0) =&amp;gt; -0.0 下面就来一一分析是哪些原因导致了这些结果的产生。
ceil 会返回 -0.0 首先我们来看一下为什么 ceil 函数会返回 -0.0。
ceil 函数的实现在 $PHP-SRC/ext/stardands/math.c （$PHP-SRC 指的是 PHP 解释器源码根目录）中，为了展示清楚我去掉了一些细节：
PHP_FUNCTION(ceil) { ... if (Z_TYPE_PP(value) == IS_DOUBLE) { RETURN_DOUBLE(ceil(Z_DVAL_PP(value))); } else if (Z_TYPE_PP(value) == IS_LONG) { convert_to_double_ex(value); RETURN_DOUBLE(Z_DVAL_PP(value)); } .</description>
    </item>
    
    <item>
      <title>如何编写一个独立的 PHP 扩展（译）</title>
      <link>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</link>
      <pubDate>Wed, 04 Nov 2015 23:43:58 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</guid>
      <description>本文翻译自 PHP 源码中的 README.SELF-CONTAINED-EXTENSIONS。文中标记了 注 的内容均为自己添加。内容有点老，也挺啰嗦，没讲什么深入的内容，但是可以作为入门学习参考。
独立的 PHP 扩展可以独立于 PHP 源码之外进行分发。要创建一个这样的扩展，需要准备好两样东西：
 配置文件 (config.m4) 你的模块源码  接下来我们来描述一下如果创建这些文件并组合起来。
准备好系统工具 想要扩展能够在系统上编译并成功运行，需要准备转以下工具：
 GNU autoconf GNU automake GNU libtool GNU m4  以上这些都可以从 ftp://ftp.gnu.org/pub/gnu/ 获取。
注：以上这些都是类 Unix 环境下才能使用的工具。
改装一个已经存在的扩展 为了显示出创建一个独立的扩展是很容易的事情，我们先将一个已经内嵌到 PHP 的扩展改成独立扩展。安装 PHP 并且执行以下命令：
$ mkdir /tmp/newext $ cd /tmp/newext 现在你已经有了一个空目录。我们将 mysql 扩展目录下的文件复制过来：
$ cp -rp php-4.0.X/ext/mysql/* . # 注：看来这篇 README 真的需要更新一下了 # PHP7 中已经移除了 mysql 扩展部分 到这里扩展就完成了，执行：
$ phpize 现在你可以独立存放这个目录下的文件到任何地方，这个扩展可以完全独立存在了。
用户在编译时需要使用以下命令：
$ .</description>
    </item>
    
    <item>
      <title>getimagesize 函数不是完全可靠的</title>
      <link>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</link>
      <pubDate>Mon, 26 Oct 2015 23:12:53 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</guid>
      <description>getimagesize 函数并不属于 GD 扩展的部分，标准安装的 PHP 都可以使用这个函数。可以先看看这个函数的文档描述：http://php.net/manual/zh/function.getimagesize.php
如果指定的文件如果不是有效的图像，会返回 false，返回数据中也有表示文档类型的字段。如果不用来获取文件的大小而是使用它来判断上传文件是否是图片文件，看起来似乎是个很不错的方案，当然这需要屏蔽掉可能产生的警告，比如代码这样写：
&amp;lt;?php $filesize = @getimagesize(&amp;#39;/path/to/image.png&amp;#39;); if ($filesize) { do_upload(); } # 另外需要注意的是，你不可以像下面这样写： # if ($filesize[2] == 0) # 因为 $filesize[2] 可能是 1 到 16 之间的整数，但却绝对不对是0。 但是如果你仅仅是做了这样的验证，那么很不幸，你成功的在代码里种下了一个 webshell 的隐患。
要分析这个问题，我们先来看一下这个函数的原型：
static void php_getimagesize_from_stream(php_stream *stream, zval **info, INTERNAL_FUNCTION_PARAMETERS) { ... itype = php_getimagetype(stream, NULL TSRMLS_CC); switch( itype) { ... } ... } static void php_getimagesize_from_any(INTERNAL_FUNCTION_PARAMETERS, int mode) { ... php_getimagesize_from_stream(stream, info, INTERNAL_FUNCTION_PARAM_PASSTHRU); php_stream_close(stream); } PHP_FUNCTION(getimagesize) { php_getimagesize_from_any(INTERNAL_FUNCTION_PARAM_PASSTHRU, FROM_PATH); } 限于篇幅上面隐藏了一些细节，现在从上面的代码中我们知道两件事情就够了：</description>
    </item>
    
    <item>
      <title>PHP 7 的几个新特性</title>
      <link>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</link>
      <pubDate>Sun, 18 Oct 2015 15:29:42 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</guid>
      <description>1. ?? 运算符（NULL 合并运算符） 把这个放在第一个说是因为我觉得它很有用。用法：
$a = $_GET[&amp;#39;a&amp;#39;] ?? 1; 它相当于：
&amp;lt;?php $a = isset($_GET[&amp;#39;a&amp;#39;]) ? $_GET[&amp;#39;a&amp;#39;] : 1; 我们知道三元运算符是可以这样用的：
$a ?: 1 但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。
2. 函数返回值类型声明 官方文档提供的例子（注意 ... 的边长参数语法在 PHP 5.6 以上的版本中才有）：
&amp;lt;?php function arraysSum(array ...$arrays): array { return array_map(function(array $array): int { return array_sum($array); }, $arrays); } print_r(arraysSum([1,2,3], [4,5,6], [7,8,9])); 从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。
这种声明的写法有些类似于 swift：
func sayHello(personName: String) -&amp;gt; String { let greeting = &amp;#34;Hello, &amp;#34; + personName + &amp;#34;!</description>
    </item>
    
    <item>
      <title>现在写 PHP，你应该知道这些</title>
      <link>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</link>
      <pubDate>Sun, 11 Oct 2015 22:50:43 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</guid>
      <description>首先你应该是在用 PHP 5.3 以上的版本，如果 PHP 版本在这之下，是时候该升级了。我建议如果有条件，最好使用最新的版本。
你应该看过 PHP The Right Way，这篇文章包含了很多内容，而且还能再扩展开。大部分的名词和概念你都需要了解。
1. PSR  The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together.
 在之前的文章中以及跟同事交流的过程中我多次提到过 PSR（PHP Standard Recommendation）。很多人以为 PSR 只是做一些规范代码风格等无关痛痒的事情，但其实远不止此。
PSR 的一系列标准文档由 php-fig (PHP Framework Interop Group)起草和投票决议，投票成员中有一些主流框架和扩展的作者，包括 Laravel、Symfony、Yii等等。
按照其官网的说法，这个组织的目的并不是告诉你你应该怎么做，只是一些主流的框架之间相互协商和约定。但是我相信这些框架和扩展中总会有你用到的。
PSR 目前通过的共有 6 份文档：
 0：自动加载（主要是针对 PHP 5.3 以前没有命名空间的版本） 1：编码规范 2：编码风格推荐 3：Log 结果 4：自动加载更细（在出现命名空间后有很大的改变） 7：HTTP 消息接口  目前在起草（Draft）中的还有 PSR-5(PHPDoc Standard)、PSR-6(Cache)等。5 和 6 没有出现在以上的列表中，是因为还没有投票通过。</description>
    </item>
    
    <item>
      <title>说说 PHP 的 die 和 exit</title>
      <link>http://0x1.im/posts/2015-09-24-php-exit-die/</link>
      <pubDate>Thu, 24 Sep 2015 00:25:44 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-09-24-php-exit-die/</guid>
      <description>今天有小伙伴说 exit 和 die 有一点差别。我说 die 不就是 exit 的别名吗？为了证明我的观点，翻了翻 PHP 的源码，在 zend_language_scanner.l 中，很容易就能发现这关键字是同一个 token：
&amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;exit&amp;#34; { return T_EXIT; } &amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;die&amp;#34; { return T_EXIT; } 所以最终也是同一个 Opcode：ZEND_EXIT。所以这两个关键字没有任何差别，这其实也没什么好说的。
我顺便提醒了小伙伴们一句：不要用 exit 输出整数。原因也很简单，在 PHP 官网的文档里就能看到：
 void exit ([ string $status ] )
void exit ( int $status )
如果 status 是一个字符串，在退出之前该函数会打印 status 。
如果 status 是一个 integer，该值会作为退出状态码，并且不会被打印输出。 退出状态码应该在范围0至254，不应使用被PHP保留的退出状态码255。 状态码0用于成功中止程序。
 所以如果 status 是一个整数，会被当成状态码输出，而不是打印，所以如果想返回给前端是不可能的。
那么这个状态码有什么用呢？
大家都知道 shell 脚本执行可以返回一个状态码，PHP 的脚本的执行返回的状态码是一样的，可以在环境变量中被捕捉到：
Scholer: ~ $ php -r &amp;#39;exit(254);&amp;#39; Scholer: ~ $ echo $?</description>
    </item>
    
  </channel>
</rss>