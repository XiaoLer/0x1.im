<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scholer&#39;s Homapage</title>
    <link>http://0x1.im/</link>
    <description>Recent content on Scholer&#39;s Homapage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Wed, 08 Jul 2020 09:39:40 +0000</lastBuildDate>
    
	<atom:link href="http://0x1.im/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 Golang 实现一个 JSON 命令行工具</title>
      <link>http://0x1.im/posts/2020-07-08-a-json-toys/</link>
      <pubDate>Wed, 08 Jul 2020 09:39:40 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2020-07-08-a-json-toys/</guid>
      <description>首先先提一个问题，&amp;quot;abc&amp;quot; 、123 或者 [1, 2, 3] 是不是一个合法的 json ？
之前一直有在使用一个 json 的命令行工具 jq，这个工具是基于 flex 和 bison 来实现的（去了解这些是基于当年学习 php 的经历）。后来有段时间我又发现一个不错的词法和语法分析工具 antlr，它支持多种语言的生成，并且本身也提供了多种语言的基本语法文件。所以我就想能不用基于它实现一个 go 语言版的 json 命令行工具。
下面就开始一步一步行动吧（如果想直接看代码可以直接拉到底部），我将这个项目命名为 jtlr。
提供的功能 根据我自己常使用的场景，我要实现以下几个功能：
基本用法：
 jtlr &amp;lsquo;{&amp;ldquo;a&amp;rdquo;: 1}&amp;rsquo;
 交互模式，可以多次输入，并且最好能支持上下切换：
 jtlr -a
 从标准输入中读取内容，可以格式化实时输出的日志：
 tail -f xxx.log | jtlr -s
 从文件中读取：
 jtlr -f xxx.log
 什么是 json 在动手之前，先要对 json 有一个全面的认识。先来大致看一下官网提供的 json 的 BNF 范式的起始部分：
json element value object array string number &amp;quot;true&amp;quot; &amp;quot;false&amp;quot; &amp;quot;null&amp;quot; .</description>
    </item>
    
    <item>
      <title>写给 PHP 程序员的 Go 入门教程</title>
      <link>http://0x1.im/posts/2020-05-26-way-from-php-to-go/</link>
      <pubDate>Tue, 26 May 2020 10:41:41 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2020-05-26-way-from-php-to-go/</guid>
      <description>这两年唱衰 PHP 的论调不少（其实我觉得大可不必），导致不少 PHP 程序员产生危机感，纷纷寻求转型，根据我的观察，基本上 Go 都是首选。不管怎么说，技多不压身，多掌握一点知识总是好的。本文就作为一个基础的入门来帮助 PHP 程序员入门 Go 语言吧。
1. 脚本语言 vs 编译型语言 这其实是个我每次面试都会问的问题，脚本语言和编译型语言有什么区别。维基上的解释：
 语法和结构通常比较简单 学习和使用通常比较简单 通常以容易修改程序的“解释”作为运行方式，而不需要“编译” 程序的开发产能优于运行性能  从我的角度，可以从执行角度和环境依赖上来说。
简单理解，作为脚本语言，你可以单独写一行 &amp;lt;?php echo &amp;quot;Hello World&amp;quot;;，命名为任意文件，然后使用 php 解释器来执行。甚至可以使用 php -a 进入交互环境执行任何代码。
go 这种编译型语言就不是这样。因为是先编译后执行，go 一定需要知道程序的入口文件和入口函数。所以一个程序的执行一定需要 main 函数（go test 文件除外）。虽然 go 也提供了 run 指令省略到编译的步骤。
在环境依赖上，执行 php 的服务器一定需要预装固定版本 php 解释器，而编译成二进制文件的 go 程序则只需要在对应架构的服务器上即可运行。这本质上是 php 的解释器扮演的才是 go 编译后的程序的角色，而脚本则是在 php 解释器构建的一层虚拟机上执行的。所以脚本语言在不同平台上表现的一致性更好，而使用编译型语言则需要有更好的操作系统和网络底层知识。
2. 动态语言 vs 静态语言 动态语言与静态语言又分别被称为弱类型语言和强类型语言，其实这样描述也更加形象。
PHP 会在执行的过程中做隐式类型转换（虽然也提供了类型转换的函数和关键字），go 的类型转换却需要手动、强制的来执行。
弱类型语言带来了很多便利性，但是也隐含了很多问题，以至于 PHP 要引入 === 这种比较方式，不过经验丰富的 PHP 开发应该是能在每一个变量定义之前都确认好它的数据类型的。go 语言中不存在隐式转换的问题，但是写起来肯定也没有那么爽，光是 int 都有多种长度的类型，会让很多新手不太适应，同样的道理，定义每一个变量之前都稍加思考，就能轻松解决这个问题。</description>
    </item>
    
    <item>
      <title>基于 Redis 的 Pub/Sub 实现 Websocket 推送</title>
      <link>http://0x1.im/posts/2018-01-06-redis-websocket-push/</link>
      <pubDate>Sat, 06 Jan 2018 14:04:11 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2018-01-06-redis-websocket-push/</guid>
      <description>背景 微信小程序的生态越来越完善，而在技术上，小程序目前只支持两种通信协议：HTTPS 和 WebSocket，所以在需要使用双工通信的时候，除了 WebSocket 也没有别的选择。最近恰好有个这样的需求，所以我也花了点时间研究了一下。
项目上实现的目标就是小程序和服务器建立 WebSocket 建立连接，在服务端收到来自于第三方的事件推送之后，主动推送给客户端而不是靠客户端轮询来获取消息（这里就不介绍 WebSocket 的基础知识了）。因为我们项目组成员大多都是 PHP 开发，所以也是考虑用 PHP 来实现。
实现 这里会遇到的问题就是，用 PHP 的库来开一个 WebSocket 服务端口的时候，由于要保持连接，并接收的后续连接，所以服务本身是处于监听端口的状态。而如果程序同时要订阅来自 Redis 的事件，同样也需要监听 Redis 的消息。那么要如何实现呢？这里先直接抛出我所使用的两个库：
 Ratchet：一个 PHP 实现的异步 WebSocket 服务器 predis-async: PHP 实现的异步 Redis 客户端  仔细看上面的描述，除了 PHP 实现 外，他们还有一个相同的关键词：异步。没错，这里的异步和 node.js 描述的异步差不多是同一回事。实现异步的基础就是：EventLoop。这里我也不具体描述 EventLoop 到底是怎么一回事儿。其实 Ratchet 提供的 examples 里也有一个借用 zeromq 实现 push的例子：
$loop = React\EventLoop\Factory::create(); // Listen for the web server to make a ZeroMQ push after an ajax request $context = new React\ZMQ\Context($loop); $pusher = new MyApp\Pusher; $pull = $context-&amp;gt;getSocket(ZMQ::SOCKET_PULL); $pull-&amp;gt;bind(&amp;#39;tcp://127.</description>
    </item>
    
    <item>
      <title>使用 deployer 部署项目</title>
      <link>http://0x1.im/posts/2017-09-23-use-deployer/</link>
      <pubDate>Sat, 23 Sep 2017 08:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2017-09-23-use-deployer/</guid>
      <description>我一直都认为部署是持续集成或者 DevOps 中最重要的一个环节。受限于公司的网络环境，一直在这一块儿能做的事情很少。最近用腾讯云的机器做一些事情，才有机会好好研究一下 deployer 这个工具。
简介 deployer 主要的功能是创建一系列的工作流来执行部署任务。通过 task 函数定义一系列的操作，然后按照顺序执行，完成代码部署前后的工作。你可以自己定义任务，也可以直接使用 deployer 提供的一些已经写好的方法，deployer 称这些封装为 recipe。
举个例子 task 定义的例子：
task(&amp;#39;deploy&amp;#39;, [ &amp;#39;deploy:prepare&amp;#39;, &amp;#39;deploy:lock&amp;#39;, &amp;#39;deploy:release&amp;#39;, &amp;#39;rsync&amp;#39;, &amp;#39;deploy:shared&amp;#39;, &amp;#39;deploy:writable&amp;#39;, &amp;#39;deploy:symlink&amp;#39;, &amp;#39;deploy:unlock&amp;#39;, &amp;#39;cleanup&amp;#39;, &amp;#39;success&amp;#39;, ]); 在名为 deploy 的任务中定义了一系列的操作，这样执行 dep deployer 的时候，deployer 会按照顺序执行任务，完成部署工作。这一切执行动作本身是基于 ssh 的。
从上面的例子中也可以看出，虽然 deployer 本身主要是针对 git 项目的发布，但也可以通过 rsync 的方式同步代码。而名为 rsync 的 recipe具体的内容在github上也可以找到。
使用 deployer 进行代码部署是非常方便编写指令的，还有一个好处就是你可以在任何一次部署结束之后使用 rollback 命令进行回滚等操作。
起步 创建一个基于 deployer 的项目部署配置很简单，在安装完 deployer 后直接在目录中执行 dep init 即可。deployer 本身已经提供了一些知名开源项目的部署配置供选择，如果想高度自定义，选择通用配置（common）即可。
执行完成后会在当前目录中生成一个 deploy.php 的文件。 配置文件中最常见的两个函数就是 set 和 task，task 上文已经有过介绍。set 函数是用来配置参数用的。它既可以用来设置新的配置项，也可以替换默认的设置。</description>
    </item>
    
    <item>
      <title>再见2016，我在腾讯这一年</title>
      <link>http://0x1.im/posts/2017-01-07-goodbye-2016/</link>
      <pubDate>Sat, 07 Jan 2017 08:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2017-01-07-goodbye-2016/</guid>
      <description>再过几天，就是入职腾讯一周年的日子了。现在想想，过去的这一年，我觉得自己是幸运的。
16年一月，将近过年的时候，义无反顾的离开了上一家公司。那是我个人整个动荡的15年的结束。这一年我在这里呆的安心，有收获、有成长。如果说之前的两年多时间我是在安心学技术，那么这一年更多的是学习如何做事情。
到深圳之前，我并没有接触过项目管理、开发周期这些概念；而到腾讯之前，我对每周迭代这件事情也是完全没有概念的，这真的很快，太快了，以至于需求从拿到手上到成型你都可能还没有时间好好消化它，一开始我很难相信这种迭代速度能打造出精品。刚入职的那段时间确实很慌乱，我挺害怕自己之前那种慢工出细活的那种做事方式没办法太好的展现出自己的优势。实际上这在上半年也确实成了掣肘的毛病。而我的另外一个问题是我始终不太愿意做重复的事情。所以在很长一段时间中，我一直抓住的是另外一条线：运维。我觉得这是能带我融入项目和环境的途径。
从我工作以来，一直都是 PHP 和运维双线发展的（也许我离开上一家公司也有一个原因是他们不愿意让我碰服务器吧）。从熟悉业务机器的部署到管理和调整，然后再去了解项目本身的模块和代码问题，也算是找到了自己的一个熟悉整个项目架构的途径。
下半年花了很大的力气去改变一些既有的结构，我把自己的想法和风格带入到了项目中。我们对服务器的结构做了很大的调整，从原来一致性的环境分割成按照不同模块划分独立运行的环境，对环境的配置也做了很大的调整。中间也不完全是一帆风顺的，也出过一些小的问题，但都及时调整，也算是安稳度过。业务代码上，随着 Composer 加入项目，一些组件和模块逐渐取代了原来的一些意大利面条式代码。虽然这一块儿改的不算彻底，但也比原来好多了。
过程不必一一细表，还是总结一下收获吧。
对项目和产品的理解：
 一个需求投入时间的多少不是取决于把它做到完美需要多少时间，而是它会带来的收益值多少时间； 投入时间的性价比也是你可以拒绝某些需求的理由； 一个产品在市场的认可程度不是取决于用户看不见的技术实现是否优雅，用户只看表象，有时候还是因为出现的时间； 技术的最终都是服务于需求，不要用技术的理由来拒绝需求，如果两者有冲突，可以试着调整一下，尽管有时候你会有『f**k，这事儿还能这么干』的感叹； 技术的在某些时候对产品的意见未必没有产品专业，有的时候，技术能直击事情的本质； 不要拒绝沟通，解决问题永远是第一位的，哪怕不得不做出一些妥协。  技术上的一些进步：
 花了一个月左右的时间掌握了下 docker 的基本用法，并且实践在了项目上（非我自己操作）； 花了一些时间在 PHP 源码调试的学习上，也能自己动手改造一下业务用的 PHP 扩展； 在公司环境限制的条件下对改善运维操作做了一些尝试，节省了一些体力； 丰富了自己的技术栈认识，包括 日志收集、ELK、自动化测试、持续集成等，但有些还没有应用到实践上； 从尝试中学会了将自己熟悉的技术栈带入项目中的方法； 对大公司（当然是腾讯）的技术栈有了一定的认知，解决了一些以往的困惑。  以上项目和产品上的理解未必完全正确，只是自己的认知，也有可能随着时间的推移而产生调整。而技术上的事情，我只能说：学习永不止步。以下是一些 2016 做的不好地方以及 2017 希望去了解的地方：
 过去的一年看书太少，给自己的理由是私下的时间太少，2017 还是希望补足，多看书； 应该尝试写一些业务上成熟且有示范效应的代码； 尝试写一些成体系的文章，运营一个公众号试试？ 也去跟风了解一下机器学习，从 TensorFlow 开始？  感谢过去的一年，从可见的成果上看，小小的升了级，并且有了一个继续升级的机会，摘下一颗四星。希望 2017 会更好。</description>
    </item>
    
    <item>
      <title>如何学习 PHP 源码 - 从编译开始</title>
      <link>http://0x1.im/posts/2017-01-02-learn-compile-php/</link>
      <pubDate>Mon, 02 Jan 2017 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2017-01-02-learn-compile-php/</guid>
      <description>PHP Mailing Lists 上这两天有个好玩儿的问题：Introduction to the PHP source code，大概就是有人想知道如何学习 PHP 源码，可是这种事情不是应该自己去发掘的吗？
上面是玩笑话，现在我也说说如何学习 PHP 解释器的源码。
首选你要知道的是 PHP 解释器源码的 github 地址：https://github.com/php/php-src ，话说回来还有人不知道吗？这里有几乎所有 PHP 的代码提交记录、pull requests 和一些 issue 等。
创建编译脚本或者发布包 从 Branch 中选择一个版本 tag，和每次 PHP 发布出来的版本就是一致的。也许你会发现你想编译的的时候缺找不到 configure 文件，但是有 configure.in 文件。这时候需要先执行的是 buildconf（如果是在 Windows 下面可以执行 buildconf.bat，不过我从来没有尝试过在 Windows 下面编译 PHP，所以具体的步骤我就不清楚了）。buildconf 本身是个简单的 shell 脚本，你可以用记事本打开看看它（最终的执行文件在 build 目录里，这个目录里有一些与编译有关的文件）。
这里面涉及到一个系列的编译工具：Autotools。如果你有兴趣，可以简单的了解一下，没有兴趣的话也不用多考虑，因为这些工具绝大多数 Linux 系统上都是已经存在的。
如果你想将 Github 上的 PHP 源码做成一个可发布的源码包，你可以看看 makedist 这个文件，它也是一个 shell 脚本（实际上源码里几乎所有跟编译相关的脚本都是 shell 脚本）。但是如果想直接执行者这个脚本，你可能会收到缺少以下组件的提示：re2c 和 Bison。仔细看 makedist 的文件，里面有调用 genfiles 这个脚本的语句，上面两个工具就是在 genfiles 的脚本里被调用的。</description>
    </item>
    
    <item>
      <title>一个神奇的操作符即将加入PHP</title>
      <link>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</link>
      <pubDate>Thu, 22 Dec 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</guid>
      <description>我在翻看 PHP 的 RFC 列表的时候发现了一篇不算新的，但很有意思的 rfc：空合并赋值操作符 （姑且就这么翻译吧）。
它会引起我的注意的还有一个原因是我之前写过这样一篇文章：两行代码给 PHP7 添加一个“非空合并”语法糖，里面讲的是添加一个 ??: 操作符的方法， 而现在要讲的这个，已经被接受的 rfc 里添加的操作符是： ??=。
由于这个事情本身可说的不多，这里就根据 rfc 简单描述一下吧。以下部分是 rfc 的翻译。
 合并赋值操作符在上世纪七十年代就出现了，最早是在 C 语言里，比如 $x = $x + 3 可以被简写为 $x += 3。随着 PHP 成为一门专注于 Web 的语言，?? 操作符经常会被用去检查变量是否存在：比如：
$username = $_GET[&amp;#39;user&amp;#39;] ?? &amp;#39;nobody&amp;#39;; 但是由于大部分情况下变量的名称回避 $username 长很多，所以在使用 ?? 检查后讲变量本身赋值给自己的时候会需要些一些重复的代码，形如以下形式：
$this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? ‘value’; 这就是为什么需要一个能在自我赋值的时候进行空合并检查的赋值操作符的原因。
虽然 ?? 是一个比较操作符，??= 确实一个赋值操作符号。如果左值为 null，右值会被赋给左值，否则不做任何操作。
// 下面这一行有相同的效果 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? &amp;#39;value&amp;#39;; // 使用新操作符替代重复的代码 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?</description>
    </item>
    
    <item>
      <title>如何拯救一个有历史问题的PHP项目</title>
      <link>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</link>
      <pubDate>Sun, 18 Dec 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</guid>
      <description>本文未经许可禁止转载，如有转载意愿请与作者联系。
 1、项目历史 我们团队现在做的是一个微信第三方平台项目，项目起步时间不长，到现在差不多两年。起初是个探索性的小项目，但是随着业务的发展，已有的结构渐渐不能满足业务需求以及高峰时段的压力；不仅如此，一些历史问题也给我的开发流程带来了不少问题。所以这半年以来，再满足产品高速迭代的需求的前提下，我们也对后台框架以及服务器的结构做了持续的调整和优化。本文主要是针对后台部分的变动进行整理。
项目开始的时候，组里还有其他两个项目处于维护阶段。并且这个项目后台的起步也是直接从原来的项目里 copy 了部分结构代码并在这基础上进行改动，所以有很多历史遗留问题在里面。项目本身的框架还是 11 年左右的一个 cakePHP 的变种框架，项目框架从来没有更新过，甚至项目本身的 String 类封装每次调用都会触发 bug。
在服务器上，三个项目最开始的时候是共享所有的服务器资源的。而较老的项目由于只维护不开发，一些业务组件，比如 memcached、sphinx 中文版（Coreseek）以及一些 PHP 的扩展早已没有更新，但是每次服务器变更的时候还得考虑这些东西。
最近半年，通过不断的调整和修改，我们解决了大部分历史遗留问题，并成功升级到 PHP7。
2、基本能力 PHP 最近几年发展势头也是很快，Composer、Laravel 等组件和框架逐渐流行起来。借助第三方的力量能够很大程度的简化自己的工作、提高开发效率。
虽然以前项目中也有引入 PHPExcel 等第三方库，但都是通过下载源码丢到项目本身的方式来做的。这样做的问题是引入并不方便，并且一般不会及时通过升级来解决一些第三方库的 bug、漏洞等问题。为了提高框架的基础能力，我们在框架中引入了 Composer。
在 Compoer 的引入的同时我们也引入了一些优秀的库来解决基础问题。之前项目中的 cURL 封装到处都是，不统一并且使用起来也不方便，所以在有了 Composer 之后项目中直接加入了 guzzle。同样，为了解决异常日志栈的记录问题，monolog 也被加入到项目中。
这其中最大的一个变更是，受限于框架底层实现的问题，框架本身的 ORM 极其难用，并且整个是基于 mysql_query 来实现的。所以我们设法直接在框架中集成了 Laravel 的 ORM eloquent 减轻痛苦。
至此，项目解决了四个基本问题：
 第三方库的引入； 服务端发送请求的处理； 项目日志记录； ORM 的易用性。  这些改动都是为了解决开发上的问题。但开发上某些问题依旧存在：老的代码难以改动，并且 PHP 5.5 之后 mysql_query 系列的方法已经逐步被废弃。所以在后续的修改中一次性将这些方法都替换成了 mysqli 的实现，这也使得后续的 PHP7 升级工作能够继续进行下去。
3、项目拆分 项目的拆分分为两个部分，一个是逐步隔离两个老项目和新项目之间的资源、使新项目能够摆脱历史包袱快步前进；第二个是对新项目本身的拆分工作。</description>
    </item>
    
    <item>
      <title>一个关于 PHP 的 new 的小问题的探究</title>
      <link>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</link>
      <pubDate>Mon, 21 Nov 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</guid>
      <description>问题起因 前两天有人在群里说了一个关于 new 和 stdClass 的问题，具体表现如下：
&amp;lt;?php $a = new stdClass; $b = new $a; var_dump($a, $b); 这段代码是可以正确运行的，并且 $a 和 $b 是两个不同的空对象。即使在 new $a 之前给 $a 添加属性并赋值，$b 也始终是一个的空对象。
所以问题就是：为什么空对象还可以跟在 new 后面，stdClass 有什么特殊的地方吗？
实际表现 其实主要稍加验证就能知道，其实这和 stdClass 并没有什么关系，完全是 new 的行为决定的，比如在 psysh 上做一下简单的测试：
&amp;gt;&amp;gt;&amp;gt; $a = new Reflection; =&amp;gt; Reflection {#174} &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Reflection {#177} 这里我是 new 了一个 Reflection 类的实例，和 stdClass 的表现没有区别。当然也可以自定义一个类：
&amp;gt;&amp;gt;&amp;gt; class Test { public $foo = 1; } =&amp;gt; null &amp;gt;&amp;gt;&amp;gt; $a = new Test =&amp;gt; Test {#178 +foo: 1, } &amp;gt;&amp;gt;&amp;gt; $a-&amp;gt;foo = 2; =&amp;gt; 2 &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Test {#180 +foo: 1, } 从这个例子中我们可以清楚的看到，改变 $a 的属性对 $b 没有任何影响（到这里也可以顺便思考一下 PHP 的一个关键字：clone）。</description>
    </item>
    
    <item>
      <title>PHP 7.1 新特性一览</title>
      <link>http://0x1.im/posts/2016-09-14-features-of-php71/</link>
      <pubDate>Wed, 14 Sep 2016 00:29:02 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-09-14-features-of-php71/</guid>
      <description>PHP 7.1 release版本发布在即，本文整理一下 7.1 中的一些新特性以供了解。所有内容均选自官方 RFC 文档。
 可空类型 可空类型主要用于参数类型声明和函数返回值声明。
主要的两种形式如下：
&amp;lt;?php function answer(): ?int { return null; //ok } function answer(): ?int { return 42; // ok } function say(?string $msg) { if ($msg) { echo $msg; } } 从例子很容易理解，所指的就是通过 ? 的形式表明函数参数或者返回值的类型要么为指定类型，要么为 null。
此方法也可用于接口函数的定义：
&amp;lt;?php interface Fooable { function foo(?Fooable $f); } 但有一个需要注意的地方：如果函数本身定义了参数类型并且没有默认值，即使是可空的，也不能省略，否则会触发错误。如下：
&amp;lt;?php function foo_nullable(?Bar $bar) {} foo_nullable(new Bar); // 可行 foo_nullable(null); // 可行 foo_nullable(); // 不可行 但是如果以上函数的参数定义为 ?</description>
    </item>
    
    <item>
      <title>PHP 错误与异常的日志记录</title>
      <link>http://0x1.im/posts/2016-07-31-php-error-exception-log/</link>
      <pubDate>Sun, 31 Jul 2016 20:59:51 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-07-31-php-error-exception-log/</guid>
      <description>提到 Nginx + PHP 服务的错误日志，我们通常能想到的有 Nginx 的 access 日志、error 日志以及 PHP 的 error 日志。虽然看起来是个很简单的问题，但里面其实又牵扯到应用配置以及日志记录位置的问题，如果是在 ubuntu 等系统下使用 apt-get 的方式来安装，其自有一套较为合理的的配置文件可用。再者运行的应用程序中的配置也会影响到日志记录的方式及内容。
错误与异常的区别 关于错误与异常，我们可以用一个简单的例子来理解：
&amp;lt;?php try { 1 / 0; } catch (Exception $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 执行这个小示例会直接得到一个『PHP Warning: Division by zero …』错误。原因很简单：这是逻辑错误，并不是异常，所以不能被 try 捕获。同样，对于变量使用前未定义这种问题，也是同样的会产生 warning 而不是被捕获。
但是这个问题在 PHP7 中却有了一些改动，比如上面的例子中我把 / 改成 %，在 PHP7 的环境中执行会得到一个不一样的提示：
 PHP Fatal error: Uncaught DivisionByZeroError &amp;hellip;
 根据这个提示，如果我把 catch 中的条件修改一下：
&amp;lt;?php try { 1 / 0; } catch (DivisionByZeroError $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 这样就可以正常捕获到错误并输出 catched 了。</description>
    </item>
    
    <item>
      <title>PHP 共享内存使用与信号控制</title>
      <link>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</link>
      <pubDate>Sun, 01 May 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</guid>
      <description>共享内存 共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。
PHP 内置的 shmop 扩展 (Shared Memory Operations) 提供了一系列共享内存操作的函数（可能是用的人不多吧，这一块儿的文档还没有中文翻译）。在 Linux 上，这些函数直接是通过调用 shm* 系列的函数实现，而 Winodows 上也通过对系统函数的封装实现了同样的调用。
主要函数：
 shmop_close — 关闭共享内存块 shmop_delete — 删除共享内存块 shmop_open — 创建或打开共享内存块 shmop_read — 从共享内存块中读取数据 shmop_size — 获取共享内存块的大小 shmop_write — 向共享内存块中写入数据  与此相关的还有一个很重要的函数：ftok，通过文件的 inode 信息（*nix 上通过 stat 或 ls -i 命令查看）创建 IPC 的唯一 key（文件/文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。
一个简单的计数例子：
&amp;lt;?php # 创建一块共享内存 $shm_key = ftok(__FILE__, &amp;#39;t&amp;#39;); $shm_id = shmop_open($shm_key, &amp;#39;c&amp;#39;, 0644, 8); # 读取并写入数据 $count = (int) shmop_read($shm_id, 0, 8) + 1; shmop_write($shm_id, str_pad($count, 8, &amp;#39;0&amp;#39;, STR_PAD_LEFT), 0); // echo shmop_read($shm_id, 0, 8); # 关闭内存块，并不会删除共享内存，只是清除 PHP 的资源 shmop_close($shm_id); 以上这段代码没执行一次计数加 1，而且数据是在不同进程之间共享的。也就是说除非手动删除这块内存使用，否则这个数据是不会重置的。</description>
    </item>
    
    <item>
      <title>PHP 代码规范简洁之道</title>
      <link>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</link>
      <pubDate>Sun, 28 Feb 2016 12:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</guid>
      <description>1. 统一的编码规范 编码规范往简单说其实就是三个方面：
 换行 空格 变量命名  放在 PHP 里面，还有一些附加的地方，比如关键字大小写，语法糖的使用（array() 与 [] 等）的问题。之前整理过 PSR 的标准，也找过 php-cs-fixer 这样的工具。这些都是规范代码的重要手段。有统一的标准，配合上工具的检查，形成统一的编码约束不是什么难题。
没有规范，不同的人甚至同一个人在空格、换行和命名上都有可能是十分随意的。代码一长，回使整个文件看起来无比杂乱。
典型的例子比如：if 和 else 的组合，可以写出无数种风格，比如：
&amp;lt;?php # 单语句不写大括号 if (true) doSomething(); # else 大括号换行 十分占篇幅 if (true) { doSomething(); } else { doElseThings(); } # 此外还有关键字后不带空格，随意缩进等等 # ... 再比如变量函数命名的问题上，各种混搭风格层出不穷：
&amp;lt;?php # 全小写 $someparam1 = null; # 首字母下环线 $_some_param_1 = null; # 某些库的类，下划线和大小写混用 class Abstract_ClassA { } 这里并不探讨各种写法的优缺点，只是风格需要保持统一，不要混用。
2. 良好的编码习惯 如果你仔细看过 PSR 的标准，可能也会注意到某些地方其实是标准无法涉及到的。比如一个超长的表达式在什么时候换行，如何缩进等。</description>
    </item>
    
    <item>
      <title>Googbye 2015 &amp; Hello 2016</title>
      <link>http://0x1.im/posts/2015-12-31-hello-2016/</link>
      <pubDate>Thu, 31 Dec 2015 22:43:22 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-31-hello-2016/</guid>
      <description>2015 是我的本命年，24，也是毕业后变动最大的一年。这一年我基本上是在整理我的学习思路，尝试找一些不一样的事情做。
相应的，换工作了，twice。我有疑虑过，现在也有，但并不后悔。一路前行，一路感知吧。
担忧与坚持 我在 PHP 上的一些坚持可能会给人一种我很死板的错觉。但事实上我也很喜欢尝鲜，各种语言、框架、新颖的玩物、前后端的东西，不过始终没有深入。现在也仍然特别想继续扩宽自己的知识面，希望在其他层面有一项掌握的不过的。我个人并没有说真正去粉什么东西，只是觉得既然使用一项工具，那就应该把它掌握好，维护它，也是维护自己。
至于 PHP 未来会怎么样，我觉得期望还是好的，即使是未来 Web 应用流量会慢慢减小，移动端已经慢慢成为主流的一部分，但是这并不是说后端就不重要了。也许会越来越多样化吧。再者一门语言往深里去探究学习的就是语言的原理和基础的理论了，在这个基础上去构建其他上层的东西也不会太难。
2015 做过的事 杂事：
 从武汉到深圳，迈出探险的第一步 有了些自己的想法，自己的坚持 下半年开始认真写博客 下半年组了个交流群、目前有 60 个人，氛围还可以  技术：
 PHP 的应用知识体系更完全 PHP 内核代码和执行终于能认证梳理理解一下了 对 PHP 各种框架、组件、标准以及 PHP 有了更加系统的了解和深入  读书：
 《HTTP 权威指南》 《图解 TCP/IP》 《flex 与 bison》 《Modern PHP》 《Objective-c 程序设计》 一些技术文章和博客 一些没有记住的&amp;hellip;  不好的地方：
 Linux 上并没有长进 MySQL 没长进 前端知识结构没长进  2016 的期望  继续构建并完全自己的知识体系 业余时间系统的有计划学习而不是东一点西一点 认证学习理解 C 语言，争取有些算法上的长进 继续深入了解 PHP 内核 争取在应用后端构建与服务器架构体系上有些更先进的认知  Happy New Year!</description>
    </item>
    
    <item>
      <title>[译]变量在 PHP7 内部的实现（二）</title>
      <link>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</link>
      <pubDate>Sun, 20 Dec 2015 22:54:48 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</guid>
      <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
第一部分讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。
复杂的 zval 数据值有一个共同的头，其结构由 zend_refcounted 定义：
struct _zend_refcounted { uint32_t refcount; union { struct { ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) } v; uint32_t type_info; } u; }; 这个头存储有 refcount（引用计数），值的类型 type 和循环回收的相关信息 gc_info 以及类型标志位 flags。
接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。
字符串 PHP7 中定义了一个新的结构体 zend_string 用于存储字符串变量：
struct _zend_string { zend_refcounted gc; zend_ulong h; /* hash value */ size_t len; char val[1]; }; 除了引用计数的头以外，字符串还包含哈希缓存 h，字符串长度 len 以及字符串的值 val。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。</description>
    </item>
    
    <item>
      <title>php-cs-fixer (PHP Coding Standards Fixer)</title>
      <link>http://0x1.im/posts/2015-12-18-php-cs-fixer/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-18-php-cs-fixer/</guid>
      <description>php-cs-fixer 是个代码格式化工具，格式化的标准是 PSR-1、PSR-2 以及一些 symfony 的标准。这个工具也和 symfony、twig 等优秀的 PHP 库出自同门。
安装与更新 需要使用 PHP 5.3.6 以上的版本。
你可以直接下载封装好的 phar 包：php-cs-fixer.phar；
或者通过 wget 下载（下面的都是 OSX 和 Linux 上的用法）：
wget http://get.sensiolabs.org/php-cs-fixer.phar -O php-cs-fixer 或者通过 curl 下载：
curl http://get.sensiolabs.org/php-cs-fixer.phar -o php-cs-fixer 下载完成后给可执行的权限，然后移动到 bin 目录下面即可：
sudo chmod a+x php-cs-fixer sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer 这样就可以在任何地方直接使用 php-cs-fixer 命令来调用了。
也可以用过 Composer 来安装：
composer global require fabpot/php-cs-fixer 如果你是 Mac 用户、homebrew 用户并且已经 tap 过 homebrew/php 的话，也可以直接：
brew install php-cs-fixer 或者：
brew install homebrew/php/php-cs-fixer 如果后续需要更新的话：</description>
    </item>
    
    <item>
      <title>[译]变量在 PHP7 内部的实现（一）</title>
      <link>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</link>
      <pubDate>Thu, 10 Dec 2015 00:39:46 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</guid>
      <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。
PHP5 中的 zval PHP5 中 zval 结构体定义如下：
typedef struct _zval_struct { zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; } zval; 如上，zval 包含一个 value、一个 type 以及两个 __gc 后缀的字段。value 是个联合体，用于存储不同类型的值：
typedef union _zvalue_value { long lval; // 用于 bool 类型、整型和资源类型  double dval; // 用于浮点类型  struct { // 用于字符串  char *val; int len; } str; HashTable *ht; // 用于数组  zend_object_value obj; // 用于对象  zend_ast *ast; // 用于常量表达式(PHP5.</description>
    </item>
    
    <item>
      <title>PHP7 的抽象语法树（AST）带来的变化</title>
      <link>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</link>
      <pubDate>Fri, 20 Nov 2015 12:58:25 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</guid>
      <description>本文大部分内容参照 AST 的 RFC 文档而成：https://wiki.php.net/rfc/abstract_syntax_tree，为了易于理解从源文档中节选部分进行介绍。
本文并不会告诉你抽象语法树是什么，这需要你自己去了解，这里只是描述 AST 给 PHP 带来的一些变化。
新的执行过程 PHP7 的内核中有一个重要的变化是加入了 AST。在 PHP5中，从 php 脚本到 opcodes 的执行的过程是：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，在此阶段生成 op arrays。  PHP7 中在语法分析阶段不再直接生成 op arrays，而是先生成 AST，所以过程多了一步：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，从 token 流生成抽象语法树； Compilation：从抽象语法树生成 op arrays。  执行时间和内存消耗 从以上的步骤来看，这比之前的过程还多了一步，所以按常理来说这反而会增加程序的执行时间和内存的使用。但事实上内存的使用确实增加了，但是执行时间上却有所降低。
以下结果是使用小（代码大约 100 行）、中（大约 700 行）、大（大约 2800 行）三个脚本分别进行测试得到的，测试脚本： https://gist.github.com/nikic/289b0c7538b46c2220bc.
每个文件编译 100 次的执行时间（注意文章的测试结果时间是 14 年，PHP7 还叫 PHP-NG 的时候）：
    php-ng php-ast diff     SMALL 0.</description>
    </item>
    
    <item>
      <title>两行代码给 PHP7 添加一个“非空合并”语法糖</title>
      <link>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</link>
      <pubDate>Sun, 08 Nov 2015 18:22:26 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</guid>
      <description>我们知道从 PHP 5.3 起三元运算符 ? : 有一个写法简洁写法是这样的：
&amp;lt;?php $a = 0; $b = $a ?: 1; # $b === 1 这实际上相当于：
&amp;lt;?php $a = 0; $b = $a ? $a : 1; # $b === 1 在 PHP5 中，语法分析是这样写的：
| expr &amp;#39;?&amp;#39; { zend_do_begin_qm_op(&amp;amp;$1, &amp;amp;$2 TSRMLS_CC); } expr &amp;#39;:&amp;#39; { zend_do_qm_true(&amp;amp;$4, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } expr { zend_do_qm_false(&amp;amp;$$, &amp;amp;$7, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } | expr &amp;#39;?&amp;#39; &amp;#39;:&amp;#39; { zend_do_jmp_set(&amp;amp;$1, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } expr { zend_do_jmp_set_else(&amp;amp;$$, &amp;amp;$5, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } 在 PHP7 中，由于 AST（抽象语法树）的引入，语法分析有些简化：</description>
    </item>
    
    <item>
      <title>max/min 函数（PHP）的一个小 BUG</title>
      <link>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</link>
      <pubDate>Sat, 07 Nov 2015 13:30:22 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</guid>
      <description>先直接来看一段展示：
# Psy Shell v0.3.3 (PHP 5.5.30 — cli) by Justin Hileman &amp;gt;&amp;gt;&amp;gt; ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max(-0.0, 0) =&amp;gt; 0.0 &amp;gt;&amp;gt;&amp;gt; max(ceil(-0.5), 0) =&amp;gt; -0.0 上面的演示中，ceil 函数返回的是 -0.0，max 在将 ceil 函数调用的结果作为参数传入的时候，返回的也是一个 -0.0。
如果给 ceil 的结果赋值给变量，还是能得到 -0.0 的结果：
&amp;gt;&amp;gt;&amp;gt; $a = ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max($a, 0) =&amp;gt; -0.0 下面就来一一分析是哪些原因导致了这些结果的产生。
ceil 会返回 -0.0 首先我们来看一下为什么 ceil 函数会返回 -0.0。
ceil 函数的实现在 $PHP-SRC/ext/stardands/math.c （$PHP-SRC 指的是 PHP 解释器源码根目录）中，为了展示清楚我去掉了一些细节：
PHP_FUNCTION(ceil) { ... if (Z_TYPE_PP(value) == IS_DOUBLE) { RETURN_DOUBLE(ceil(Z_DVAL_PP(value))); } else if (Z_TYPE_PP(value) == IS_LONG) { convert_to_double_ex(value); RETURN_DOUBLE(Z_DVAL_PP(value)); } .</description>
    </item>
    
    <item>
      <title>如何编写一个独立的 PHP 扩展（译）</title>
      <link>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</link>
      <pubDate>Wed, 04 Nov 2015 23:43:58 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</guid>
      <description>本文翻译自 PHP 源码中的 README.SELF-CONTAINED-EXTENSIONS。文中标记了 注 的内容均为自己添加。内容有点老，也挺啰嗦，没讲什么深入的内容，但是可以作为入门学习参考。
独立的 PHP 扩展可以独立于 PHP 源码之外进行分发。要创建一个这样的扩展，需要准备好两样东西：
 配置文件 (config.m4) 你的模块源码  接下来我们来描述一下如果创建这些文件并组合起来。
准备好系统工具 想要扩展能够在系统上编译并成功运行，需要准备转以下工具：
 GNU autoconf GNU automake GNU libtool GNU m4  以上这些都可以从 ftp://ftp.gnu.org/pub/gnu/ 获取。
注：以上这些都是类 Unix 环境下才能使用的工具。
改装一个已经存在的扩展 为了显示出创建一个独立的扩展是很容易的事情，我们先将一个已经内嵌到 PHP 的扩展改成独立扩展。安装 PHP 并且执行以下命令：
$ mkdir /tmp/newext $ cd /tmp/newext 现在你已经有了一个空目录。我们将 mysql 扩展目录下的文件复制过来：
$ cp -rp php-4.0.X/ext/mysql/* . # 注：看来这篇 README 真的需要更新一下了 # PHP7 中已经移除了 mysql 扩展部分 到这里扩展就完成了，执行：
$ phpize 现在你可以独立存放这个目录下的文件到任何地方，这个扩展可以完全独立存在了。
用户在编译时需要使用以下命令：
$ .</description>
    </item>
    
    <item>
      <title>getimagesize 函数不是完全可靠的</title>
      <link>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</link>
      <pubDate>Mon, 26 Oct 2015 23:12:53 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</guid>
      <description>getimagesize 函数并不属于 GD 扩展的部分，标准安装的 PHP 都可以使用这个函数。可以先看看这个函数的文档描述：http://php.net/manual/zh/function.getimagesize.php
如果指定的文件如果不是有效的图像，会返回 false，返回数据中也有表示文档类型的字段。如果不用来获取文件的大小而是使用它来判断上传文件是否是图片文件，看起来似乎是个很不错的方案，当然这需要屏蔽掉可能产生的警告，比如代码这样写：
&amp;lt;?php $filesize = @getimagesize(&amp;#39;/path/to/image.png&amp;#39;); if ($filesize) { do_upload(); } # 另外需要注意的是，你不可以像下面这样写： # if ($filesize[2] == 0) # 因为 $filesize[2] 可能是 1 到 16 之间的整数，但却绝对不对是0。 但是如果你仅仅是做了这样的验证，那么很不幸，你成功的在代码里种下了一个 webshell 的隐患。
要分析这个问题，我们先来看一下这个函数的原型：
static void php_getimagesize_from_stream(php_stream *stream, zval **info, INTERNAL_FUNCTION_PARAMETERS) { ... itype = php_getimagetype(stream, NULL TSRMLS_CC); switch( itype) { ... } ... } static void php_getimagesize_from_any(INTERNAL_FUNCTION_PARAMETERS, int mode) { ... php_getimagesize_from_stream(stream, info, INTERNAL_FUNCTION_PARAM_PASSTHRU); php_stream_close(stream); } PHP_FUNCTION(getimagesize) { php_getimagesize_from_any(INTERNAL_FUNCTION_PARAM_PASSTHRU, FROM_PATH); } 限于篇幅上面隐藏了一些细节，现在从上面的代码中我们知道两件事情就够了：</description>
    </item>
    
    <item>
      <title>Laravel 模板引擎（Blade）原理简析</title>
      <link>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</link>
      <pubDate>Sun, 25 Oct 2015 23:50:33 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</guid>
      <description>上次提到过，模板引擎一般是要做三件事情：
 变量值的输出（echo） 条件判断和循环（if &amp;hellip; else、for、foreach、while） 引入或继承其他文件  现在就来看看 Laravel 的模板引擎是如何来处理这三件事情的。我是在 Laravel 5.1 的实现上来写这篇文章的。
1. 视图解析流程 Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：.blade.php 后缀的认为是模板视图文件，其他的 .php 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。
在使用 View 组件输出时，不管是调用 helpers 中提供的 view 函数还是使用 Facades 提供静态接口 View::make()，实际上执行的都是 Illuminate\View\Factory 中的 make 方法。以此为入口，很容易就能知道视图解析输出的流程：
 查找视图文件； 根据文件名后缀从 Container 中取出响应的引擎； 加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。  Factory 中的一些方法完成了以上第一步的过程，文件查找是调用的 FileViewFinder,其中使用了一些 Illuminate\Filesystem\Filesystem 中的方法，这个类中还有一些方法是跟 events 相关的，这里就忽略不表了。
在以上步骤中，如果中获取到的视图文件是需要“编译”的，引擎会调用 “Blade 编译器”将原视图进行“编译”并保存在 cache 目录中然后加载输出。下次调用时如果发现源文件并没有被修改过就不再重新编译而是直接获取缓存文件并输出。
CompilerEngine 调用的编译器是 CompilerInterface 接口的实现，默认情况下也就只有 BladeCompiler（如果不知道解析器是如何注入的，你需要去了解 Laravel 的服务容器，这里就不细表）。</description>
    </item>
    
    <item>
      <title>PHP 7 的几个新特性</title>
      <link>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</link>
      <pubDate>Sun, 18 Oct 2015 15:29:42 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</guid>
      <description>1. ?? 运算符（NULL 合并运算符） 把这个放在第一个说是因为我觉得它很有用。用法：
$a = $_GET[&amp;#39;a&amp;#39;] ?? 1; 它相当于：
&amp;lt;?php $a = isset($_GET[&amp;#39;a&amp;#39;]) ? $_GET[&amp;#39;a&amp;#39;] : 1; 我们知道三元运算符是可以这样用的：
$a ?: 1 但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。
2. 函数返回值类型声明 官方文档提供的例子（注意 ... 的边长参数语法在 PHP 5.6 以上的版本中才有）：
&amp;lt;?php function arraysSum(array ...$arrays): array { return array_map(function(array $array): int { return array_sum($array); }, $arrays); } print_r(arraysSum([1,2,3], [4,5,6], [7,8,9])); 从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。
这种声明的写法有些类似于 swift：
func sayHello(personName: String) -&amp;gt; String { let greeting = &amp;#34;Hello, &amp;#34; + personName + &amp;#34;!</description>
    </item>
    
    <item>
      <title>现在写 PHP，你应该知道这些</title>
      <link>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</link>
      <pubDate>Sun, 11 Oct 2015 22:50:43 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</guid>
      <description>首先你应该是在用 PHP 5.3 以上的版本，如果 PHP 版本在这之下，是时候该升级了。我建议如果有条件，最好使用最新的版本。
你应该看过 PHP The Right Way，这篇文章包含了很多内容，而且还能再扩展开。大部分的名词和概念你都需要了解。
1. PSR  The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together.
 在之前的文章中以及跟同事交流的过程中我多次提到过 PSR（PHP Standard Recommendation）。很多人以为 PSR 只是做一些规范代码风格等无关痛痒的事情，但其实远不止此。
PSR 的一系列标准文档由 php-fig (PHP Framework Interop Group)起草和投票决议，投票成员中有一些主流框架和扩展的作者，包括 Laravel、Symfony、Yii等等。
按照其官网的说法，这个组织的目的并不是告诉你你应该怎么做，只是一些主流的框架之间相互协商和约定。但是我相信这些框架和扩展中总会有你用到的。
PSR 目前通过的共有 6 份文档：
 0：自动加载（主要是针对 PHP 5.3 以前没有命名空间的版本） 1：编码规范 2：编码风格推荐 3：Log 结果 4：自动加载更细（在出现命名空间后有很大的改变） 7：HTTP 消息接口  目前在起草（Draft）中的还有 PSR-5(PHPDoc Standard)、PSR-6(Cache)等。5 和 6 没有出现在以上的列表中，是因为还没有投票通过。</description>
    </item>
    
    <item>
      <title>说说 PHP 的 die 和 exit</title>
      <link>http://0x1.im/posts/2015-09-24-php-exit-die/</link>
      <pubDate>Thu, 24 Sep 2015 00:25:44 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-09-24-php-exit-die/</guid>
      <description>今天有小伙伴说 exit 和 die 有一点差别。我说 die 不就是 exit 的别名吗？为了证明我的观点，翻了翻 PHP 的源码，在 zend_language_scanner.l 中，很容易就能发现这关键字是同一个 token：
&amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;exit&amp;#34; { return T_EXIT; } &amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;die&amp;#34; { return T_EXIT; } 所以最终也是同一个 Opcode：ZEND_EXIT。所以这两个关键字没有任何差别，这其实也没什么好说的。
我顺便提醒了小伙伴们一句：不要用 exit 输出整数。原因也很简单，在 PHP 官网的文档里就能看到：
 void exit ([ string $status ] )
void exit ( int $status )
如果 status 是一个字符串，在退出之前该函数会打印 status 。
如果 status 是一个 integer，该值会作为退出状态码，并且不会被打印输出。 退出状态码应该在范围0至254，不应使用被PHP保留的退出状态码255。 状态码0用于成功中止程序。
 所以如果 status 是一个整数，会被当成状态码输出，而不是打印，所以如果想返回给前端是不可能的。
那么这个状态码有什么用呢？
大家都知道 shell 脚本执行可以返回一个状态码，PHP 的脚本的执行返回的状态码是一样的，可以在环境变量中被捕捉到：
Scholer: ~ $ php -r &amp;#39;exit(254);&amp;#39; Scholer: ~ $ echo $?</description>
    </item>
    
    <item>
      <title>Python 版 APM 服务使用测试</title>
      <link>http://0x1.im/posts/2015-09-06-tingyun-probe-for-python/</link>
      <pubDate>Sun, 06 Sep 2015 11:40:24 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-09-06-tingyun-probe-for-python/</guid>
      <description>后端开发与云服务 云服务这个词，大概最早是从云盘开始的，那时候概念也特别简单，无非就是把一些数据存在别人的服务器上，在”云存储”这个名词火起来之前，QQ 也有提供网站的功能用来存一些小东西（05年06年的样子，那时候大概只有几十 M 的空间），其实刚听到这个概念的时候我就很不理解，光存存东西不至于吹得这么玄乎吧。毕业后入行，云服务器才慢慢真真的丰富起来，从最开始的 VPS 变成云服务器、存储变成资源服务器、远程数据库等等，现在甚至有帮你防 DDOS 的服务（去年和今年貌似 DDOS 变得越来越没有节操了）。确实节省了很多精力，也省钱。
除了云，最近几年还有另外一个比较火的词：&amp;ldquo;大数据”。我没接触过那么大的数据，作为一个半吊子运维，接触的最大的数据应该就是服务器 log 了。所以大数据的东西以后有机会接触再说，对我来说更重要的是 — 数据统计。
服务端的各种 log 不仅是分析服务器的状态的重要参数，也是从后台代码里抓 bug 抓异常检查 SQL 性能等各种工作的参考。log 数据一般都是单调而且重复的居多，要发现它的价值，往往需要大量的分析和统计工作。各种监控服务、分析工具也是层出不穷。不过到今年我才知道有个词叫 &amp;ldquo;APM&amp;rdquo;。
APM (Application Performance Management/Monitoring) 简单翻译过来就是&amp;quot;应用性能管理/监控”(也许说监控更准确一些)。大概就是服务器上部署的 awstats、nagios、zabbix 等一堆东西的集合。有服务器的地方就有云，既然这个事情这么麻烦，那就自然也可以交给别人来做了。
前几天找到了一个 Python 的小 web 框架：bottle，只有一个文件，简洁好用，觉得很不错，先是用它来做了一个简单的小应用（APP 下载，公司内部使用），准备这段时间尝试用它来自己写一个简单的博客系统，改造一下自己的博客，所以业务时间花在搞 Python 上的比较多一点。恰好看到了在测 Python 版本的探针，于是部署来测试一下。部署之前先在本地做了一些测试，不过听云目前仅支持基于 django 开发的程序（文档上写的目标是支持所有以 wsgi 协议部署的 Python Web 服务，包括 flask、tornado 等等，不过这个应该还要等后续开发支持了），所以我就先在本地用 django 测了一下。
听云探针(Python版)的使用 探针部署过程十分简单，在听云后台复制自己账户的 license key，生成配置文件，将配置文件地址加载到环境变量中，就可以启动程序开始使用了。以下是测试环境部署步骤的介绍。
先用 virtualenv 开辟一个环境并 active 之：
virtualenv tingyun cd tingyun source bin/active 听云探针在 pypi 的仓库里有，所以可以直接安装了，同时也安装 django , 探针支持 MySQL 的 log 记录，所以我也安装了 MySQL 的组件并将 django 的数据库从 sqlite 改成 MySQL：</description>
    </item>
    
    <item>
      <title>2015年5月 ~ 6月离职求职历程</title>
      <link>http://0x1.im/posts/2015-06-15-find-a-new-job/</link>
      <pubDate>Mon, 15 Jun 2015 18:26:32 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-06-15-find-a-new-job/</guid>
      <description>起因 其实有离职的想法是去年十一月的事情，但是有点舍不得，四月份的时候我还说再看一看，再呆一年，但是后来实在忍不住了。
历程   5.17（周日） 找了房子，但是感觉不是特别喜欢，给房东交了200块钱押金，晚上请两个朋友吃饭，喝了点酒，回来之后决定离职。
  5.18（周一）跟以前在腾讯的师兄聊了一下，他说可以换个环境试试看。发了一份之前整理的技能表给他，他表示可以。下午下班之后跟老板聊了下，表达了离职的意愿，他说让我再考虑下，六月份我们再聊一次。跟师兄说已经提出了口头离职，师兄说要不要让他们负责人跟我联系一下，我说行。晚上回来之后整理一份简单的简历，就是最初的技能列表加上简单的项目经理，在拉勾上分别投了腾讯和杭州的某街。
  5.19（周二）腾讯接收简历，一个大哥提醒我再修改下，项目经历丰富下。某街拒了我的简历，女朋友看了下说你看别人是要数据挖掘的，你肯定不懂这个（哈哈，我说好像是，她可有成就感了，因为她根本不懂我们这个行业）。晚上腾讯的另外一个大哥联系我进行了第一次远程面试，从十一点半到一点钟。一些基本的问题，然后问了三个比较浅的技术问题，我基本上都在一分钟之内给出了答案。最后问了下git的使用、了不了解node之类的（他告诉我他们是一个前端团队，招人是进去和运营那边沟通，是这边的人，做那边的工作），然后说没什么问题，让我等待下一轮技术面试。三个问题是：
 举例说明多对多的应用场景（我说了用户和标签的例子） 在这种应用场景下，获取某标签的全部用户，写出SQL语句 说明MVC的流程和关系，Router的作用    5.21（周四）腾讯这边的人跟我说这两天电话保持畅通，应该这两天会有电话面试。
  5.22（周五）我问师兄需不需要再发一份完整的简历给他，他说不用，他已经把我发给他的md格式的文档转成pdf了，负责人会电话我的，这两天可能比较忙。同天我跟室友商量了下我们再租一个月（室友硕士毕业，要离开武汉了），跟现在的房东说了下，房东阿姨表示同意（住了近两年，好说话）。然后告诉新房子的房东，说不租了，押金不要了。
  5.23 （周六）焦急的等待着两个电话。白天看了下node.js的express框架，晚上又优化了下简历上技能列表的格式，取名简历2.0，直接把markdown格式的文档上传到了jobdeer。我之所以没有继续在拉勾上投简历，是因为我想等师兄这边和腾讯这两个电话结束之后再进行下一轮，时间上我并不是特别着急，因为理论上只要在6月底之前找到新工作就好了。
  5.24（周日）等待中，开始整理这一份求职历程文档，同时继续看express的文档。。。
  5.25（周一）jobdeer审核简历通过，排期在29号。但是下午四点多接到jobdeer这边的电话，核对了下资料，说明天上午就可以开始竞拍了。晚上问了腾讯这边的大哥，说他已经催了，再等两天，技术面那边的人比较忙。
  5.26（周二）十点半简历在jobdeer上上线，到十一点半收到了七个查看简历的请求，其中居然蘑菇街有两个（不过为什么发来的介绍里面写的是招java？私信问了下说PHP也招），其他的还有房多多、贝贝网。腾讯这边的大哥联系我问我有没有漏接电话，我说没有。重新确认了一下联系方式，过一会儿腾讯来电话，约在晚上七点电话面试。莫名其妙的接了一个分期乐的电话，说是在论坛上看到的我的电话，我只在两个地方留过联系方式，一个是拉勾，一个是jobdeer，所以肯定有一家有信息泄露。jobdeer这边贝贝网是第一个发起面试邀约的。定在后天晚上七点之后电话聊一下。晚上下班回来，对面小区施工有点吵，我关上窗户给手机充电，静静的等待电话。电话准时打来，听声音是个中年大叔。问题很多，涉及的层面也很宽泛从304的含义到MyISAM和InnoDB的区别、Apache与Nginx，fastcgi，jQuery选择器等等。放下电话之后我有些释然了，虽然不是那么好，但至少也说明这两年时间我也不算是虚度了。以下三个问题没答好：
 闭包（我当时把闭包和匿名函数搞混了） MySQL联合索引（这个是真正说错了，我居然说成了跨表……） 集合模式（他把继承和集合放在一起说的，我没反应过来集合是什么，不就是一个类里面套多个其他类的实例么……）    5.27（周三）师兄这边公司在十一点打来电话。问了一些PHP和Linux方面的问题，偏底层，有些我没有答上来。最后我也征求了一些建议。说有空的话可能还是需要到深圳见面聊聊，我说可以。
  5.28（周四）贝贝网面试电话，果然技术深度还是不一样，问了php数组排序有哪些函数、Linux常用的有那些命令，以及对CI了不了解。
  5.31（周日）蘑菇街又来电话，说再考察下技能。可是总感觉蘑菇街问的问题都不在点子上。
  6.1（周一）贝贝网又电话来问什么时候能去面谈。
  6.2（周二）师兄的公司约周六面谈，订了到深圳的机票。
  6.3（周三）腾讯通知：第一轮过了，等第二轮。晚上腾讯打来电话，问了一些比较宽泛的问题，我说的不是很好，一个是为什么用redis比mysql快（这个大概是因为一个是kv数据库是hash存储，查询快，类似PHP的HashTable，再一个redis自己实现的事件事件分离器，非阻塞式的异步IO），一个是nginx为什么比apache更快（大概是因为事件驱动（epoll）、异步IO，事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务）。说还是想面谈一下，我说周六到深圳，那就约在周一吧。
  6.6（周六）早晨五点四十起床，地铁到长岗路然后坐用去哪儿叫的专车，110块到了机场。十点半到深圳，十一点坐上机场8线，十一点半到科兴科学园，先去吃了个午饭，到了公司，显示负责人聊一下，然后技术总监，然后HR。然后我到酒店，在路上offer邮件就来了，还比较顺利。
  6.7（周日）在酒店，查了些可能会问到的知识点。快到中午的时候出去了一趟，去企鹅大厦楼下和深圳大学看了看，天气太热，回来了。想了想自己上学、工作之类的事情。
  6.8（周一）早晨深圳的公交上的人简直太多了，等了一会儿决定步行，差不多八点二十开始走，九点十分左右到科兴，在C栋楼下喝了一杯鲜榨橙汁。九点半准时给联系人打电话，告诉我可以上去。上去之后他告诉我今天上午是总监面试，然后我们先聊了一会儿。具体也没有什么细节上的技术问题，都是问个人的基本情况，这些年收获了些什么之类了。过了一会儿总监来了，也是问了些类似的问题，甚至包括运不运动，一周运动几次。大概前后一个小时的时间就结束了，然后我下楼等了一会儿，吃了个饭，就坐上公交去了深圳北站。火车站人真的好多。
  6.</description>
    </item>
    
    <item>
      <title>使用Nginx 的 image filter 模块裁剪图片</title>
      <link>http://0x1.im/posts/2015-04-09-use-nginx-image-filter-module/</link>
      <pubDate>Thu, 09 Apr 2015 15:36:35 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-04-09-use-nginx-image-filter-module/</guid>
      <description>背景 项目中有个地方需要根据客户端的要求缩放图片。最开始想用PHP来实现这个功能。设想中如果已经存在图片a.jpg，则可以通过类似a_400x400.jpg的方式来获取图片特定尺寸的缩略图。
要实现此功能可以在图片上传的时候就事先裁好指定尺寸的图片，或者在获取的时候拦截请求来实现。
如果使用第一种方法，则只能实现裁剪好预设尺寸的图片，而且会影响到上传图片的效率，如果裁剪失败，也无法后续处理。
使用第二种方式的问题是图片资源存储在一个静态资源的目录，需要在没有图片的情况下将请求转发给PHP去处理。
于是我设想能否在Nginx这一层去做这件事情，恰好Nginx有一个image filter的模块，只不过在编译的时候默认没有编译进去。
手动添加参数编译此模块，开始修改nginx的配置文件。
配置 第一个版本的配置如下：
# 我使用16进制数的方式给图片重命名 location ~* /(.*)\/([0-9a-f]+)_(\d+)x(\d+)\.(jpg|png|jpeg|gif)$ { # 如果存在文件就终止规则 if (-f $request_filename) { break; } # 设定一些参数 set $filepath $1; set $filename &amp;#34;$2.$5&amp;#34;; set $thumb &amp;#34;$2_$3x$4.$5&amp;#34;; set $width $3; set $height $4; # 如果原文件不存在可以直接返回404 if (!-f $document_root/$filepath/$filename) { return 404; } # 重写URL rewrite /(.*)\/([0-9a-f]+)_([0-9x]+)\.(jpg|png|jpeg|gif) /$1/$2.$4 break; # 执行图片缩放 image_filter test; image_filter resize $width $height; image_filter_jpeg_quality 75; } 但是在这个版本的配置中，如果配置原文件不存在，实际上没法正确返回404，而是返回415。过滤还是执行了。
还有一个问题就是在每次访问缩略图的时候都会重新生成，如果访问量比较大的情况下，效率并不高。
进过一系列的实践后，我又改好了一个版本：</description>
    </item>
    
    <item>
      <title>2014 年总结 &amp; 展望 2015</title>
      <link>http://0x1.im/posts/2015-01-17-summary-2014/</link>
      <pubDate>Sat, 17 Jan 2015 21:50:38 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2015-01-17-summary-2014/</guid>
      <description>2014 2014 年已经结束了；一个完整的工作年，也该对工作和生活做一些简单的总结了。
上半年基本上还是处于一种刚毕业找不到状态的感觉中，加上玩儿游戏时间过长的关系，在Coding 的道路上没什么长进。无非就是多了解下PHP，看看Python等。
新的电脑拿回来之后，稍微了解了一下WP的应用的结构，也算是对客户端APP的一个基础了解。对于后端开发有些促进作用。（现在又搞了本swift 的书看看iOS的。）
下半年的时间里游戏时间要少一些，可以总结的要多一些：
 在Linux 的道路上越走越远，使用越来越熟练，解决问题比较轻松； 去年是安全问题爆发的一年，也促使我安全方面的知识增加了了解，系统了解了Web 安全方面的问题； 在PHP 上，上手了Laravel，这是一个不错的框架，适合学习； 开始尝试看一些PHP 解释器的源码，尝试从C语言的角度理解PHP； 花了些时间多看了一些基础和底层的知识，偶尔了解一些其他的语言，通过比较增加见识；  这一年看过的一些书：
 C与指针 Linux程序设计 高可用MySQL：构建健壮的数据中心 深入浅出Windows Phone8应用开发 Swift语言实战入门  这里面没有一本PHP的书，但其实收获最多的还是PHP。（因为现在对我来说PHP重要的知识不是通过看书来的~）
过去的一年在技术上面对我来说最重要的两部分：PHP, Linux。
我对自己的对位：一个兼职运维的PHP程序员。
2015 2015 年，我希望自己能完成或者学习以下的技能：
 通过阅读Laravel的源码来理解它以及它的思想； 多阅读PHP解释器的代码； 写面向对象的代码，多理解一些设计模式； 我希望能做一个用swift的iOS应用； 我希望能在Github上发布一个有意义、写的不错的项目； 我希望在Linux上更精进一些；  Happy New Year!</description>
    </item>
    
    <item>
      <title>开始学习和使用Laravel</title>
      <link>http://0x1.im/posts/2014-12-14-start-to-learn-laravel/</link>
      <pubDate>Sun, 14 Dec 2014 18:36:44 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-12-14-start-to-learn-laravel/</guid>
      <description>About Laravel Laravel是一个最近两年兴起的框架，在去年的PHP框架流行程度统计中居首，占据25.87%的份额。 Laravel是一个面向对象的PHP框架，大量运用了PHP5的特性。Laravel 4.0的版本需要在PHP 5.3.7 以上的环境中运行，而最新的4.2 版本则需要PHP 5.4以上的环境。 Laravel是一个重量级的框架，依赖于PHP社区中的现有标准、框架来实现。所以学习Laravel要先从以下几个项目和概念开始。
PSR PSR的全称是PHP Standard Recommendation (PHP标准推荐)，是由PHP-FIG (PHP Framework Interop Group) 创导并规定的，到目前一共发不过5个标准 (PSR-0 ~ PSR-4)。
PSR项目的github地址：https://github.com/php-fig/fig-standards 关于PSR的具体介绍可以参考：http://segmentfault.com/a/1190000000380008
PSR:
 PSR-0 自动加载 PSR-1 基本代码规范 PSR-2 代码样式 PSR-3 日志接口 PSR-4 autoloader, PSR-4可以替代PSR-0, 也可以和包括PSR-0在内的其他自动加载机制共同使用  Laravel 中并不直接使用到PSR，而是因为Laravel 使用了另外一个项目：Composer。
Composer Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。类似于Node.js的npm 和 Ruby的 bundler。
Packagist 是Composer 的主要资源库，默认的，Composer 只使用Packagist 仓库。通过指定仓库地址，你可以从任何地方获取包。
Composer支持PSR-0,PSR-4,classmap及files包含以支持文件自动加载。
Laravel 使用Composer 安装。安装完成后vendor 目录下得composer 目录下有autolad 文件，会根据项目需要加载的类生成classmap。在项目中只需要：
 require &amp;lsquo;vendor/autoload.php&amp;rsquo;;
 即可自动加载所有需要的类。
Composer 中文文档：http://docs.</description>
    </item>
    
    <item>
      <title>一个XSS带来的一些收获和警示&amp;常见安全问题总结</title>
      <link>http://0x1.im/posts/2014-09-22-one-month-begin-with-a-xss/</link>
      <pubDate>Mon, 22 Sep 2014 21:55:59 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-09-22-one-month-begin-with-a-xss/</guid>
      <description>一个月前我们遭遇了一次XSS，原因很简单：输入内容没有做检查。说起来也很蠢：前端没有检查、写数据库没有检查、Cookie也不是Httponly的，所有可以做的防御措施，我们全部都轻松的避过去了。这样别人轻松的就拿到cookie登录到后台了。
而最近又先后爆出SSL心脏滴血、Bash破壳漏洞等重大的安全问题，所以这一个月我就恶补了一些关于安全的知识，在代码和网站中去是不是以前忽略过的坑坑洼洼。有些东西可以总结一些。很基础但也很容易忽略。
一、常见的攻击方式及防御 1. XSS注入 XSS注入是最常见的、最容易的，但危害性缺不小。对于需要登录的网站，拿到cookie就意味着可以登入后台。如果后台是管理员用的，那意味着网站的大部分信息都暴漏了。如果是用户的后台，一次注入可能就意味着很多用户的私人信息暴漏在了别人面前。
XSS原理简单、手法说起来也不复杂。只要有输入框，没有做过滤，就留给了有心人一个注入代码的可能。通过注入代码调用远程的js文件，可以轻松获取到cookie等信息。
XSS的的基本防御是对用户输入的内容做好过滤，对于一些特殊字符的进行必要的处理。特别是需要写入到数据库里的数据。
2. CSRF攻击 别人诱导你点了一个链接、向后端发了一个请求，这个请求下转走了你支付宝里的钱，这就是CSRF。我登录了A站，A站有扣款的服务。我又登陆了B站，B站有个按钮实际上是A站的扣款链接，我并不知情，基本上就是这样的。
防御CSRF的关键在于后端要判断出请求是不是来自于自己呈现给用户的网页。在客户端的输入框隐藏一个输入框，框里留一个随机数，后端校验这个随机数，就能有效防御绝大部分的CSRF攻击。因为其它的网页和你的网页同时在浏览器存在的时候，从他的网页里请求你的连接时，虽然能带上cookie等信息，但是他的网页却没办法从你的网页里获取到这个随机数。
3. SQL注入 SQL注入与XSS类似，也是从输入入手。但不同于XSS，SQL注入的内容可能并不是在输入框里进行的。一个请求需要根据用户请求的内容查询数据库，就意味着可能会有SQL注入的风险。通过与预期不同的字符串进行查询，构造SQL语句来获取数据库的信息，哪怕是有一个SQL注入的漏洞不小心暴漏给了有心的人，可能整个数据库就要沦陷了。
SQL注入的防御工作也是要对从前端获取到的查询信息进行严格的过滤。对于不在预期之内的字符串进行完善的处理。
4. 被上传webshell 所谓webshell，就是能通过浏览器直接在服务器上操作命令，甚至读取到结果。webshell是由上传而已。比如PHP可以通过system命令或者exec命令执行系统命令。如果有心的人上传一个脚本到你的服务器，脚本中带上了一句：echo system($_GET[&#39;cmd&#39;]);，很不幸，他能执行任何web服务器和PHP解释器有权限执行的命令。
预防webshell需要对上传文件做严格的限制，严格控制上传文件的格式，检查上传的内容。如果是有特殊必要，也要对上传文件的访问做好严格的限制。
同时也要关注服务器、web服务器和脚本解释器的动态，比如Bash的破壳漏洞、IIS6的解析漏洞，及时防御才能规避风险。
二、开发和管理系统过程中的注意事项 许多事情需要在平时开发和维护的过程中注意，处理好一些上的问题，往往能有效的规避大部分的风险。
1. 特殊文件和特殊路径的问题 不要让不该显示的信息显示出去，不要让不该让人访问的东西让别人看到。
刚搭好环境，有时候习惯随手写个phpinfo.php放那里检查一下，事后忘记了处理，别人正好看到了，猜解路径、或者恰好又拿到了别的把柄，一整个网站基本上也就去了。
一些框架特定的版本爆出来大的漏洞，而你恰好留了version或license文件在网站跟目录，替别人省了很多事情。比如thinkphp曾经有过任意代码执行漏洞。
直接通过svn更新代码，svn早期有些版本会在所有目录下都有.svn目录，有特定的文件命名文件里直接就是代码，而你的web服务器恰好没有解析，整个网站的代码就到了别人手里。即使在新的版本里，根目录下也有个wc.db的文件，而你恰好又没有不允许.svn目录的访问。
管理后台就是一个简单的网站的路径，比如phpmyadmin就是/phpmyadmin，phpmyadmin有几个版本有万能用户名的漏洞，轻轻松松拿到数据库。
项目开发过程中，随手把数据库导出一个sql文件保存在web根目录下面，放到服务器上的时候也没有删除，有人随手去试一试，就把它下载下来了。这是很危险的。
2. 不要使用弱口令 任何时候、任何地方都不要使用弱口令。
像上面所说，即使你的phpmyadmin的版本恰好规避了以上的漏洞，而你安装的时候随手敲了个123456当密码。那基本上等于没有设防。
还有网站后台的admin如果，使用一些简单的网站名称、域名或者常见的数字字母组合当密码，很容易猜解出来。
服务器端的脚本访问数据库也不要用root账户完全权限的账号密码，如果网站被上传webshell，拿到配置文件，而数据库又恰好是超级权限的账户，不近代码暴漏在别人面前，网站也被拖库了。
3. 服务端安全策略与权限分配 如果服务器沦陷了，那基本上任何信息都暴漏在了他人面前，所以做好服务器端的管理尤为重要。登录限制、防暴力猜解、防sqlmap、防端口扫描、监控异常流量和IP能够抵御部分极大的隐患。比如破壳漏洞出现时，有些恶意注入会执行一个ping，如果ping回对方的服务器，你的服务器很快就沦陷到他手里了。如果你恰好禁止了icmp包的output，就能度过一段缓冲期。
在Linux上，每个应用程序都有一个执行的用户，web服务器和脚本解释器的用户权限做好限制、web文件目录做好分配可限制也能防止一些异常命令的执行。
4. 经常检查服务器、数据库等log信息 有时候事情已经发生了，能及时发现及时处理也能把损失降到最低。可怕的时候服务器已经沦陷在别人手里了，你还不知道。
很多时候漏洞和隐患也不是单独存在的，找到一个突破口，往往就能攻陷其它地方。比如在数据库里写入一个webshell语句，然后通过构造查询拿到服务器上的东西。
5. 经常关注安全信息 一个安全问题爆出来之后，不要想当然的认为我这里应该没事，及时检查一下才能有效预防。经常浏览一下乌云和freebuf也能及时获取到相关的资讯。
安全问题是个长期的工作，没有铁打的系统，不是一蹴而就的事情，时时留心最重要。</description>
    </item>
    
    <item>
      <title>Linux(Ubuntu) iptables使用小记</title>
      <link>http://0x1.im/posts/2014-09-20-use-linux-ubuntu-iptables/</link>
      <pubDate>Sat, 20 Sep 2014 14:32:55 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-09-20-use-linux-ubuntu-iptables/</guid>
      <description>1. 基础介绍 netfilter/iptables 是与2.4版本之后Linux内核集成的IP信息包过滤系统。iptables不是防火墙，只是定义过滤规则的工具，读取规则并发挥作用的是netfilter。 netfilter/iptables是内核集成的，不存在start/stop或者禁用的说法。可以用iptables命令创建过滤规则。（现在较新的内核中已经默认集成，无需单独安装）
项目主页：http://www.netfilter.org/projects/iptables/
常用命令：
 查看帮助：iptables -h 查看过滤规则：iptables -L [-n] [-v] 子命令：  -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名 -v：显示详细信息    另外，在实际建立规则的过程中，iptables还需要和以下两个命令配合使用：
 保存创建好的规则到文件：iptables-save 从文件中回复规则：iptables-restore  2. 规则参数 iptables创建规则的命令和参数相当繁杂，基本的规则形式如下：
iptables [-t table] command chain [match] [-j target] 以下是各段命令主要参数的解释。
  -t table，table有四个选项，默认为filter：
 filter：一般的过滤功能，默认的table nat：用于NAT功能（端口映射，地址映射等） mangle：用于对特定数据包的修改 raw：主要用于配合NOTRACK的响应 security：用户强制访问控制(MAC)网络规则    command，定义规则写入方式：
 -P：定义链的默认规则（所有其它规则都没有匹配到的数据包，将按照默认规则来执行） -A：追加，在当前链的最后新增一个规则 -I num：插入，把当前规则插入为第几条 -R num：Replays替换/修改第几条规则 -D num：删除，明确指定删除第几条规则    chain，netfilter可以在五个位置进行过滤：
 PREROUTING (路由前) INPUT (数据包流入口) FORWARD (转发管卡) OUTPUT(数据包出口) POSTROUTING（路由后）    match：匹配规则，常用的规则有以下几种：</description>
    </item>
    
    <item>
      <title>什么时候需要使用urlencode和urldecode函数</title>
      <link>http://0x1.im/posts/2014-09-17-when-to-use-urlencode-and-urldecode/</link>
      <pubDate>Wed, 17 Sep 2014 19:07:27 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-09-17-when-to-use-urlencode-and-urldecode/</guid>
      <description>本文默认的语言为PHP
今天在使用fscokopen的时候需要在输入中带上get参数，测试的时候发现参数传过去有问题，于是简单的把参数urlencode了一下再传，问题解决。
后来检查了一下，原来是在参数中有空格，被拼接在需要通过fputs往scoket里字符串里再写进去就出现问题了。
于是整理了一下关于urlencode和urldecode的小问题：
  除了-._三个字符、大小写字母、数字，其它字符串都会被urlencode处理（虽然encode编码之后的字符串都是数字和大写字母，但是小写字母是不会被编码的）
  通过浏览器在URL后面带GET参数的时候都是经过encode处理的（所以才叫urlencode的嘛）
  PHP在后台接收参数的时候无需经过urldecode的处理了：
 Warning: 超全局变量 $_GET 和 $_REQUEST 已经被解码了。对 $_GET 或 $_REQUEST 里的元素使用 urldecode() 将会导致不可预计和危险的结果
   POST传递和接受参数都不需要经过encode和decode处理，$_POST接收的参数也不会进行解码操作
  在使用fsockopen等函数，通过凭借header信息字符串的方式添加进去的参数，如果经过eneode，需要自己调用urldecode方法
  encode之后的字符串还会可以再次被encode，%会被编码为%25，但是如果在浏览器上带上encode之后的字符串，字符串不会被再次编码
  PHP的urlencode函数被把空格替换成+,rawurlencode函数会空格编码成20%
  </description>
    </item>
    
    <item>
      <title>PHP的session与cookie &amp; CodeIgniter的session修改</title>
      <link>http://0x1.im/posts/2014-09-16-php-session-cookie/</link>
      <pubDate>Tue, 16 Sep 2014 21:01:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-09-16-php-session-cookie/</guid>
      <description>设定cookie的读取为httponly 最近网站被XSS了，还被报到乌云上去了。感谢仁慈的好事者没有做什么破坏，也给我提了醒。郁闷之与，做好防范才是关键。 做好防范，除了做好设置过滤以外，同事提到一个环节是设定cookie的读取模式为httponly。
于是我找了一下什么是httponly。在php.ini中有一个设置参数：
session.cookie_httponly =  试试用ini_set把这个参数置为1，清理cookie刷新一下，结果显示不行。从php.ini文件中改也不行。
于是放弃了这种方法，在CodeIgniter中的源文件中改了几个地方，通过setcookie的参数设定httponly。
但是还有点不死心，想看一下这个参数到底是做什么的。在网上找了一下，也没有专门去讲这个事情的，甚至有些提到这个参数和setcookie混用的。
在PHP的源码中搜了一下，，在ext/session/session.c找到了以下的地方：
if (PS(cookie_httponly)) { smart_str_appends(&amp;amp;ncookie, COOKIE_HTTPONLY); } smart_str_0(&amp;amp;ncookie); php_session_remove_cookie(TSRMLS_C); /* remove already sent session ID cookie */ /* &amp;#39;replace&amp;#39; must be 0 here, else a previous Set-Cookie header, probably sent with setcookie() will be replaced! */ sapi_add_header_ex(estrndup(ncookie.s-&amp;gt;val, ncookie.s-&amp;gt;len), ncookie.s-&amp;gt;len, 0, 0 TSRMLS_CC); 从这段代码中可以看出httponly这个参数是被写在客户端存储session的cookie头上的，所以作用的范围仅限于session，而且只有使用了PHP自己的session的时候才会起作用（这个参数对其它的cookie更是没有任何作用的），在使用session_start()之后，客户端会保存一个cookie记录当前会话的session数据（默认名称是PHPSESSID，通过sesssion.name修改），这里配置的所有关于cookie的参数，都是针对这一条数据的。CI的session是自己实现的。所以使用这个参数当然是没有用的。
于是我梳理了一下cookie和session的知识并记录下来。很多信息从网络上可以获取到。
cookie与session 1.session与session机制
session与session机制是两个的概念。
session，顾名思义，指的是会话的过程，而session机制指的是创建会话过程并维护的方式。 我们说的PHP的session指的是PHP实现并维护的session机制（可以使用session_start()函数开启并使用$_SESSION保存和获取参数），但是我们也可以自己实现或者使用框架里的session实现方式。
2.session机制
一个完善的session机制如下：
  服务器生成一个id作为会话的id，同时可以已这个id为基础存储一些数据，整个session的id和数据可以存在文件里，也可以存在数据库里（PHP的session机制默认是存储文件）。
  服务器把session的id和数据经过整理、加密等一系类过程作为一个数据（字符串）发送给客户端（浏览器），客户端将这个session存储下来。存储的方式可能有多种，最常用的是cookie（也可以是别的方式，只要保证在自己的web程序中可以取到，比如存在一个form标签里也是可以的）。
  客户端（浏览器）发送请求时，带上session数据（大多时候是cookie）一起送给服务器，服务器通过解析这段数据来判断请求来自哪里，已经在这次会话的过程中存储的一些数据（后端）。</description>
    </item>
    
    <item>
      <title>修改CodeIgniter的Pagination类使其支持Ajax分页</title>
      <link>http://0x1.im/posts/2014-09-14-modify-codeigniter-pagination-class/</link>
      <pubDate>Sun, 14 Sep 2014 23:37:54 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-09-14-modify-codeigniter-pagination-class/</guid>
      <description>本文中针对CodeIgniter的问题都是基于2.1.3的版本。
 在使用CodeIgniter做项目的过程中，需要用到ajax来分页，但是CI集成的分页类只支持在URL后面跟分页参数的方式。如果想实现ajax的分页，通过一定的方法也可以实现。
###使用原有实现示例
&amp;lt;?php $config[&amp;#39;base_url&amp;#39;] = &amp;#39;javascript:pageAnchor(\&amp;#39;&amp;#39;; $config[&amp;#39;suffix&amp;#39;] = &amp;#39;\&amp;#39;);&amp;#39;; $config[&amp;#39;first_url&amp;#39;] = &amp;#39;javascript:pageAnchor(\&amp;#39;/0\&amp;#39;)&amp;#39;; $config[&amp;#39;anchor_class&amp;#39;] = &amp;#34;&amp;#34;; //添加你的样式  $config[&amp;#39;cur_tag_open&amp;#39;] = &amp;#39;&amp;lt;a href=&amp;#34;javascript:void(0);&amp;#34; class=&amp;#34;&amp;#34;&amp;gt;&amp;#39;; $config[&amp;#39;cur_tag_close&amp;#39;] = &amp;#39;&amp;lt;/a&amp;gt;&amp;#39;; $config[&amp;#39;prev_link&amp;#39;] = &amp;#39;&amp;amp;lt;&amp;#39;; $config[&amp;#39;next_link&amp;#39;] = &amp;#39;&amp;amp;gt;&amp;#39;; $config[&amp;#39;first_link&amp;#39;] = &amp;#39;&amp;amp;laquo;&amp;#39;; $config[&amp;#39;last_link&amp;#39;] = &amp;#39;&amp;amp;raquo;&amp;#39;; $config[&amp;#39;first_tag_close&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;last_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;next_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;next_tag_close&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;prev_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;num_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;total_rows&amp;#39;] = 100; //数据总条数  $config[&amp;#39;per_page&amp;#39;] = 10; // 这里原来是要配置$config[&amp;#39;uri_segment&amp;#39;] 默认为3  // 分页类中有一个地方  // $CI-&amp;gt;uri-&amp;gt;segment($this-&amp;gt;uri_segment) !</description>
    </item>
    
    <item>
      <title>iOS推送（Apple Push Notification Service）部署总结</title>
      <link>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</link>
      <pubDate>Sat, 09 Aug 2014 15:50:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</guid>
      <description>1. 基础部署  后端：PHP 依赖：zendframework/zendservice-apple-apns 本文中使用的PHP框架：laravel  2. 实现目标  实现中等规模批量设备的推送（1w设备以上），并且有可扩展的余地（十万到百万级） 推送的整体发送时间可控（半小时内，最好数分钟内） 保证推送的到达率能够达到**90%**以上 可以从设备列表中及时剔除无效的设备，并能够从APNs的服务器中及时获取反馈 可以获取到已经卸载的设备信息  3. 基础知识 关于APNs，我们首选需要知道：
 iOS的推送是通过socket链接将详细发送到苹果的服务器，然后由苹果像设备推送来实现的； 在服务的我们需要自己维护一个token的列表用于记录要向哪些设备发送推送； token是由系统提供的，但是有可能会失效，用户也可能会已经卸载应用； 苹果提供有获取feedback的服务器接口用于获取已经卸载应用的的设备token；  在实际操作中发现关于推送的部分：
 向一个已经打开的socket连接写入token和推送消息时，如果有一个token是无效的，socket会断开； 已经卸载应用的设备token不算是无效的token（不会导致连接断开），但是像它发送消息是没有意义的且会增加负担； socket断开之前会向连接中写入一个错误信息，可以捕捉错误的方式知道socket是在什么时候断开的，但是这个消息会有延时，无法保证100%接收到； 错误信息不会直接返回是哪个token，而是返回发送时设定的identifier； socket也会存在其它异常断开的情况； iOS6以下的设备无法通过feedback的接口获取到已卸载的token（测试结果，没有在文档中验证）； feedback的接口取到的是上次推送的过程中出现的已卸载应用的设备token，而且获取一次之后就会清空； 如果想获得卸载应用的feedback，该应用不能是卸载的设备上的仅有的推送应用（如果是最后一个，设备和苹果的推送服务连接会断开）；  4. 实际部署 实际部署中，需要对使用的库做出一些改动。
1.在ZendService\Apple\Apns\Client\Message中增加一个方法用于每次推送结束之后获取反馈：
&amp;lt;?php /** * Get Response * * @return ZendService\Apple\Apns\Response\Message */ public function getResponse(){ if (!$this-&amp;gt;isConnected()) { throw new Exception\RuntimeException(&amp;#39;You must first open the connection by calling open()&amp;#39;); } return new MessageResponse($this-&amp;gt;read()); } ?</description>
    </item>
    
    <item>
      <title>MQTT(使用mosquitto做broker)做Android推送总结</title>
      <link>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</link>
      <pubDate>Mon, 04 Aug 2014 18:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</guid>
      <description>“读万卷书，行万里路”。我觉得这句话用在程序员的工作中就是：在网络中找一万篇资料，在实践中做一万种尝试。
 由于Android的开放性，Android的推送解决方案有很多。这其中最便于使用的，应该是google提供的GCM的方案，但是GCM是基于GMS服务的。由于国内的ROM大多干掉了GMS，或者是由于某些众所周知的原因，我们无法使用这个方案获得稳定的推送服务（这个Apple的APNS不同，APNS是IOS的设备上唯一可用的推送解决方案，也是稳定的方案）。基于这些原因，我们选择了自建推送服务的方式。
###1. 基础建设： 纸上得来终觉浅 绝知此事要躬行
 理论支撑 ：使用MQTT作为Android实现方案的原因源于一篇四年前的文章：How to Implement Push Notifications for Android； 与Web管理的对接 ： 文章的作者同时也提供了PHP端的Client方案：PhpMQTTClient。 服务端 ： 当然，这只是Web端的实现方案，至于后端需要使用的Broker，我们找到了mosquitto。 客户端 ： 在客户端中，我们使用的是来自IBM的wmqtt.jar的包：wmqtt  以上四个基本条件是我们具备了部署基于MQTT协议的Android的推送服务的基本条件。在最初的测试中，也没有遇到过太大的问题，测试顺利，于是我们在我们的应用和服务器之间部署了这套解决方案。
###2. 从0到1的变化： 千里之行，始于足下
由于事先并没有做推送的经验，在实际实施的过程中我们明白的几个基础的概念：
 MQTT协议是一个即时通讯协议，推送实际上用到的只是它可以publish内容给topic的功能。topic是一个广播，所有订阅了这个topic的客户端都可以收到消息，为了实现针对设备的点对点推送，我们使用一个prefix+Client ID的方式给每个设备一个topic（如果没有这个需求，可以采取其它灵活的方式）。 为了保证客户端能够实时的收到推送消息，即使是程序退出，客户端用于接收消息的service也需要处于保持状态。 客户端与Broker、Broker和Web端的都是socket通信，推送的过程是用于Web端的client发布一个消息到Broker，Broker再将消息发送给当前其它连接到Broker的Client。所以能及时收到消息的只是现在和Broker保持连接状态的设备。 服务端需要维护一个设备id列表，这个列表中的id必须都是唯一的（在前期，我们选择使用Android ID，这也带来了很多麻烦）。  基于以上几点，我们也可以发现以下的问题：
 不是所有的设备都能够及时的获取到推送的内容。 客户端的service随时会有被各种安全软件干掉的风险。  通过前期的调研我们也发现，这些问题也是其它的第三方推送服务也都会遇到的问题。只要迈出第一步，让服务先work起来，其它的问题后续来优化。
###3. 从1到1万： 不积硅步，无以致千里
这个阶段主要是丰富推送的功能，解决一些前表面上的问题，我们做了以下的调整：
  在设备量到10000的时候，遇到了一个问题：推送10000个设备时间过长。这个问题很快得到了解决：这是由于没发送一个设备，都新建了一个从Web端到Broker的socket连接，这实际上是没有必要的，只要socket不断开所有Publish的工作都可以通过一个socket进行（这和APNS有些不一样的地方，在苹果的推送服务中，如果有一个设备id是无效的，整个推送都会断开），在前文提到过的Web端的库中，是有指定重连的操作的。
  丰富推送的内容。虽然推送的内容都是文本，但是文本的解析却是客户端维持的service来进行的，所以通过推送json的方式，实现了分别推送新闻、天气等富文本信息，并可以通过点击跳转到不同的页面。
  分地区推送的需求，这个实现方式经过一些迭代，最早是通过用户注册地来实现的，后来改为了用户安装应用时上报的地区的方式。
  ###4. 从1万到10万，必须做出的改变： 行百里者半于九十
数据量到达10万的时候，一些问题也逐渐凸显。
  Android ID重复的问题 ： 从网上查询来的资料，大部分都是使用Android的系统参数ANDROID_ID来做推送的。然而实践表明，这个参数并不是可靠的。生产环境中使用这个参数有极大的几率重复。由于一个相同的设备id连接到Broker的时候，之前的连接就会断开，这就会导致相同设备ID的设备只有一个会收到推送的消息。 在续的改造过程中，我们将设备ID换成了自己生成的一套唯一随机的ID。</description>
    </item>
    
    <item>
      <title></title>
      <link>http://0x1.im/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://0x1.im/about/</guid>
      <description>About Me 90后 程序员 武汉 PHP 深圳
2013 年毕业于武汉某211通信工程专业。先在武汉工作了两年，然后又漂泊到了深圳。工作之前实习过一年，也就是毕业后留下来的公司，也是因为这个契机才成为一枚程序猿。
主要从事 PHP 开发和 Linux 服务器运维相关的工作，对 Python/Lua/Go 也有浓厚的兴趣。关注业界动态，时刻谨记优化自己的技能。目前就职于鹅厂。
并不特别聪明，也并不特别勤奋，没事儿喜欢瞎折腾。喜欢简单安静的生活。
联系我 email: scholer_l#live.com
微信: Scholer_L</description>
    </item>
    
  </channel>
</rss>