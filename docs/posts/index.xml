<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Scholer&#39;s Homapage</title>
        <link>http://0x1.im/posts/</link>
        <description>Recent content in Posts on Scholer&#39;s Homapage</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-hans</language>
        <lastBuildDate>Wed, 08 Jul 2020 09:39:40 +0000</lastBuildDate>
        <atom:link href="http://0x1.im/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>使用 Golang 实现一个 JSON 命令行工具</title>
            <link>http://0x1.im/posts/2020-07-08-a-json-toys/</link>
            <pubDate>Wed, 08 Jul 2020 09:39:40 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2020-07-08-a-json-toys/</guid>
            <description>首先先提一个问题，&amp;quot;abc&amp;quot; 、123 或者 [1, 2, 3] 是不是一个合法的 json ？
之前一直有在使用一个 json 的命令行工具 jq，这个工具是基于 flex 和 bison 来实现的（去了解这些是基于当年学习 php 的经历）。后来有段时间我又发现一个不错的词法和语法分析工具 antlr，它支持多种语言的生成，并且本身也提供了多种语言的基本语法文件。所以我就想能不用基于它实现一个 go 语言版的 json 命令行工具。
下面就开始一步一步行动吧（如果想直接看代码可以直接拉到底部），我将这个项目命名为 jtlr。
提供的功能 根据我自己常使用的场景，我要实现以下几个功能：
基本用法：
 jtlr &amp;lsquo;{&amp;ldquo;a&amp;rdquo;: 1}&amp;rsquo;
 交互模式，可以多次输入，并且最好能支持上下切换：
 jtlr -a
 从标准输入中读取内容，可以格式化实时输出的日志：
 tail -f xxx.log | jtlr -s
 从文件中读取：
 jtlr -f xxx.log
 什么是 json 在动手之前，先要对 json 有一个全面的认识。先来大致看一下官网提供的 json 的 BNF 范式的起始部分：
json element value object array string number &amp;quot;true&amp;quot; &amp;quot;false&amp;quot; &amp;quot;null&amp;quot; .</description>
            <content type="html"><![CDATA[<p>首先先提一个问题，<code>&quot;abc&quot;</code> 、<code>123</code> 或者 <code>[1, 2, 3]</code> 是不是一个合法的 json ？</p>
<p>之前一直有在使用一个 json 的命令行工具 <a href="https://github.com/stedolan/jq">jq</a>，这个工具是基于 flex 和 bison 来实现的（去了解这些是基于当年学习 php 的经历）。后来有段时间我又发现一个不错的词法和语法分析工具 <a href="https://github.com/antlr/antlr4">antlr</a>，它支持多种语言的生成，并且本身也提供了多种语言的基本语法文件。所以我就想能不用基于它实现一个 go 语言版的 json 命令行工具。</p>
<p>下面就开始一步一步行动吧（如果想直接看代码可以直接拉到底部），我将这个项目命名为 <code>jtlr</code>。</p>
<h3 id="提供的功能">提供的功能</h3>
<p>根据我自己常使用的场景，我要实现以下几个功能：</p>
<p>基本用法：</p>
<blockquote>
<p>jtlr &lsquo;{&ldquo;a&rdquo;: 1}&rsquo;</p>
</blockquote>
<p>交互模式，可以多次输入，并且最好能支持上下切换：</p>
<blockquote>
<p>jtlr -a</p>
</blockquote>
<p>从标准输入中读取内容，可以格式化实时输出的日志：</p>
<blockquote>
<p>tail -f xxx.log | jtlr -s</p>
</blockquote>
<p>从文件中读取：</p>
<blockquote>
<p>jtlr -f  xxx.log</p>
</blockquote>
<h3 id="什么是-json">什么是 json</h3>
<p>在动手之前，先要对 <a href="https://www.json.org/">json</a> 有一个全面的认识。先来大致看一下官网提供的 json 的 BNF 范式的起始部分：</p>
<pre><code>json
    element

value
    object
    array
    string
    number
    &quot;true&quot;
    &quot;false&quot;
    &quot;null&quot;

...

element
    ws value ws
</code></pre><p><code>ws</code> 是 whitespace 的缩写，即空白字符，忽略这个之后，即可简单清晰的看到 json 的内的有效数值。虽然我们常用的 json 内容都是 object 起的，但并不是一定要从 object 开始，所以对于文章开头那个问题，你有答案了吗？</p>
<p>在实现时我并没有去复制官网提供的 BNF，而是采用了 antlr4 提供的语法，关于它的实现，这里有一篇文章说明：<a href="https://andreabergia.com/a-grammar-for-json-with-antlr-v4/">https://andreabergia.com/a-grammar-for-json-with-antlr-v4/</a> 。</p>
<p>简单来说，json 有七种的数据，其中 <code>array</code> 和 <code>object</code> 是可以再包含 <code>value</code>，剩下五种就是基本的数值数据。</p>
<p>此外，还有一类比较特殊的情况，就是对 <code>string</code> 的用法：</p>
<pre><code>member
    ws string ws ':' element
</code></pre><p><code>string</code> 既可以是一个基本类型的 <code>value</code>，也可以一个对象成员的键值。这会导致我们在对 <code>string</code> 做上色等处理时需要考虑着两种情况。</p>
<h3 id="antlr4-提供的接口">antlr4 提供的接口</h3>
<p>使用下面的命令即可生成基于 go 语言的 lexer 和 parser：</p>
<blockquote>
<p>antlr -Dlanguage=Go -o parser/ JSON.g4</p>
</blockquote>
<p>接下来就是功能实现的工作了。</p>
<p>antlr4 生成的接口比较完备，包含每个分支逻辑进入、退出和错误节点访问的接口。并且有较好的错误纠正和提示机制。</p>
<p>但对于 json 本身这个 case，需要注意的是对 <code>value</code> 和 <code>string</code>。上面也有提到，所有七类数值都是 <code>value</code>，所以都会触发 <code>EnterValue</code> 和 <code>ExitValue</code> 事件，<code>string</code> 同理。</p>
<p>对于 <code>object</code> 和 <code>array</code> 来说，比较棘手的在于嵌套的数据，例如：</p>
<blockquote>
<p>{&ldquo;a&rdquo;: [134, {&ldquo;a&rdquo;: 1}, true, [1, 2, 3], false]}</p>
</blockquote>
<p>在使用 antlr4 提供的接口时，需要标注进入和退出的顺序。</p>
<h3 id="交互模式下的问题">交互模式下的问题</h3>
<p>最开始我做了个非常简单的交互模式的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reader</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;&gt;&gt;&gt; &#34;</span><span class="p">)</span>
    <span class="nx">text</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">text</span> <span class="o">==</span> <span class="s">&#34;\n&#34;</span> <span class="o">||</span> <span class="nx">text</span> <span class="o">==</span> <span class="s">&#34;\r\n&#34;</span> <span class="p">{</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="nf">fn</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>但是在这种实现逻辑下，上下左右等按键会直接打印在屏幕上而无法正确处理，因为终端处于 <strong>cooked mode</strong> 下。go 本身也没有提供 tty 的封装。所以要进入 <strong>raw mode</strong>，一种是通过直接 call 起命令行的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">raw</span><span class="p">(</span><span class="nx">start</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="s">&#34;raw&#34;</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">start</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="p">=</span> <span class="s">&#34;-raw&#34;</span>
    <span class="p">}</span>

    <span class="nx">rawMode</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;stty&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="nx">rawMode</span><span class="p">.</span><span class="nx">Stdin</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rawMode</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">rawMode</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>另外一种是操作 stdin 的文件句柄，这样实现起来就相当复杂了。</p>
<p>出于兼容性和可维护性的考虑，我使用了 <a href="https://github.com/golang/crypto">golang/crypto</a> 提供的 terminal 的封装，这也是项目中除了 antlr 以外唯一一个引入的第三方包（如果算是第三方的话）。</p>
<p>但是这个包有一个问题是必须使用 <code>\r\n</code> 进行回车（官方的 issue 解释是一些历史原因吧啦吧啦），不然光标不会回到行首，但是 go 标准的 fmt 包中使用的 <code>\n</code> 换行，而 antlr 使用了 fmt 进行错误输出，所以需要对错误输出进行重载。</p>
<h3 id="未完成">未完成</h3>
<p>从开始构思到实现到当前阶段，大概耗时两个周末了。</p>
<p>由于前期偷懒，格式化输出全部使用的是 fmt，这里后续需要优化一下。</p>
<p>现在的实现对于 antlr 来说有点像用牛刀杀鸡，jq 本身支持的节点选取，这是后续实现的一个方向。</p>
<p>另外，go 官方虽然提供了官方的 json 序列化和反序列化工具，但是市面上也有一些第三方的实现被使用，我也想探讨一下实现方式。</p>
<p>另外，windows 下还没做完全的兼容测试。</p>
<p>最后，贴上项目地址：<a href="https://github.com/XiaoLer/jtlr-go">https://github.com/XiaoLer/jtlr-go</a></p>
]]></content>
        </item>
        
        <item>
            <title>写给 PHP 程序员的 Go 入门教程</title>
            <link>http://0x1.im/posts/2020-05-26-way-from-php-to-go/</link>
            <pubDate>Tue, 26 May 2020 10:41:41 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2020-05-26-way-from-php-to-go/</guid>
            <description>这两年唱衰 PHP 的论调不少（其实我觉得大可不必），导致不少 PHP 程序员产生危机感，纷纷寻求转型，根据我的观察，基本上 Go 都是首选。不管怎么说，技多不压身，多掌握一点知识总是好的。本文就作为一个基础的入门来帮助 PHP 程序员入门 Go 语言吧。
1. 脚本语言 vs 编译型语言 这其实是个我每次面试都会问的问题，脚本语言和编译型语言有什么区别。维基上的解释：
 语法和结构通常比较简单 学习和使用通常比较简单 通常以容易修改程序的“解释”作为运行方式，而不需要“编译” 程序的开发产能优于运行性能  从我的角度，可以从执行角度和环境依赖上来说。
简单理解，作为脚本语言，你可以单独写一行 &amp;lt;?php echo &amp;quot;Hello World&amp;quot;;，命名为任意文件，然后使用 php 解释器来执行。甚至可以使用 php -a 进入交互环境执行任何代码。
go 这种编译型语言就不是这样。因为是先编译后执行，go 一定需要知道程序的入口文件和入口函数。所以一个程序的执行一定需要 main 函数（go test 文件除外）。虽然 go 也提供了 run 指令省略到编译的步骤。
在环境依赖上，执行 php 的服务器一定需要预装固定版本 php 解释器，而编译成二进制文件的 go 程序则只需要在对应架构的服务器上即可运行。这本质上是 php 的解释器扮演的才是 go 编译后的程序的角色，而脚本则是在 php 解释器构建的一层虚拟机上执行的。所以脚本语言在不同平台上表现的一致性更好，而使用编译型语言则需要有更好的操作系统和网络底层知识。
2. 动态语言 vs 静态语言 动态语言与静态语言又分别被称为弱类型语言和强类型语言，其实这样描述也更加形象。
PHP 会在执行的过程中做隐式类型转换（虽然也提供了类型转换的函数和关键字），go 的类型转换却需要手动、强制的来执行。
弱类型语言带来了很多便利性，但是也隐含了很多问题，以至于 PHP 要引入 === 这种比较方式，不过经验丰富的 PHP 开发应该是能在每一个变量定义之前都确认好它的数据类型的。go 语言中不存在隐式转换的问题，但是写起来肯定也没有那么爽，光是 int 都有多种长度的类型，会让很多新手不太适应，同样的道理，定义每一个变量之前都稍加思考，就能轻松解决这个问题。</description>
            <content type="html"><![CDATA[<p>这两年唱衰 PHP 的论调不少（其实我觉得大可不必），导致不少 PHP 程序员产生危机感，纷纷寻求转型，根据我的观察，基本上 Go 都是首选。不管怎么说，技多不压身，多掌握一点知识总是好的。本文就作为一个基础的入门来帮助 PHP 程序员入门 Go 语言吧。</p>
<h3 id="1--脚本语言-vs-编译型语言">1.  脚本语言 vs 编译型语言</h3>
<p>这其实是个我每次面试都会问的问题，脚本语言和编译型语言有什么区别。维基上的解释：</p>
<ul>
<li>语法和结构通常比较简单</li>
<li>学习和使用通常比较简单</li>
<li>通常以容易修改程序的“解释”作为运行方式，而不需要“编译”</li>
<li>程序的开发产能优于运行性能</li>
</ul>
<p>从我的角度，可以从执行角度和环境依赖上来说。</p>
<p>简单理解，作为脚本语言，你可以单独写一行 <code>&lt;?php echo &quot;Hello World&quot;;</code>，命名为任意文件，然后使用 php 解释器来执行。甚至可以使用 <code>php -a</code> 进入交互环境执行任何代码。</p>
<p>go 这种编译型语言就不是这样。因为是先编译后执行，go 一定需要知道程序的入口文件和入口函数。所以一个程序的执行一定需要 <code>main</code> 函数（go test 文件除外）。虽然 go 也提供了 <code>run</code> 指令省略到编译的步骤。</p>
<p>在环境依赖上，执行 php 的服务器一定需要预装固定版本 php 解释器，而编译成二进制文件的 go 程序则只需要在对应架构的服务器上即可运行。这本质上是 php 的解释器扮演的才是 go 编译后的程序的角色，而脚本则是在 php 解释器构建的一层虚拟机上执行的。所以脚本语言在不同平台上表现的一致性更好，而使用编译型语言则需要有更好的操作系统和网络底层知识。</p>
<h3 id="2-动态语言-vs-静态语言">2. 动态语言 vs 静态语言</h3>
<p>动态语言与静态语言又分别被称为弱类型语言和强类型语言，其实这样描述也更加形象。</p>
<p>PHP 会在执行的过程中做隐式类型转换（虽然也提供了类型转换的函数和关键字），go 的类型转换却需要手动、强制的来执行。</p>
<p>弱类型语言带来了很多便利性，但是也隐含了很多问题，以至于 PHP 要引入 <code>===</code> 这种比较方式，不过经验丰富的 PHP 开发应该是能在每一个变量定义之前都确认好它的数据类型的。go 语言中不存在隐式转换的问题，但是写起来肯定也没有那么爽，光是 <code>int</code> 都有多种长度的类型，会让很多新手不太适应，同样的道理，定义每一个变量之前都稍加思考，就能轻松解决这个问题。</p>
<p>go 提供了 <code>:=</code> 和 <code>var</code> 关键字的赋值方式，编译器会根据初始化的值自动推导出相应的类型，但是这个用法同样也要求你小心处理作用域的问题，不妨猜一下下面这段代码的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
    <span class="k">if</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h3 id="3-go-还要不要-mvc">3. Go 还要不要 MVC</h3>
<p>先说我的观点：不需要。其实不只是 go 开发，PHP 的微服务框架比如 Slim 默认也不是按照 MVC 的方式组织代码的。本身现在前端工程化程度越来越高，一般都拉出去单独开项目，也不需要接口项目准备 V  的部分，所以说 MVC 是时代的产物，可以被淘汰了。</p>
<p>再者，go 使用的函数名、变量一般都比较简洁，<code>Controller</code> 这个长长的单词看起来真的有点突兀。</p>
<p>go 语言本身有一些约定性的命名方式，对代码的访问、编译和执行都是有影响的，比如 <code>internal</code> 目录下的内容不能被外部包访问，在搭建 go 项目的时候，也应该按照这些约定来，这才符合 go 的规范。</p>
<p>这里有一个 go 项目目录组织的 demo：<a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a>， 值得参考一下。也可以看一下这篇文章，写的很不错：<a href="https://draveness.me/golang-101/">https://draveness.me/golang-101/</a>。</p>
<h3 id="4-go-还要不要框架">4. Go 还要不要框架</h3>
<p>既然 MVC 都不需要了，那开发框架还需不需要呢？这个问题没有固定答案，因为同样在 PHP 中，框架的概念也渐渐弱化，包的概念逐渐强化。只要有 Composer，徒手搭建一个 PHP 的框架不是什么难事。</p>
<p>从 <code>1.13</code> 的版本之后，go 终于有了默认统一的包管理方式，虽然不算完美，但总算解决了以前管理混乱、限制太多的问题，具体的介绍可以参考官方说明：<a href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a>。</p>
<p>选一个或者写一个好用的基础结构，配上一些不错的包，就可以愉快的开始项目开发了。</p>
<p>最后我还是想说明一下，语言本身可能有设计上的不同，但不应该有好坏之分，特别是应用比较广泛的语言，自然是因为其自身的某些特性吸引人。选择适合自己的、适合业务的就可以，不要当语言上的精神贵族。</p>
]]></content>
        </item>
        
        <item>
            <title>基于 Redis 的 Pub/Sub 实现 Websocket 推送</title>
            <link>http://0x1.im/posts/2018-01-06-redis-websocket-push/</link>
            <pubDate>Sat, 06 Jan 2018 14:04:11 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2018-01-06-redis-websocket-push/</guid>
            <description>背景 微信小程序的生态越来越完善，而在技术上，小程序目前只支持两种通信协议：HTTPS 和 WebSocket，所以在需要使用双工通信的时候，除了 WebSocket 也没有别的选择。最近恰好有个这样的需求，所以我也花了点时间研究了一下。
项目上实现的目标就是小程序和服务器建立 WebSocket 建立连接，在服务端收到来自于第三方的事件推送之后，主动推送给客户端而不是靠客户端轮询来获取消息（这里就不介绍 WebSocket 的基础知识了）。因为我们项目组成员大多都是 PHP 开发，所以也是考虑用 PHP 来实现。
实现 这里会遇到的问题就是，用 PHP 的库来开一个 WebSocket 服务端口的时候，由于要保持连接，并接收的后续连接，所以服务本身是处于监听端口的状态。而如果程序同时要订阅来自 Redis 的事件，同样也需要监听 Redis 的消息。那么要如何实现呢？这里先直接抛出我所使用的两个库：
 Ratchet：一个 PHP 实现的异步 WebSocket 服务器 predis-async: PHP 实现的异步 Redis 客户端  仔细看上面的描述，除了 PHP 实现 外，他们还有一个相同的关键词：异步。没错，这里的异步和 node.js 描述的异步差不多是同一回事。实现异步的基础就是：EventLoop。这里我也不具体描述 EventLoop 到底是怎么一回事儿。其实 Ratchet 提供的 examples 里也有一个借用 zeromq 实现 push的例子：
$loop = React\EventLoop\Factory::create(); // Listen for the web server to make a ZeroMQ push after an ajax request $context = new React\ZMQ\Context($loop); $pusher = new MyApp\Pusher; $pull = $context-&amp;gt;getSocket(ZMQ::SOCKET_PULL); $pull-&amp;gt;bind(&amp;#39;tcp://127.</description>
            <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>微信小程序的生态越来越完善，而在技术上，小程序目前只支持两种通信协议：HTTPS 和 WebSocket，所以在需要使用双工通信的时候，除了 WebSocket 也没有别的选择。最近恰好有个这样的需求，所以我也花了点时间研究了一下。</p>
<p>项目上实现的目标就是小程序和服务器建立 WebSocket 建立连接，在服务端收到来自于第三方的事件推送之后，主动推送给客户端而不是靠客户端轮询来获取消息（这里就不介绍 WebSocket 的基础知识了）。因为我们项目组成员大多都是 PHP 开发，所以也是考虑用 PHP 来实现。</p>
<h3 id="实现">实现</h3>
<p>这里会遇到的问题就是，用 PHP 的库来开一个 WebSocket 服务端口的时候，由于要保持连接，并接收的后续连接，所以服务本身是处于监听端口的状态。而如果程序同时要订阅来自 Redis 的事件，同样也需要监听 Redis 的消息。那么要如何实现呢？这里先直接抛出我所使用的两个库：</p>
<ul>
<li><a href="https://github.com/ratchetphp/Ratchet">Ratchet</a>：一个 PHP 实现的异步 WebSocket 服务器</li>
<li><a href="https://github.com/nrk/predis-async">predis-async</a>: PHP 实现的异步 Redis 客户端</li>
</ul>
<p>仔细看上面的描述，除了 <em>PHP 实现</em> 外，他们还有一个相同的关键词：异步。没错，这里的异步和 node.js 描述的异步差不多是同一回事。实现异步的基础就是：EventLoop。这里我也不具体描述 EventLoop 到底是怎么一回事儿。其实 Ratchet 提供的 examples 里也有一个借用 zeromq 实现 push的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">$loop   = React\EventLoop\Factory::create();
// Listen for the web server to make a ZeroMQ push after an ajax request
$context = new React\ZMQ\Context($loop);
$pusher = new MyApp\Pusher;

$pull = $context-&gt;getSocket(ZMQ::SOCKET_PULL);
$pull-&gt;bind(&#39;tcp://127.0.0.1:5555&#39;); // Binding to 127.0.0.1 means the only client that can connect is itself
$pull-&gt;on(&#39;message&#39;, array($pusher, &#39;onBlogEntry&#39;));

// Set up our WebSocket server for clients wanting real-time updates
$webSock = new React\Socket\Server(&#39;0.0.0.0:8080&#39;, $loop); // Binding to 0.0.0.0 means remotes can connect
</code></pre></div><p>上面的例子中可以看出来，实现主动推送的核心点也是在于共享了同一个 loop 实例。</p>
<p>同样，如果要实现基于 Redis Pub/Sub 的推送，也是要利用这一点。上面这两个库使用的 EventLoop 库恰好是同一个：<a href="https://github.com/reactphp/event-loop">reactphp/event-loop</a>，并且也是上述基于 zeromq 实现推送的 EventLoop 库。</p>
<p>实现上和上面的代码示例类似：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$loop</span> <span class="o">=</span> <span class="nx">LoopFactory</span><span class="o">::</span><span class="na">create</span><span class="p">();</span>
<span class="nv">$redis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Predis\Async\Client</span><span class="p">(</span><span class="s1">&#39;tcp://127.0.0.1:6379&#39;</span><span class="p">,</span> <span class="nv">$loop</span><span class="p">);</span>

<span class="c1">// 自己实现一个 WebSocket 的方法实现类
</span><span class="c1"></span><span class="nv">$handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Handler</span><span class="p">();</span>

<span class="nv">$redis</span><span class="o">-&gt;</span><span class="na">connect</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$client</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$handler</span><span class="p">,</span> <span class="nv">$handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s1">&#39;Connected to Redis, now listening for incoming messages...&#39;</span><span class="p">,</span> <span class="nx">PHP_EOL</span><span class="p">;</span>

    <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">pubSubLoop</span><span class="p">([</span><span class="s1">&#39;psubscribe&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;pub.*&#39;</span><span class="p">],</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$event</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在 Handler 类中 onOpen 方法被调用时，注意存储下当前连接信息。
</span><span class="c1"></span>        <span class="c1">// 在 Handler 类中自己实现一个方法用于接收事件消息后的调用，就可以根据连接信息来源主动 push 了
</span><span class="c1"></span>        <span class="nv">$handler</span><span class="o">-&gt;</span><span class="na">onPublishEntry</span><span class="p">(</span><span class="nv">$event</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="c1">// Run the server application through the WebSocket protocol on port 8090
</span><span class="c1"></span><span class="nv">$app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RatchetApp</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8099</span><span class="p">,</span> <span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="nv">$loop</span><span class="p">);</span>
<span class="c1">// Set a route
</span><span class="c1"></span><span class="nv">$app</span><span class="o">-&gt;</span><span class="na">route</span><span class="p">(</span><span class="s1">&#39;/handler&#39;</span><span class="p">,</span> <span class="nv">$handler</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]);</span>
</code></pre></div><p>通过上面的实现，就可以监听 Pub 到 <code>pub.*</code> 的消息并主动推送给通过 WebSocket 连接到后端的客户端了。</p>
<h3 id="其他">其他</h3>
<p>Ratchet 的 WebSocket hander  一旦被实例化，在所有新进入的连接中都是共享的，所以一定要处理好各个连接之间的身份认证、数据隔离等关系。新连接的认证可以在 <code>onOpen</code> 方法被调用时处理。</p>
<p>由于小程序也不支持 Cookie，我推荐使用 <a href="https://jwt.io/">JWT</a> 做身份认证。虽然 JWT 本身并不完美，但是一个不错的解决问题的方式。</p>
<p>本文只是提供一种 PHP 实现的思路，实际并没有经过大量连接的考验。同样也有很多其他的思路来解决这个问题，比如基于 openresty 的信号量或者 golang 的线程机制来实现。</p>
]]></content>
        </item>
        
        <item>
            <title>使用 deployer 部署项目</title>
            <link>http://0x1.im/posts/2017-09-23-use-deployer/</link>
            <pubDate>Sat, 23 Sep 2017 08:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2017-09-23-use-deployer/</guid>
            <description>我一直都认为部署是持续集成或者 DevOps 中最重要的一个环节。受限于公司的网络环境，一直在这一块儿能做的事情很少。最近用腾讯云的机器做一些事情，才有机会好好研究一下 deployer 这个工具。
简介 deployer 主要的功能是创建一系列的工作流来执行部署任务。通过 task 函数定义一系列的操作，然后按照顺序执行，完成代码部署前后的工作。你可以自己定义任务，也可以直接使用 deployer 提供的一些已经写好的方法，deployer 称这些封装为 recipe。
举个例子 task 定义的例子：
task(&amp;#39;deploy&amp;#39;, [ &amp;#39;deploy:prepare&amp;#39;, &amp;#39;deploy:lock&amp;#39;, &amp;#39;deploy:release&amp;#39;, &amp;#39;rsync&amp;#39;, &amp;#39;deploy:shared&amp;#39;, &amp;#39;deploy:writable&amp;#39;, &amp;#39;deploy:symlink&amp;#39;, &amp;#39;deploy:unlock&amp;#39;, &amp;#39;cleanup&amp;#39;, &amp;#39;success&amp;#39;, ]); 在名为 deploy 的任务中定义了一系列的操作，这样执行 dep deployer 的时候，deployer 会按照顺序执行任务，完成部署工作。这一切执行动作本身是基于 ssh 的。
从上面的例子中也可以看出，虽然 deployer 本身主要是针对 git 项目的发布，但也可以通过 rsync 的方式同步代码。而名为 rsync 的 recipe具体的内容在github上也可以找到。
使用 deployer 进行代码部署是非常方便编写指令的，还有一个好处就是你可以在任何一次部署结束之后使用 rollback 命令进行回滚等操作。
起步 创建一个基于 deployer 的项目部署配置很简单，在安装完 deployer 后直接在目录中执行 dep init 即可。deployer 本身已经提供了一些知名开源项目的部署配置供选择，如果想高度自定义，选择通用配置（common）即可。
执行完成后会在当前目录中生成一个 deploy.php 的文件。 配置文件中最常见的两个函数就是 set 和 task，task 上文已经有过介绍。set 函数是用来配置参数用的。它既可以用来设置新的配置项，也可以替换默认的设置。</description>
            <content type="html"><![CDATA[<p>我一直都认为部署是持续集成或者 DevOps 中最重要的一个环节。受限于公司的网络环境，一直在这一块儿能做的事情很少。最近用腾讯云的机器做一些事情，才有机会好好研究一下 <a href="https://github.com/deployphp/deployer">deployer</a> 这个工具。</p>
<h3 id="简介">简介</h3>
<p>deployer 主要的功能是创建一系列的工作流来执行部署任务。通过 <code>task</code> 函数定义一系列的操作，然后按照顺序执行，完成代码部署前后的工作。你可以自己定义任务，也可以直接使用 deployer 提供的一些已经写好的方法，deployer 称这些封装为 <code>recipe</code>。</p>
<p>举个例子 task 定义的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">task(&#39;deploy&#39;, [
    &#39;deploy:prepare&#39;,
    &#39;deploy:lock&#39;,
    &#39;deploy:release&#39;,
    &#39;rsync&#39;,
    &#39;deploy:shared&#39;,
    &#39;deploy:writable&#39;,
    &#39;deploy:symlink&#39;,
    &#39;deploy:unlock&#39;,
    &#39;cleanup&#39;,
    &#39;success&#39;,
]);
</code></pre></div><p>在名为 <code>deploy</code> 的任务中定义了一系列的操作，这样执行 <code>dep deployer</code> 的时候，deployer 会按照顺序执行任务，完成部署工作。这一切执行动作本身是基于 ssh 的。</p>
<p>从上面的例子中也可以看出，虽然 deployer 本身主要是针对 git 项目的发布，但也可以通过 rsync 的方式同步代码。而<a href="https://github.com/deployphp/recipes/blob/master/recipe/rsync.php">名为 rsync 的 recipe</a>具体的内容在github上也可以找到。</p>
<p>使用 deployer 进行代码部署是非常方便编写指令的，还有一个好处就是你可以在任何一次部署结束之后使用 <code>rollback</code> 命令进行回滚等操作。</p>
<h3 id="起步">起步</h3>
<p>创建一个基于 deployer 的项目部署配置很简单，在安装完 deployer 后直接在目录中执行 <code>dep init</code> 即可。deployer 本身已经提供了一些知名开源项目的部署配置供选择，如果想高度自定义，选择通用配置（common）即可。</p>
<p>执行完成后会在当前目录中生成一个 <code>deploy.php</code> 的文件。 配置文件中最常见的两个函数就是 <code>set</code> 和 <code>task</code>，<code>task</code> 上文已经有过介绍。<code>set</code> 函数是用来配置参数用的。它既可以用来设置新的配置项，也可以替换默认的设置。</p>
<p>举例：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">set(&#39;allow_anonymous_stats&#39;, false);
</code></pre></div><p>在执行 init 的时候，deployer 会询问你时候允许发送统计信息，如果允许，则会像https://deployer.org/api/stats 这个地址发送你的 php 版本，系统等信息。可以通过上文的设置禁用统计。</p>
<p>通过 <code>host</code> 函数可以指定需要部署的机器，如果你已经配置好目标机器的 ssh 访问，则无需重复配置，但也可以在配置中指定密码或者认证 key 文件。然后通过设置 <code>deploy_path</code> 配置代码部署目标位置，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">host(&#39;my-vm&#39;)-&gt;set(&#39;deploy_path&#39;, &#39;/var/www/my-web&#39;);
</code></pre></div><p>deployer 本身提供了一些通用的任务比如 <code>deploy:prepare</code>，这项任务会检查目标机器上的代码部署目录是否存在，如果不存在则会创建。</p>
<h3 id="配置">配置</h3>
<p>deployer 在服务器上创建的目录主要由两个 <code>releases</code> 和 <code>current</code>，其中 <code>current</code> 是软链到 <code>releases</code> 下当前版本的目录的，这也是可以随时回滚的原因。</p>
<p>此外，有些文件或者目录本身是需要再多个版本之间共享的，比如用户上传图片的目录，可以通过 <code>shared_files</code>、<code>shared_dirs</code> 来配置。上传文件的目录也需要是对 php 或者 nginx 允许用户是可写的，可以通过 <code>writable_dirs</code> 来设置（这项配置也可以用来首次部署是创建目录）。而 <code>writable_mode</code> 则可以指定使用哪种方式来设置目录可写（chown、chmod 或者 chgrp）。</p>
<p>例如针对 laravel/lumen 的 rsync 方式的发布，我会设置同步时忽略 storage 目录，主要设置如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">set(&#39;rsync&#39;, [
    // 不同步的目录
    &#39;exclude&#39; =&gt; [
        &#39;.git&#39;,
        &#39;storage&#39;,
    ],
    &#39;options&#39; =&gt; [&#39;delete&#39;],
    &#39;timeout&#39; =&gt; 3600,
]);

// 服务器上保存的版本数
set(&#39;keep_releases&#39;, 5);
// 共享 storage 目录
set(&#39;shared_dirs&#39;, [&#39;storage&#39;]);
// 首次发布时会创建这些目录，并被设置为可写状态
set(&#39;writable_dirs&#39;, [
    &#39;storage&#39;,
    &#39;storage/app&#39;,
    &#39;storage/framework&#39;,
    &#39;storage/framework/cache&#39;,
    &#39;storage/framework/views&#39;,
    &#39;storage/logs&#39;,
]);
</code></pre></div><p>设置完这些选项，将上文中的 task 放到文件最后保存。最后执行 <code>dep deploy</code> 命令，就可以讲代码同步到目标服务器上。</p>
<p>更多的设置选项，比如如何使用 sudo 来执行命令，或者如何设置 js 的构建、在服务器上执行命令等操作，可以直接到<a href="https://deployer.org/docs/configuration">官网文档</a>中查看。</p>
]]></content>
        </item>
        
        <item>
            <title>再见2016，我在腾讯这一年</title>
            <link>http://0x1.im/posts/2017-01-07-goodbye-2016/</link>
            <pubDate>Sat, 07 Jan 2017 08:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2017-01-07-goodbye-2016/</guid>
            <description>再过几天，就是入职腾讯一周年的日子了。现在想想，过去的这一年，我觉得自己是幸运的。
16年一月，将近过年的时候，义无反顾的离开了上一家公司。那是我个人整个动荡的15年的结束。这一年我在这里呆的安心，有收获、有成长。如果说之前的两年多时间我是在安心学技术，那么这一年更多的是学习如何做事情。
到深圳之前，我并没有接触过项目管理、开发周期这些概念；而到腾讯之前，我对每周迭代这件事情也是完全没有概念的，这真的很快，太快了，以至于需求从拿到手上到成型你都可能还没有时间好好消化它，一开始我很难相信这种迭代速度能打造出精品。刚入职的那段时间确实很慌乱，我挺害怕自己之前那种慢工出细活的那种做事方式没办法太好的展现出自己的优势。实际上这在上半年也确实成了掣肘的毛病。而我的另外一个问题是我始终不太愿意做重复的事情。所以在很长一段时间中，我一直抓住的是另外一条线：运维。我觉得这是能带我融入项目和环境的途径。
从我工作以来，一直都是 PHP 和运维双线发展的（也许我离开上一家公司也有一个原因是他们不愿意让我碰服务器吧）。从熟悉业务机器的部署到管理和调整，然后再去了解项目本身的模块和代码问题，也算是找到了自己的一个熟悉整个项目架构的途径。
下半年花了很大的力气去改变一些既有的结构，我把自己的想法和风格带入到了项目中。我们对服务器的结构做了很大的调整，从原来一致性的环境分割成按照不同模块划分独立运行的环境，对环境的配置也做了很大的调整。中间也不完全是一帆风顺的，也出过一些小的问题，但都及时调整，也算是安稳度过。业务代码上，随着 Composer 加入项目，一些组件和模块逐渐取代了原来的一些意大利面条式代码。虽然这一块儿改的不算彻底，但也比原来好多了。
过程不必一一细表，还是总结一下收获吧。
对项目和产品的理解：
 一个需求投入时间的多少不是取决于把它做到完美需要多少时间，而是它会带来的收益值多少时间； 投入时间的性价比也是你可以拒绝某些需求的理由； 一个产品在市场的认可程度不是取决于用户看不见的技术实现是否优雅，用户只看表象，有时候还是因为出现的时间； 技术的最终都是服务于需求，不要用技术的理由来拒绝需求，如果两者有冲突，可以试着调整一下，尽管有时候你会有『f**k，这事儿还能这么干』的感叹； 技术的在某些时候对产品的意见未必没有产品专业，有的时候，技术能直击事情的本质； 不要拒绝沟通，解决问题永远是第一位的，哪怕不得不做出一些妥协。  技术上的一些进步：
 花了一个月左右的时间掌握了下 docker 的基本用法，并且实践在了项目上（非我自己操作）； 花了一些时间在 PHP 源码调试的学习上，也能自己动手改造一下业务用的 PHP 扩展； 在公司环境限制的条件下对改善运维操作做了一些尝试，节省了一些体力； 丰富了自己的技术栈认识，包括 日志收集、ELK、自动化测试、持续集成等，但有些还没有应用到实践上； 从尝试中学会了将自己熟悉的技术栈带入项目中的方法； 对大公司（当然是腾讯）的技术栈有了一定的认知，解决了一些以往的困惑。  以上项目和产品上的理解未必完全正确，只是自己的认知，也有可能随着时间的推移而产生调整。而技术上的事情，我只能说：学习永不止步。以下是一些 2016 做的不好地方以及 2017 希望去了解的地方：
 过去的一年看书太少，给自己的理由是私下的时间太少，2017 还是希望补足，多看书； 应该尝试写一些业务上成熟且有示范效应的代码； 尝试写一些成体系的文章，运营一个公众号试试？ 也去跟风了解一下机器学习，从 TensorFlow 开始？  感谢过去的一年，从可见的成果上看，小小的升了级，并且有了一个继续升级的机会，摘下一颗四星。希望 2017 会更好。</description>
            <content type="html"><![CDATA[<p>再过几天，就是入职腾讯一周年的日子了。现在想想，过去的这一年，我觉得自己是幸运的。</p>
<p>16年一月，将近过年的时候，义无反顾的离开了上一家公司。那是我个人整个动荡的15年的结束。这一年我在这里呆的安心，有收获、有成长。如果说之前的两年多时间我是在安心学技术，那么这一年更多的是学习如何做事情。</p>
<p>到深圳之前，我并没有接触过项目管理、开发周期这些概念；而到腾讯之前，我对每周迭代这件事情也是完全没有概念的，这真的很快，太快了，以至于需求从拿到手上到成型你都可能还没有时间好好消化它，一开始我很难相信这种迭代速度能打造出精品。刚入职的那段时间确实很慌乱，我挺害怕自己之前那种慢工出细活的那种做事方式没办法太好的展现出自己的优势。实际上这在上半年也确实成了掣肘的毛病。而我的另外一个问题是我始终不太愿意做重复的事情。所以在很长一段时间中，我一直抓住的是另外一条线：运维。我觉得这是能带我融入项目和环境的途径。</p>
<p>从我工作以来，一直都是 PHP 和运维双线发展的（也许我离开上一家公司也有一个原因是他们不愿意让我碰服务器吧）。从熟悉业务机器的部署到管理和调整，然后再去了解项目本身的模块和代码问题，也算是找到了自己的一个熟悉整个项目架构的途径。</p>
<p>下半年花了很大的力气去改变一些既有的结构，我把自己的想法和风格带入到了项目中。我们对服务器的结构做了很大的调整，从原来一致性的环境分割成按照不同模块划分独立运行的环境，对环境的配置也做了很大的调整。中间也不完全是一帆风顺的，也出过一些小的问题，但都及时调整，也算是安稳度过。业务代码上，随着 Composer 加入项目，一些组件和模块逐渐取代了原来的一些意大利面条式代码。虽然这一块儿改的不算彻底，但也比原来好多了。</p>
<p>过程不必一一细表，还是总结一下收获吧。</p>
<p>对项目和产品的理解：</p>
<ol>
<li>一个需求投入时间的多少不是取决于把它做到完美需要多少时间，而是它会带来的收益值多少时间；</li>
<li>投入时间的性价比也是你可以拒绝某些需求的理由；</li>
<li>一个产品在市场的认可程度不是取决于用户看不见的技术实现是否优雅，用户只看表象，有时候还是因为出现的时间；</li>
<li>技术的最终都是服务于需求，不要用技术的理由来拒绝需求，如果两者有冲突，可以试着调整一下，尽管有时候你会有『f**k，这事儿还能这么干』的感叹；</li>
<li>技术的在某些时候对产品的意见未必没有产品专业，有的时候，技术能直击事情的本质；</li>
<li>不要拒绝沟通，解决问题永远是第一位的，哪怕不得不做出一些妥协。</li>
</ol>
<p>技术上的一些进步：</p>
<ol>
<li>花了一个月左右的时间掌握了下 docker 的基本用法，并且实践在了项目上（非我自己操作）；</li>
<li>花了一些时间在 PHP 源码调试的学习上，也能自己动手改造一下业务用的 PHP 扩展；</li>
<li>在公司环境限制的条件下对改善运维操作做了一些尝试，节省了一些体力；</li>
<li>丰富了自己的技术栈认识，包括 日志收集、ELK、自动化测试、持续集成等，但有些还没有应用到实践上；</li>
<li>从尝试中学会了将自己熟悉的技术栈带入项目中的方法；</li>
<li>对大公司（当然是腾讯）的技术栈有了一定的认知，解决了一些以往的困惑。</li>
</ol>
<p>以上项目和产品上的理解未必完全正确，只是自己的认知，也有可能随着时间的推移而产生调整。而技术上的事情，我只能说：学习永不止步。以下是一些 2016 做的不好地方以及 2017 希望去了解的地方：</p>
<ol>
<li>过去的一年看书太少，给自己的理由是私下的时间太少，2017 还是希望补足，多看书；</li>
<li>应该尝试写一些业务上成熟且有示范效应的代码；</li>
<li>尝试写一些成体系的文章，运营一个公众号试试？</li>
<li>也去跟风了解一下机器学习，从 <a href="https://www.tensorflow.org/">TensorFlow</a> 开始？</li>
</ol>
<p>感谢过去的一年，从可见的成果上看，小小的升了级，并且有了一个继续升级的机会，摘下一颗四星。希望 2017 会更好。</p>
]]></content>
        </item>
        
        <item>
            <title>如何学习 PHP 源码 - 从编译开始</title>
            <link>http://0x1.im/posts/2017-01-02-learn-compile-php/</link>
            <pubDate>Mon, 02 Jan 2017 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2017-01-02-learn-compile-php/</guid>
            <description>PHP Mailing Lists 上这两天有个好玩儿的问题：Introduction to the PHP source code，大概就是有人想知道如何学习 PHP 源码，可是这种事情不是应该自己去发掘的吗？
上面是玩笑话，现在我也说说如何学习 PHP 解释器的源码。
首选你要知道的是 PHP 解释器源码的 github 地址：https://github.com/php/php-src ，话说回来还有人不知道吗？这里有几乎所有 PHP 的代码提交记录、pull requests 和一些 issue 等。
创建编译脚本或者发布包 从 Branch 中选择一个版本 tag，和每次 PHP 发布出来的版本就是一致的。也许你会发现你想编译的的时候缺找不到 configure 文件，但是有 configure.in 文件。这时候需要先执行的是 buildconf（如果是在 Windows 下面可以执行 buildconf.bat，不过我从来没有尝试过在 Windows 下面编译 PHP，所以具体的步骤我就不清楚了）。buildconf 本身是个简单的 shell 脚本，你可以用记事本打开看看它（最终的执行文件在 build 目录里，这个目录里有一些与编译有关的文件）。
这里面涉及到一个系列的编译工具：Autotools。如果你有兴趣，可以简单的了解一下，没有兴趣的话也不用多考虑，因为这些工具绝大多数 Linux 系统上都是已经存在的。
如果你想将 Github 上的 PHP 源码做成一个可发布的源码包，你可以看看 makedist 这个文件，它也是一个 shell 脚本（实际上源码里几乎所有跟编译相关的脚本都是 shell 脚本）。但是如果想直接执行者这个脚本，你可能会收到缺少以下组件的提示：re2c 和 Bison。仔细看 makedist 的文件，里面有调用 genfiles 这个脚本的语句，上面两个工具就是在 genfiles 的脚本里被调用的。</description>
            <content type="html"><![CDATA[<p>PHP Mailing Lists 上这两天有个好玩儿的问题：<a href="http://externals.io/thread/581">Introduction to the PHP source code</a>，大概就是有人想知道如何学习 PHP 源码，可是这种事情不是应该自己去发掘的吗？</p>
<p>上面是玩笑话，现在我也说说如何学习 PHP 解释器的源码。</p>
<p>首选你要知道的是 PHP 解释器源码的 github 地址：<a href="https://github.com/php/php-src">https://github.com/php/php-src</a> ，话说回来还有人不知道吗？这里有几乎所有 PHP 的代码提交记录、pull requests 和一些 issue 等。</p>
<h2 id="创建编译脚本或者发布包">创建编译脚本或者发布包</h2>
<p>从 Branch 中选择一个版本 tag，和每次 PHP 发布出来的版本就是一致的。也许你会发现你想编译的的时候缺找不到 <code>configure</code> 文件，但是有 <code>configure.in</code> 文件。这时候需要先执行的是 <code>buildconf</code>（如果是在 Windows 下面可以执行 <code>buildconf.bat</code>，不过我从来没有尝试过在 Windows 下面编译 PHP，所以具体的步骤我就不清楚了）。buildconf 本身是个简单的 shell 脚本，你可以用记事本打开看看它（最终的执行文件在 <code>build</code> 目录里，这个目录里有一些与编译有关的文件）。</p>
<p>这里面涉及到一个系列的编译工具：<a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html">Autotools</a>。如果你有兴趣，可以简单的了解一下，没有兴趣的话也不用多考虑，因为这些工具绝大多数 Linux 系统上都是已经存在的。</p>
<p>如果你想将 Github 上的 PHP 源码做成一个可发布的源码包，你可以看看 <code>makedist</code> 这个文件，它也是一个 shell 脚本（实际上源码里几乎所有跟编译相关的脚本都是 shell 脚本）。但是如果想直接执行者这个脚本，你可能会收到缺少以下组件的提示：<code>re2c</code> 和 <code>Bison</code>。仔细看 makedist 的文件，里面有调用 <code>genfiles</code> 这个脚本的语句，上面两个工具就是在 genfiles 的脚本里被调用的。</p>
<p>re2c 和 Bison 分别是 PHP 用到的词法解析器和语法分析器。在 genfiles 这个文件中可以看到它们的调用其实是在 <code>Makefile.frag</code> 中写着，分别通过 <code>zend_language_scanner.l</code> 和 <code>zend_language_parser.y</code> 生成相应的 C 语言文件（这个应该很多地方都有提到过）。</p>
<h2 id="编译解释器并初始化">编译解释器并初始化</h2>
<p>到了编译环节，编译之前需要先通过 <code>configure</code> 文件生成 Makefile 然后执行 <code>make</code>，所以 <code>gcc</code> 自然是必不可少的。configure 文件本身也是一个 shell 脚本，你也可以简单阅读一下它的内容。不过既然它是由 <code>autoconf</code> 从 <code>configure.in</code> 中生成的，也许直接查看 configure.in 会更轻松一些。</p>
<p>到这里总结一下就是：抛开一些核心扩展额依赖（比如 xml，ssl 等），编译 PHP 的先决条件是机器上有 Autotools 的工具（automake，autoconf 等），需要安装 re2c 和 Bison，当然还有编译工具（gcc）。</p>
<p>也许大家都知道，使用 <code>configure</code>  生成 Makefile 的时候可以通过 <code>--prefix</code> 参数指定目录，同时也可以选择编译哪些核心模块。至于哪些模块会被默认集成而哪些不会，这些本身是写在每个扩展的 <code>config.m4</code> （也有几个是被命名为 config0.m4 或 config9.m4）文件里的的，全都通过一些  <code>--enable</code>、<code>--disable</code>、<code>--with</code> 和 <code>--without</code> 的选项来控制。</p>
<p>编译的也与你采用的 Web 服务器有关，这涉及到你需要使用哪个 <code>sapi</code>，如果是 Apache，也许需要指定 <code>--with-apxs2</code> 的参数，如果是 Nginx，<code>php-fpm</code> 在默认条件下是会被编译的，但可以指定 php-fpm 的执行组和用户，不过这个是可以在编译完成后在配置中修改的。</p>
<p>编译完成之后还有一些事情需要考虑，最基本的问题是 PHP 的配置文件的问题，还有一个是如果使用的是 php-fpm，如何更便捷的控制它的启动、停止以及重启等。</p>
<p>在 PHP 源码根中已经准备了两份配置文件的模板：<code>php.ini-development</code> 和 <code>php.ini-production</code>。显然是分别用于开发环境和生产环境的，将其中一个复制到配置文件目录并重命名为 <code>php.ini</code> 即可（如果你不知道配置文件的目录在哪里，可以使用 <code>php --ini</code> 命令查看）。然后也可以根据你的需要修改它。</p>
<p>至于 php-fpm 的控制脚本，源码中本身也是有提供的，在 <code>sapi/fpm</code> 目录下。这个目录下的几个文件中有 php-fpm 配置文件的模板，也有稍微修改即可放到服务器 <code>/etc/init.d</code> 目录下用于控制 php-fpm 的 <code>start</code>、<code>stop</code>、<code>restart</code> 和 <code>reload</code> 动作的脚本，现在的版本中也提供了用于 <code>systemd</code> 的 service 文件。</p>
<h2 id="扩展编译">扩展编译</h2>
<p>如果 PHP 编译完成之后，发现还需要一些没有编译进去的核心扩展或者第三方扩展，你可以单独编译它们。</p>
<p>扩展编译的整个过程一共四句命令：</p>
<ol>
<li>phpize</li>
<li>./configure</li>
<li>make</li>
<li>make install</li>
</ol>
<p><code>phpize</code> 命令是用来准备 PHP 扩展库的编译环境的。在执行 <code>phpize</code> 的时候，如果有多个版本的 PHP，用哪个就要选哪个。这个命令和编译后的 php 的二进制文件在同一个目录中，也是一个 shell 脚本。</p>
<p>执行 <code>configure</code> 的时候，如果当前 <code>$PATH</code> 中找不到 <code>php-config</code> 或者有多个版本的 PHP 时，也需要通过 <code>--with-php-config</code> 的指令来指定 php-config 的目录。php-config 是一个用于获取所安装的 PHP 配置的信息，它也一样是和 php 的二进制文件在同一个目录的 shell 脚本。</p>
<p>phpize 和 php-config 的源码生成文件都是在 scripts 目录下。</p>
<p>所有工作完成之后，就可以愉快的使用你自己定制的 PHP 了。</p>
]]></content>
        </item>
        
        <item>
            <title>一个神奇的操作符即将加入PHP</title>
            <link>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</link>
            <pubDate>Thu, 22 Dec 2016 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-12-22-null-coalescing-assignment-operator/</guid>
            <description>我在翻看 PHP 的 RFC 列表的时候发现了一篇不算新的，但很有意思的 rfc：空合并赋值操作符 （姑且就这么翻译吧）。
它会引起我的注意的还有一个原因是我之前写过这样一篇文章：两行代码给 PHP7 添加一个“非空合并”语法糖，里面讲的是添加一个 ??: 操作符的方法， 而现在要讲的这个，已经被接受的 rfc 里添加的操作符是： ??=。
由于这个事情本身可说的不多，这里就根据 rfc 简单描述一下吧。以下部分是 rfc 的翻译。
 合并赋值操作符在上世纪七十年代就出现了，最早是在 C 语言里，比如 $x = $x + 3 可以被简写为 $x += 3。随着 PHP 成为一门专注于 Web 的语言，?? 操作符经常会被用去检查变量是否存在：比如：
$username = $_GET[&amp;#39;user&amp;#39;] ?? &amp;#39;nobody&amp;#39;; 但是由于大部分情况下变量的名称回避 $username 长很多，所以在使用 ?? 检查后讲变量本身赋值给自己的时候会需要些一些重复的代码，形如以下形式：
$this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? ‘value’; 这就是为什么需要一个能在自我赋值的时候进行空合并检查的赋值操作符的原因。
虽然 ?? 是一个比较操作符，??= 确实一个赋值操作符号。如果左值为 null，右值会被赋给左值，否则不做任何操作。
// 下面这一行有相同的效果 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] = $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?? &amp;#39;value&amp;#39;; // 使用新操作符替代重复的代码 $this-&amp;gt;request-&amp;gt;data[&amp;#39;comments&amp;#39;][&amp;#39;user_id&amp;#39;] ?</description>
            <content type="html"><![CDATA[<p>我在翻看 PHP 的 RFC 列表的时候发现了一篇不算新的，但很有意思的 rfc：<a href="https://wiki.php.net/rfc/null_coalesce_equal_operator">空合并赋值操作符</a> （姑且就这么翻译吧）。</p>
<p>它会引起我的注意的还有一个原因是我之前写过这样一篇文章：<a href="http://0x1.im/blog/php/add-a-operator-to-php7.html">两行代码给 PHP7 添加一个“非空合并”语法糖</a>，里面讲的是添加一个 <code>??:</code> 操作符的方法， 而现在要讲的这个，已经被接受的 rfc 里添加的操作符是： <code>??=</code>。</p>
<p>由于这个事情本身可说的不多，这里就根据 rfc 简单描述一下吧。以下部分是 rfc 的翻译。</p>
<hr>
<p>合并赋值操作符在上世纪七十年代就出现了，最早是在 C 语言里，比如 <code>$x = $x + 3</code> 可以被简写为 <code>$x += 3</code>。随着 PHP 成为一门专注于 Web 的语言，<code>??</code> 操作符经常会被用去检查变量是否存在：比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">$username = $_GET[&#39;user&#39;] ?? &#39;nobody&#39;;
</code></pre></div><p>但是由于大部分情况下变量的名称回避 <code>$username</code> 长很多，所以在使用 <code>??</code> 检查后讲变量本身赋值给自己的时候会需要些一些重复的代码，形如以下形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"> $this-&gt;request-&gt;data[&#39;comments&#39;][&#39;user_id&#39;] = $this-&gt;request-&gt;data[&#39;comments&#39;][&#39;user_id&#39;] ?? ‘value’;
</code></pre></div><p>这就是为什么需要一个能在自我赋值的时候进行空合并检查的赋值操作符的原因。</p>
<p>虽然 <code>??</code> 是一个比较操作符，<code>??=</code> 确实一个赋值操作符号。如果左值为 <code>null</code>，右值会被赋给左值，否则不做任何操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">// 下面这一行有相同的效果
$this-&gt;request-&gt;data[&#39;comments&#39;][&#39;user_id&#39;] = $this-&gt;request-&gt;data[&#39;comments&#39;][&#39;user_id&#39;] ?? &#39;value&#39;;
// 使用新操作符替代重复的代码
$this-&gt;request-&gt;data[&#39;comments&#39;][&#39;user_id&#39;] ??= &#39;value&#39;;
</code></pre></div><p>用简单描述就是：左值为空时复制右值。</p>
<hr>
<p>从实际的工程经验上来说，这个操作符确实能简化判断。这也不是第一个三个字符组成的操作符（除此之外还有 <code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>===</code>、<code>!==</code>）。</p>
<p>这个操作符并没有出现在 PHP7.1 中，因为 rfc 提出来的时候已经 7.1 已经是 beta3 了，而新特性需要在 beta1 时就冻结，所以在 7.2 中应该就可以用上它了。</p>
<p>既然说到简化重复的代码，<code>??=</code> 都已经来了，<code>??:</code> 还会远吗 😄 。</p>
]]></content>
        </item>
        
        <item>
            <title>如何拯救一个有历史问题的PHP项目</title>
            <link>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</link>
            <pubDate>Sun, 18 Dec 2016 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-12-18-how-to-save-a-php-project/</guid>
            <description>本文未经许可禁止转载，如有转载意愿请与作者联系。
 1、项目历史 我们团队现在做的是一个微信第三方平台项目，项目起步时间不长，到现在差不多两年。起初是个探索性的小项目，但是随着业务的发展，已有的结构渐渐不能满足业务需求以及高峰时段的压力；不仅如此，一些历史问题也给我的开发流程带来了不少问题。所以这半年以来，再满足产品高速迭代的需求的前提下，我们也对后台框架以及服务器的结构做了持续的调整和优化。本文主要是针对后台部分的变动进行整理。
项目开始的时候，组里还有其他两个项目处于维护阶段。并且这个项目后台的起步也是直接从原来的项目里 copy 了部分结构代码并在这基础上进行改动，所以有很多历史遗留问题在里面。项目本身的框架还是 11 年左右的一个 cakePHP 的变种框架，项目框架从来没有更新过，甚至项目本身的 String 类封装每次调用都会触发 bug。
在服务器上，三个项目最开始的时候是共享所有的服务器资源的。而较老的项目由于只维护不开发，一些业务组件，比如 memcached、sphinx 中文版（Coreseek）以及一些 PHP 的扩展早已没有更新，但是每次服务器变更的时候还得考虑这些东西。
最近半年，通过不断的调整和修改，我们解决了大部分历史遗留问题，并成功升级到 PHP7。
2、基本能力 PHP 最近几年发展势头也是很快，Composer、Laravel 等组件和框架逐渐流行起来。借助第三方的力量能够很大程度的简化自己的工作、提高开发效率。
虽然以前项目中也有引入 PHPExcel 等第三方库，但都是通过下载源码丢到项目本身的方式来做的。这样做的问题是引入并不方便，并且一般不会及时通过升级来解决一些第三方库的 bug、漏洞等问题。为了提高框架的基础能力，我们在框架中引入了 Composer。
在 Compoer 的引入的同时我们也引入了一些优秀的库来解决基础问题。之前项目中的 cURL 封装到处都是，不统一并且使用起来也不方便，所以在有了 Composer 之后项目中直接加入了 guzzle。同样，为了解决异常日志栈的记录问题，monolog 也被加入到项目中。
这其中最大的一个变更是，受限于框架底层实现的问题，框架本身的 ORM 极其难用，并且整个是基于 mysql_query 来实现的。所以我们设法直接在框架中集成了 Laravel 的 ORM eloquent 减轻痛苦。
至此，项目解决了四个基本问题：
 第三方库的引入； 服务端发送请求的处理； 项目日志记录； ORM 的易用性。  这些改动都是为了解决开发上的问题。但开发上某些问题依旧存在：老的代码难以改动，并且 PHP 5.5 之后 mysql_query 系列的方法已经逐步被废弃。所以在后续的修改中一次性将这些方法都替换成了 mysqli 的实现，这也使得后续的 PHP7 升级工作能够继续进行下去。
3、项目拆分 项目的拆分分为两个部分，一个是逐步隔离两个老项目和新项目之间的资源、使新项目能够摆脱历史包袱快步前进；第二个是对新项目本身的拆分工作。</description>
            <content type="html"><![CDATA[<blockquote>
<p>本文未经许可禁止转载，如有转载意愿请与作者联系。</p>
</blockquote>
<h2 id="1项目历史">1、项目历史</h2>
<p>我们团队现在做的是一个微信第三方平台项目，项目起步时间不长，到现在差不多两年。起初是个探索性的小项目，但是随着业务的发展，已有的结构渐渐不能满足业务需求以及高峰时段的压力；不仅如此，一些历史问题也给我的开发流程带来了不少问题。所以这半年以来，再满足产品高速迭代的需求的前提下，我们也对后台框架以及服务器的结构做了持续的调整和优化。本文主要是针对后台部分的变动进行整理。</p>
<p>项目开始的时候，组里还有其他两个项目处于维护阶段。并且这个项目后台的起步也是直接从原来的项目里 copy 了部分结构代码并在这基础上进行改动，所以有很多历史遗留问题在里面。项目本身的框架还是 11 年左右的一个 cakePHP 的变种框架，项目框架从来没有更新过，甚至项目本身的 <code>String</code> 类封装每次调用都会触发 bug。</p>
<p>在服务器上，三个项目最开始的时候是共享所有的服务器资源的。而较老的项目由于只维护不开发，一些业务组件，比如 memcached、sphinx 中文版（Coreseek）以及一些 PHP 的扩展早已没有更新，但是每次服务器变更的时候还得考虑这些东西。</p>
<p>最近半年，通过不断的调整和修改，我们解决了大部分历史遗留问题，并成功升级到 PHP7。</p>
<h2 id="2基本能力">2、基本能力</h2>
<p>PHP 最近几年发展势头也是很快，Composer、Laravel 等组件和框架逐渐流行起来。借助第三方的力量能够很大程度的简化自己的工作、提高开发效率。</p>
<p>虽然以前项目中也有引入 PHPExcel 等第三方库，但都是通过下载源码丢到项目本身的方式来做的。这样做的问题是引入并不方便，并且一般不会及时通过升级来解决一些第三方库的 bug、漏洞等问题。为了提高框架的基础能力，我们在框架中引入了 <a href="https://getcomposer.org/">Composer</a>。</p>
<p>在 Compoer 的引入的同时我们也引入了一些优秀的库来解决基础问题。之前项目中的 cURL 封装到处都是，不统一并且使用起来也不方便，所以在有了 Composer 之后项目中直接加入了 <a href="https://github.com/guzzle/guzzle">guzzle</a>。同样，为了解决异常日志栈的记录问题，<a href="https://github.com/Seldaek/monolog">monolog</a> 也被加入到项目中。</p>
<p>这其中最大的一个变更是，受限于框架底层实现的问题，框架本身的 ORM 极其难用，并且整个是基于 <code>mysql_query</code> 来实现的。所以我们设法直接在框架中集成了 Laravel 的 ORM  <a href="https://laravel.com/docs/master/eloquent">eloquent</a> 减轻痛苦。</p>
<p>至此，项目解决了四个基本问题：</p>
<ol>
<li>第三方库的引入；</li>
<li>服务端发送请求的处理；</li>
<li>项目日志记录；</li>
<li>ORM 的易用性。</li>
</ol>
<p>这些改动都是为了解决开发上的问题。但开发上某些问题依旧存在：老的代码难以改动，并且 PHP 5.5 之后 <code>mysql_query</code> 系列的方法已经逐步被废弃。所以在后续的修改中一次性将这些方法都替换成了 <code>mysqli</code> 的实现，这也使得后续的 PHP7 升级工作能够继续进行下去。</p>
<h2 id="3项目拆分">3、项目拆分</h2>
<p>项目的拆分分为两个部分，一个是逐步隔离两个老项目和新项目之间的资源、使新项目能够摆脱历史包袱快步前进；第二个是对新项目本身的拆分工作。</p>
<p>上文中提到，项目起步时的基础代码和环境都是从原来的两个项目里直接 copy 过来的，甚至硬件资源都是公用的。因为几个项目整个的战线拉的很长，所以一些依赖的组件和服务有些都是很古老的，甚至是没有继续维护的。也有一些内部的组件依赖。这导致无论想做什么新的尝试都需要瞻前顾后，总是要考虑到是不是会影响到原来的东西。</p>
<p>由于硬件资源完全共享，而一些业务高峰时间带来的压力总是会导致服务器资源占用飙升，几个项目的服务同时挂掉，并且经常短时间内难以恢复正常。为了解决这个问题，我们对之前的两个项目和这个项目的物理资源分配做了一些调整，并做了隔离。</p>
<p>在项目上，最开始这个项目的所有功能模块，包括消息转发系统和主站部分全部都是耦合在一起的一套代码，由于框架本身的问题，效率并不高。在项目的改进中，我们逐渐分离了核心的消息系统部分并采用性能更高的框架（phalcon）完全重写。硬件上消息系统和主站也进行了分开部署，使两个部分不会相互影响。</p>
<h2 id="4持续改进">4、持续改进</h2>
<p>技术总是在持续的优化中进步，项目改进的脚步也从不曾停止。</p>
<p>在持续的改进过程中，我们继续进行了以下的部分工作：</p>
<ol>
<li>使用 Redis 完全替换了以前依赖的 memcached 和 memcacheq，在缓存和消息处理上变得结构单一易于维护，引入 Redis 集群提高可靠性；</li>
<li>引入优秀第三方的库封装微信 API 调用的部分，节省工作时间；</li>
<li>在发布环境，增加了预发布环境尽量靠近线上环境，降低每周发布之后的 bug 量；</li>
<li>在开发环境打开所有 <code>E_NOTICE</code> 及以上的告警，尽量减少 bug 并优化代码逻辑，搭建 <a href="https://github.com/getsentry/sentry">sentry</a> 平台记录线上的错误及异常日志，便于查找和及时修复；</li>
<li>使用 elasticsearch 存储服务器日志以及全文检索的内容；</li>
<li>整理所有 crontab 脚本，将所有本身需要长期服务的任务使用 <code>supervisor</code> 集中管理；</li>
<li>推动 https 切换。</li>
</ol>
<h2 id="5版本升级">5、版本升级</h2>
<p>PHP7 带来的内存使用量降低和性能优化是很令人心动的，在很长一段时间里，受限与项目环境的原因，项目基本上没有可能在短期内升级。</p>
<p>但在升级 PHP7 之前实际上已经进行过另外一次升级工作。起因是机房迁移，需要将所有的服务器都迁移到新的机器上去。借助这个机会，我们把所有的服务组件都进行了整理和重新编译，并且相应的升级了 Nginx（1.4 到 1.8）、openssl（解决之前 openssl 爆出的一些列安全问题），也将 PHP 从 5.4 升级到了 5.6。</p>
<p>在这期间，由于对 MySQL 存储 emoji 表情有需求，通过较长时间调研和实践，最终也将 MySQL 从 5.5 升级到了 5.7（但请注意：MySQL 主从同步，无法直接从 5.5 同步到 5.7，只能通过 5.5 -&gt; 5.6 -&gt; 5.7 这种方式）。</p>
<p>之后的几个月里，项目基本上保持着高速稳定的状态运行着。经过一段时间的等待，项目需要的几个开源的核心扩展完成 PHP7 版本的开发工作之后，我们也开始进行升级 PHP7 的工作。</p>
<p>升级的工作主要包括两部分：检查语法兼容性，解决扩展兼容问题。因为有些扩展并不是来自开源社区，需要自己手动去改。</p>
<p>整个升级的节奏也是分成了两个部分：先动消息框架，再升级主站。由于两个老项目的状态，所以决定不对其进行变更，还是维持在原来的状态。丢掉包袱才能快步前进。</p>
<p>消息框架依赖较少，主要就是 phalcon 和 redis，所以升级过程比较顺利。</p>
<p>主站依赖的内部扩展较多，语法兼容性问题也比较多。所以使用了开源项目检查语法兼容性。对框架底层做了一些改动，这里面最主要的还是从 <code>mysql</code> 换到 <code>mysqli</code> 的工作。</p>
<p>扩展部分在编译过程中就可以把大部分不兼容的语法暴露出来，进行修改并重新编译测试即可。</p>
<p>总结起来，一共经历过以下步骤：</p>
<ol>
<li>重新编译所有服务组件、升级 Nginx（1.4 到 1.6），PHP （5.4 到 5.6）；</li>
<li>升级 MySQL （5.5 到 5.7）；</li>
<li>消息框架升级 PHP7；</li>
<li>修改主站框架，将底层 <code>mysql_query</code> 替换为 <code>mysqli</code>；</li>
<li>检查主站代码兼容性；</li>
<li>修改主站使用的内部扩展，使其兼容 PHP7；</li>
<li>主站升级 PHP7。</li>
</ol>
<h2 id="6结语">6、结语</h2>
<p>随着业务的发展，项目也会面对越来越多的问题。技术上不断前进，不断提高个人水平。做好迎接更多的挑战的准备，也总会有更多的惊喜。</p>
]]></content>
        </item>
        
        <item>
            <title>一个关于 PHP 的 new 的小问题的探究</title>
            <link>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</link>
            <pubDate>Mon, 21 Nov 2016 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-11-21-an-issue-of-php-new/</guid>
            <description>问题起因 前两天有人在群里说了一个关于 new 和 stdClass 的问题，具体表现如下：
&amp;lt;?php $a = new stdClass; $b = new $a; var_dump($a, $b); 这段代码是可以正确运行的，并且 $a 和 $b 是两个不同的空对象。即使在 new $a 之前给 $a 添加属性并赋值，$b 也始终是一个的空对象。
所以问题就是：为什么空对象还可以跟在 new 后面，stdClass 有什么特殊的地方吗？
实际表现 其实主要稍加验证就能知道，其实这和 stdClass 并没有什么关系，完全是 new 的行为决定的，比如在 psysh 上做一下简单的测试：
&amp;gt;&amp;gt;&amp;gt; $a = new Reflection; =&amp;gt; Reflection {#174} &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Reflection {#177} 这里我是 new 了一个 Reflection 类的实例，和 stdClass 的表现没有区别。当然也可以自定义一个类：
&amp;gt;&amp;gt;&amp;gt; class Test { public $foo = 1; } =&amp;gt; null &amp;gt;&amp;gt;&amp;gt; $a = new Test =&amp;gt; Test {#178 +foo: 1, } &amp;gt;&amp;gt;&amp;gt; $a-&amp;gt;foo = 2; =&amp;gt; 2 &amp;gt;&amp;gt;&amp;gt; $b = new $a; =&amp;gt; Test {#180 +foo: 1, } 从这个例子中我们可以清楚的看到，改变 $a 的属性对 $b 没有任何影响（到这里也可以顺便思考一下 PHP 的一个关键字：clone）。</description>
            <content type="html"><![CDATA[<h2 id="问题起因">问题起因</h2>
<p>前两天有人在群里说了一个关于 <code>new</code> 和 <code>stdClass</code> 的问题，具体表现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="k">stdClass</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="k">new</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">);</span>
</code></pre></div><p>这段代码是可以正确运行的，并且 <code>$a</code> 和 <code>$b</code> 是两个不同的空对象。即使在 <code>new $a</code> 之前给 <code>$a</code> 添加属性并赋值，<code>$b</code> 也始终是一个的空对象。</p>
<p>所以问题就是：为什么空对象还可以跟在 <code>new</code> 后面，<code>stdClass</code> 有什么特殊的地方吗？</p>
<h2 id="实际表现">实际表现</h2>
<p>其实主要稍加验证就能知道，其实这和 <code>stdClass</code> 并没有什么关系，完全是 <code>new</code> 的行为决定的，比如在 <a href="http://psysh.org/">psysh</a> 上做一下简单的测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">&gt;&gt;&gt; $a = new Reflection;
=&gt; Reflection {#174}
&gt;&gt;&gt; $b = new $a;
=&gt; Reflection {#177}
</code></pre></div><p>这里我是 new 了一个 <code>Reflection</code> 类的实例，和 <code>stdClass</code> 的表现没有区别。当然也可以自定义一个类：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">&gt;&gt;&gt; class Test { public $foo = 1; }
=&gt; null
&gt;&gt;&gt; $a = new Test
=&gt; Test {#178
     +foo: 1,
   }
&gt;&gt;&gt; $a-&gt;foo = 2;
=&gt; 2
&gt;&gt;&gt; $b = new $a;
=&gt; Test {#180
     +foo: 1,
   }
</code></pre></div><p>从这个例子中我们可以清楚的看到，改变 <code>$a</code> 的属性对 <code>$b</code> 没有任何影响（到这里也可以顺便思考一下 PHP 的一个关键字：<code>clone</code>）。</p>
<p>既然已经知道了表现，也可以得到结论：通过一个类的对象 <code>new</code> 出一个新对象等同于 <code>new</code> 原对象的类。</p>
<h2 id="原因">原因</h2>
<p>那么 PHP 是什么样的实现造成了这种表现呢？还是从源码入手来解析这个问题。</p>
<p>其实从源码中，我们可以直奔 <code>zend_vm_def.h</code> 中找到答案，在关于 <code>ZEND_FETCH_CLASS</code> 这个 opcode 的解释中，我们可以看到以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">ZEND_VM_HANDLER</span><span class="p">(</span><span class="mi">109</span><span class="p">,</span> <span class="n">ZEND_FETCH_CLASS</span><span class="p">,</span> <span class="n">ANY</span><span class="p">,</span> <span class="n">CONST</span><span class="o">|</span><span class="n">TMPVAR</span><span class="o">|</span><span class="n">UNUSED</span><span class="o">|</span><span class="n">CV</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">OP2_TYPE</span> <span class="o">==</span> <span class="n">IS_CONST</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span> <span class="o">==</span> <span class="n">IS_OBJECT</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Z_CE_P</span><span class="p">(</span><span class="n">EX_VAR</span><span class="p">(</span><span class="n">opline</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span><span class="n">var</span><span class="p">))</span> <span class="o">=</span> <span class="n">Z_OBJCE_P</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span>
        <span class="p">}</span> <span class="p">...</span>
        <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><p>去掉一些干扰的上下文，上面的内容很清晰的呈现出一个解释：如果取到的 <code>class_name</code> 是一个对象，则通过 <code>Z_OBJCE_P</code> 的宏找到它的类。所以上面的表现解释起来就很容易了。</p>
<p>这本身是一个很简单的问题，不用往复杂了去想。如果想知道具体的 <code>new</code> 的实现，可以到 <code>zend_compile.c</code> 文件中去查看 <code>zend_compile_new</code> 的实现。</p>
]]></content>
        </item>
        
        <item>
            <title>PHP 7.1 新特性一览</title>
            <link>http://0x1.im/posts/2016-09-14-features-of-php71/</link>
            <pubDate>Wed, 14 Sep 2016 00:29:02 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-09-14-features-of-php71/</guid>
            <description>PHP 7.1 release版本发布在即，本文整理一下 7.1 中的一些新特性以供了解。所有内容均选自官方 RFC 文档。
 可空类型 可空类型主要用于参数类型声明和函数返回值声明。
主要的两种形式如下：
&amp;lt;?php function answer(): ?int { return null; //ok } function answer(): ?int { return 42; // ok } function say(?string $msg) { if ($msg) { echo $msg; } } 从例子很容易理解，所指的就是通过 ? 的形式表明函数参数或者返回值的类型要么为指定类型，要么为 null。
此方法也可用于接口函数的定义：
&amp;lt;?php interface Fooable { function foo(?Fooable $f); } 但有一个需要注意的地方：如果函数本身定义了参数类型并且没有默认值，即使是可空的，也不能省略，否则会触发错误。如下：
&amp;lt;?php function foo_nullable(?Bar $bar) {} foo_nullable(new Bar); // 可行 foo_nullable(null); // 可行 foo_nullable(); // 不可行 但是如果以上函数的参数定义为 ?</description>
            <content type="html"><![CDATA[<blockquote>
<p>PHP 7.1 release版本发布在即，本文整理一下 7.1 中的一些新特性以供了解。所有内容均选自官方 RFC 文档。</p>
</blockquote>
<h2 id="可空类型">可空类型</h2>
<p>可空类型主要用于参数类型声明和函数返回值声明。</p>
<p>主要的两种形式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">answer</span><span class="p">()</span><span class="o">:</span> <span class="o">?</span><span class="nx">int</span>  <span class="p">{</span>
    <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">//ok
</span><span class="c1"></span><span class="p">}</span>

<span class="k">function</span> <span class="nf">answer</span><span class="p">()</span><span class="o">:</span> <span class="o">?</span><span class="nx">int</span>  <span class="p">{</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// ok
</span><span class="c1"></span><span class="p">}</span>

<span class="k">function</span> <span class="nf">say</span><span class="p">(</span><span class="o">?</span><span class="nx">string</span> <span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">echo</span> <span class="nv">$msg</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>从例子很容易理解，所指的就是通过 <code>?</code> 的形式表明函数参数或者返回值的类型要么为指定类型，要么为 <code>null</code>。</p>
<p>此方法也可用于接口函数的定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">interface</span> <span class="nx">Fooable</span> <span class="p">{</span>
    <span class="k">function</span> <span class="nf">foo</span><span class="p">(</span><span class="o">?</span><span class="nx">Fooable</span> <span class="nv">$f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>但有一个需要注意的地方：如果函数本身定义了参数类型并且没有默认值，即使是可空的，也不能省略，否则会触发错误。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">foo_nullable</span><span class="p">(</span><span class="o">?</span><span class="nx">Bar</span> <span class="nv">$bar</span><span class="p">)</span> <span class="p">{}</span>

<span class="nx">foo_nullable</span><span class="p">(</span><span class="k">new</span> <span class="nx">Bar</span><span class="p">);</span> <span class="c1">// 可行
</span><span class="c1"></span><span class="nx">foo_nullable</span><span class="p">(</span><span class="k">null</span><span class="p">);</span> <span class="c1">// 可行
</span><span class="c1"></span><span class="nx">foo_nullable</span><span class="p">();</span> <span class="c1">// 不可行
</span></code></pre></div><p>但是如果以上函数的参数定义为 <code>?Bar $bar = null</code> 的形式，则第三种写法也是可行的。因为 <code>= null</code> 实际上相当于 <code>?</code> 的超集，对于可空类型的参数，可以设定 <code>null</code> 为默认值。</p>
<h2 id="list-的方括号简写">list 的方括号简写</h2>
<p>我们知道在 PHP5.4 之前只能通过 <code>array()</code> 来定义数组，5.4之后添加了 <code>[]</code> 的简化写法（省略了5个字符还是很实在的）。</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1">// 5.4 之前
</span><span class="c1"></span><span class="nv">$array</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nv">$array</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s2">&#34;a&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">// 5.4 及之后
</span><span class="c1"></span><span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;a&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">];</span>
</code></pre></div><p>引申到另外一个问题上，如果我们要把数组的值赋值给不同的变量，可以通过 <code>list</code> 来实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
</code></pre></div><p>是否也可以通过 <code>[]</code> 的简写来实现呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="p">[</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$c</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
</code></pre></div><p>以及下一个特性中会提到的 list 指定 key：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="p">[</span><span class="s2">&#34;a&#34;</span> <span class="o">=&gt;</span> <span class="nv">$a</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span> <span class="o">=&gt;</span> <span class="nv">$b</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span> <span class="o">=&gt;</span> <span class="nv">$c</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
</code></pre></div><p>PHP7.1 实现了这个特性。但是要注意的是：出现在左值中的 <code>[]</code> 并不是数组的简写，是 <code>list()</code> 的简写。</p>
<p>但是并不仅仅如此，新的 <code>list()</code> 的实现并不仅仅可以出现在左值中，也能在 <code>foreach</code> 循环中使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">foreach</span> <span class="p">(</span><span class="nv">$points</span> <span class="k">as</span> <span class="p">[</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="nv">$x</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="nv">$y</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">var_dump</span><span class="p">(</span><span class="nv">$x</span><span class="p">,</span> <span class="nv">$y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>不过因为实现的问题，<code>list()</code> 和 <code>[]</code> 不能相互嵌套使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1">// 不合法
</span><span class="c1"></span><span class="k">list</span><span class="p">([</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">],</span> <span class="p">[</span><span class="nv">$c</span><span class="p">,</span> <span class="nv">$d</span><span class="p">])</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>

<span class="c1">// 不合法
</span><span class="c1"></span><span class="p">[</span><span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">),</span> <span class="k">list</span><span class="p">(</span><span class="nv">$c</span><span class="p">,</span> <span class="nv">$d</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>

<span class="c1">// 合法
</span><span class="c1"></span><span class="p">[[</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">],</span> <span class="p">[</span><span class="nv">$c</span><span class="p">,</span> <span class="nv">$d</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>
</code></pre></div><h2 id="允许在-list-中指定-key">允许在 list 中指定 key</h2>
<p>上文提到过，新的 <code>list()</code> 的实现中可以指定key：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;a&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">[</span><span class="s2">&#34;a&#34;</span> <span class="o">=&gt;</span> <span class="nv">$a</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span> <span class="o">=&gt;</span> <span class="nv">$b</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span> <span class="o">=&gt;</span> <span class="nv">$c</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
</code></pre></div><p>这也就相当于:</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">];</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">];</span>
<span class="nv">$c</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">];</span>
</code></pre></div><p>和以往的区别在于以往的 <code>list()</code> 的实现相当于 key 只能是 <code>0, 1, 2, 3</code> 的数字形式并且不能调整顺序。执行以下语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;2&#39;</span><span class="p">];</span>
</code></pre></div><p>会得到 <code>PHP error:  Undefined offset: 0...</code> 的错误。</p>
<p>而新的实现则可以通过以下方式来调整赋值：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="nv">$a</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;2&#39;</span><span class="p">];</span>
</code></pre></div><p>不同于数组的是，<code>list</code> 并不支持混合形式的 key，以下写法会触发解析错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1">// Parse error: syntax error, ...
</span><span class="c1"></span><span class="k">list</span><span class="p">(</span><span class="nv">$unkeyed</span><span class="p">,</span> <span class="s2">&#34;key&#34;</span> <span class="o">=&gt;</span> <span class="nv">$keyed</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>
</code></pre></div><p>更复杂的情况，<code>list</code> 也支持复合形式的解析：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">];</span>

<span class="k">list</span><span class="p">(</span><span class="k">list</span><span class="p">(</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="nv">$x1</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="nv">$y1</span><span class="p">),</span> <span class="k">list</span><span class="p">(</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="nv">$x2</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="nv">$y2</span><span class="p">))</span> <span class="o">=</span> <span class="nv">$points</span><span class="p">;</span>

<span class="nv">$points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&#34;first&#34;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">&#34;second&#34;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">];</span>

<span class="k">list</span><span class="p">(</span><span class="s2">&#34;first&#34;</span> <span class="o">=&gt;</span> <span class="k">list</span><span class="p">(</span><span class="nv">$x1</span><span class="p">,</span> <span class="nv">$y1</span><span class="p">),</span> <span class="s2">&#34;second&#34;</span> <span class="o">=&gt;</span> <span class="k">list</span><span class="p">(</span><span class="nv">$x2</span><span class="p">,</span> <span class="nv">$y2</span><span class="p">))</span> <span class="o">=</span> <span class="nv">$points</span><span class="p">;</span>
</code></pre></div><p>以及循环中使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">];</span>

<span class="k">foreach</span> <span class="p">(</span><span class="nv">$points</span> <span class="k">as</span> <span class="k">list</span><span class="p">(</span><span class="s2">&#34;x&#34;</span> <span class="o">=&gt;</span> <span class="nv">$x</span><span class="p">,</span> <span class="s2">&#34;y&#34;</span> <span class="o">=&gt;</span> <span class="nv">$y</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;Point at (</span><span class="si">$x</span><span class="s2">, </span><span class="si">$y</span><span class="s2">)&#34;</span><span class="p">,</span> <span class="nx">PHP_EOL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="void-返回类型">void 返回类型</h2>
<p>PHP7.0 添加了指定函数返回类型的特性，但是返回类型却不能指定为 <code>void</code>，7.1 的这个特性算是一个补充：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">should_return_nothing</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Fatal error: A void function must not return a value
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>以下两种情况都可以通过验证：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">lacks_return</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="c1">// valid
</span><span class="c1"></span><span class="p">}</span>

<span class="k">function</span> <span class="nf">returns_nothing</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">// valid
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>定义返回类型为 <code>void</code> 的函数不能有返回值，即使返回 <code>null</code> 也不行：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">returns_one</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Fatal error: A void function must not return a value
</span><span class="c1"></span><span class="p">}</span>

<span class="k">function</span> <span class="nf">returns_null</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// Fatal error: A void function must not return a value
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>此外 <code>void</code> 也只适用于返回类型，并不能用于参数类型声明，或者会触发错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">foobar</span><span class="p">(</span><span class="nx">void</span> <span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Fatal error: void cannot be used as a parameter type
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>类函数中对于返回类型的声明也不能被子类覆盖，否则会触发错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">bar</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foobar</span> <span class="k">extends</span> <span class="nx">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">bar</span><span class="p">()</span><span class="o">:</span> <span class="k">array</span> <span class="p">{</span> <span class="c1">// Fatal error: Declaration of Foobar::bar() must be compatible with Foo::bar(): void
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="类常量属性设定">类常量属性设定</h2>
<p>这个特性说起来比较简单，就是现在类中的常量支持使用 <code>public</code>、<code>private</code> 和 <code>protected</code> 修饰了：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">class</span> <span class="nc">Token</span> <span class="p">{</span>
    <span class="c1">// 常量默认为 public
</span><span class="c1"></span>    <span class="k">const</span> <span class="no">PUBLIC_CONST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 可以自定义常量的可见范围
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">const</span> <span class="no">PRIVATE_CONST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">protected</span> <span class="k">const</span> <span class="no">PROTECTED_CONST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">const</span> <span class="no">PUBLIC_CONST_TWO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 多个常量同时声明只能有一个属性
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">const</span> <span class="no">FOO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">BAR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>此外，接口（interface）中的常量只能是 <code>public</code> 属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">interface</span> <span class="nx">ICache</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="no">PUBLIC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="no">IMPLICIT_PUBLIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>为了应对变化，反射类的实现也相应的丰富了一下，增加了 <code>getReflectionConstant</code> 和 <code>getReflectionConstants</code> 两个方法用于获取常量的额外属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">class</span> <span class="nc">testClass</span>  <span class="p">{</span>
    <span class="k">const</span> <span class="no">TEST_CONST</span> <span class="o">=</span> <span class="s1">&#39;test&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ReflectionClass</span><span class="p">(</span> <span class="s2">&#34;testClass&#34;</span> <span class="p">);</span>
<span class="nv">$const</span> <span class="o">=</span> <span class="nv">$obj</span><span class="o">-&gt;</span><span class="na">getReflectionConstant</span><span class="p">(</span> <span class="s2">&#34;TEST_CONST&#34;</span> <span class="p">);</span>
<span class="nv">$consts</span> <span class="o">=</span> <span class="nv">$obj</span><span class="o">-&gt;</span><span class="na">getReflectionConstants</span><span class="p">();</span>
</code></pre></div><h2 id="多条件-catch">多条件 catch</h2>
<p>在以往的 <code>try ... catch</code> 语句中，每个 <code>catch</code> 只能设定一个条件判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// Some code...
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ExceptionType1</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理 ExceptionType1
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ExceptionType2</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理 ExceptionType2
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">\Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>新的实现中可以在一个 <code>catch</code> 中设置多个条件，相当于或的形式判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// Some code...
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ExceptionType1</span> <span class="o">|</span> <span class="nx">ExceptionType2</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 对于 ExceptionType1 和 ExceptionType2 的处理
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">\Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>对于异常的处理简化了一些。</p>
<h2 id="附源-rfc-地址">附：源 RFC 地址</h2>
<ul>
<li><a href="https://wiki.php.net/rfc/nullable_types">Nullable Types</a></li>
<li><a href="https://wiki.php.net/rfc/short_list_syntax">Square bracket syntax for array destructuring assignment</a></li>
<li><a href="https://wiki.php.net/rfc/list_keys">Allow specifying keys in list()</a></li>
<li><a href="https://wiki.php.net/rfc/negative-string-offsets">Generalize support of negative string offsets</a></li>
<li><a href="https://wiki.php.net/rfc/void_return_type">Void Return Type</a></li>
<li><a href="https://wiki.php.net/rfc/class_const_visibility">Class constant visibility modifiers</a></li>
<li><a href="https://wiki.php.net/rfc/multiple-catch">Multi catch</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>PHP 错误与异常的日志记录</title>
            <link>http://0x1.im/posts/2016-07-31-php-error-exception-log/</link>
            <pubDate>Sun, 31 Jul 2016 20:59:51 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-07-31-php-error-exception-log/</guid>
            <description>提到 Nginx + PHP 服务的错误日志，我们通常能想到的有 Nginx 的 access 日志、error 日志以及 PHP 的 error 日志。虽然看起来是个很简单的问题，但里面其实又牵扯到应用配置以及日志记录位置的问题，如果是在 ubuntu 等系统下使用 apt-get 的方式来安装，其自有一套较为合理的的配置文件可用。再者运行的应用程序中的配置也会影响到日志记录的方式及内容。
错误与异常的区别 关于错误与异常，我们可以用一个简单的例子来理解：
&amp;lt;?php try { 1 / 0; } catch (Exception $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 执行这个小示例会直接得到一个『PHP Warning: Division by zero …』错误。原因很简单：这是逻辑错误，并不是异常，所以不能被 try 捕获。同样，对于变量使用前未定义这种问题，也是同样的会产生 warning 而不是被捕获。
但是这个问题在 PHP7 中却有了一些改动，比如上面的例子中我把 / 改成 %，在 PHP7 的环境中执行会得到一个不一样的提示：
 PHP Fatal error: Uncaught DivisionByZeroError &amp;hellip;
 根据这个提示，如果我把 catch 中的条件修改一下：
&amp;lt;?php try { 1 / 0; } catch (DivisionByZeroError $e) { echo &amp;#34;catched&amp;#34;, PHP_EOL; } 这样就可以正常捕获到错误并输出 catched 了。</description>
            <content type="html"><![CDATA[<p>提到 Nginx + PHP 服务的错误日志，我们通常能想到的有 Nginx 的 access 日志、error 日志以及 PHP 的 error 日志。虽然看起来是个很简单的问题，但里面其实又牵扯到应用配置以及日志记录位置的问题，如果是在 ubuntu 等系统下使用 apt-get 的方式来安装，其自有一套较为合理的的配置文件可用。再者运行的应用程序中的配置也会影响到日志记录的方式及内容。</p>
<h2 id="错误与异常的区别">错误与异常的区别</h2>
<p>关于错误与异常，我们可以用一个简单的例子来理解：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Exception</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;catched&#34;</span><span class="p">,</span> <span class="nx">PHP_EOL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>执行这个小示例会直接得到一个『PHP Warning:  Division by zero …』错误。原因很简单：这是逻辑错误，并不是异常，所以不能被 <code>try</code> 捕获。同样，对于变量使用前未定义这种问题，也是同样的会产生 warning 而不是被捕获。</p>
<p>但是这个问题在 PHP7 中却有了一些改动，比如上面的例子中我把 <code>/</code> 改成 <code>%</code>，在 PHP7 的环境中执行会得到一个不一样的提示：</p>
<blockquote>
<p>PHP Fatal error:  Uncaught DivisionByZeroError &hellip;</p>
</blockquote>
<p>根据这个提示，如果我把 catch 中的条件修改一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">DivisionByZeroError</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;catched&#34;</span><span class="p">,</span> <span class="nx">PHP_EOL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这样就可以正常捕获到错误并输出 <code>catched</code> 了。</p>
<p>对于第一个示例，同样如果把 <code>Excepiton</code> 修改为 <code>ErrorException</code> 也可以正常捕获。</p>
<p>至于为什么求余和除法，在 PHP5 中提示一致而在 PHP7（我的测试环境是 7.0.4） 中除法不属于 <code>DivisionByZeroError</code> 的问题，这应该是个 <a href="https://bugs.php.net/bug.php?id=69957">BUG</a>。</p>
<h2 id="日志的记录">日志的记录</h2>
<p>PHP 本身可配置的 log 大概有以下几个：</p>
<ul>
<li>php-fpm error log（php-fpm.conf 中配置，记录 php-fpm 进程的启动和终止等信息）</li>
<li>php-fpm slow log（也是在 php-fpm.conf 中配置，记录慢执行）</li>
<li>php error log（php.ini 中配置，记录应用程序的错误日志）</li>
</ul>
<p>此外 Nginx 还有两个可配置的log：access 和 error log。这几个日志文件的功能不同，记录的内容也不同。但其中有一个点需要注意：如果配置了 php-fpm 中的 error log 位置，但日志位置不可写（配置时位置得是对的，因为 php-fpm 启动时会做检查），在适当的配置条件下错误日志会被返回到 cgi 中从而写入 nginx 的 error log 中。</p>
<p>所以遇到问题是我们一般的查找思路都是：</p>
<ol>
<li>到 Nginx access log 中查看请求的状态码</li>
<li>查看 php error log 中的错误记录以及 stack 信息</li>
<li>查看 php-fpm log 中有无异常重启记录（如果核心或者扩展问题，会出现此情况）</li>
</ol>
<p>但是在以上几种情况下你也会发现，这里面并没有上文提到的程序抛出异常的日志记录。</p>
<h2 id="异常记录">异常记录</h2>
<p>异常不同于错误，严格上说它是应用程序逻辑的异常而不是错误，是可以通过合理的程序逻辑来手动触发的。但大多情况下异常也是要进行记录的，比如数据库无法连接或者框架的不当使用触发的异常，我们需要通过日志来定位问题并及时处理。</p>
<p>PHP 提供了两个函数用于自定义处理错误和异常的方法：</p>
<ul>
<li>set_error_handler</li>
<li>set_exception_handler</li>
</ul>
<p>所以可以通过 <code>set_exception_handler</code>  函数注入方法捕获所有的异常并记录 。</p>
<p><a href="https://github.com/Seldaek/monolog">monolog</a> 是一个优秀的异常记录的库，也是基于 <a href="http://www.php-fig.org/psr/psr-3/">PSR-3</a> 标准的实现。Laravel、Symfony 中默认也是使用它来记录异常。如有需要，也可以考虑在自己的项目中引入。</p>
]]></content>
        </item>
        
        <item>
            <title>PHP 共享内存使用与信号控制</title>
            <link>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</link>
            <pubDate>Sun, 01 May 2016 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-05-01-php-use-shared-memory/</guid>
            <description>共享内存 共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。
PHP 内置的 shmop 扩展 (Shared Memory Operations) 提供了一系列共享内存操作的函数（可能是用的人不多吧，这一块儿的文档还没有中文翻译）。在 Linux 上，这些函数直接是通过调用 shm* 系列的函数实现，而 Winodows 上也通过对系统函数的封装实现了同样的调用。
主要函数：
 shmop_close — 关闭共享内存块 shmop_delete — 删除共享内存块 shmop_open — 创建或打开共享内存块 shmop_read — 从共享内存块中读取数据 shmop_size — 获取共享内存块的大小 shmop_write — 向共享内存块中写入数据  与此相关的还有一个很重要的函数：ftok，通过文件的 inode 信息（*nix 上通过 stat 或 ls -i 命令查看）创建 IPC 的唯一 key（文件/文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。
一个简单的计数例子：
&amp;lt;?php # 创建一块共享内存 $shm_key = ftok(__FILE__, &amp;#39;t&amp;#39;); $shm_id = shmop_open($shm_key, &amp;#39;c&amp;#39;, 0644, 8); # 读取并写入数据 $count = (int) shmop_read($shm_id, 0, 8) + 1; shmop_write($shm_id, str_pad($count, 8, &amp;#39;0&amp;#39;, STR_PAD_LEFT), 0); // echo shmop_read($shm_id, 0, 8); # 关闭内存块，并不会删除共享内存，只是清除 PHP 的资源 shmop_close($shm_id); 以上这段代码没执行一次计数加 1，而且数据是在不同进程之间共享的。也就是说除非手动删除这块内存使用，否则这个数据是不会重置的。</description>
            <content type="html"><![CDATA[<h2 id="共享内存">共享内存</h2>
<p>共享内存的使用主要是为了能够在同一台机器不同的进程中共享一些数据，比如在多个 php-fpm 进程中共享当前进程的使用情况。这种通信也称为进程间通信（Inter-Process Communication），简称 IPC。</p>
<p>PHP 内置的 <a href="http://php.net/manual/zh/book.shmop.php">shmop 扩展</a> (Shared Memory Operations) 提供了一系列共享内存操作的函数（可能是用的人不多吧，这一块儿的文档还没有中文翻译）。在 Linux 上，这些函数直接是通过调用 <a href="https://beej.us/guide/bgipc/output/html/multipage/shm.html">shm*</a> 系列的函数实现，而 Winodows 上也通过对系统函数的封装实现了同样的调用。</p>
<p>主要函数：</p>
<ul>
<li><a href="http://php.net/manual/zh/function.shmop-close.php">shmop_close</a> — 关闭共享内存块</li>
<li><a href="http://php.net/manual/zh/function.shmop-delete.php">shmop_delete</a> — 删除共享内存块</li>
<li><a href="http://php.net/manual/zh/function.shmop-open.php">shmop_open</a> — 创建或打开共享内存块</li>
<li><a href="http://php.net/manual/zh/function.shmop-read.php">shmop_read</a> — 从共享内存块中读取数据</li>
<li><a href="http://php.net/manual/zh/function.shmop-size.php">shmop_size</a> — 获取共享内存块的大小</li>
<li><a href="http://php.net/manual/zh/function.shmop-write.php">shmop_write</a> — 向共享内存块中写入数据</li>
</ul>
<p>与此相关的还有一个很重要的函数：<a href="http://php.net/manual/zh/function.ftok.php">ftok</a>，通过文件的 inode 信息（*nix 上通过 <code>stat</code> 或 <code>ls -i</code> 命令查看）创建 IPC 的唯一 key（文件/文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。</p>
<p>一个简单的计数例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1"># 创建一块共享内存
</span><span class="c1"></span><span class="nv">$shm_key</span> <span class="o">=</span> <span class="nx">ftok</span><span class="p">(</span><span class="no">__FILE__</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">);</span>
<span class="nv">$shm_id</span> <span class="o">=</span> <span class="nx">shmop_open</span><span class="p">(</span><span class="nv">$shm_key</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="c1"># 读取并写入数据
</span><span class="c1"></span><span class="nv">$count</span> <span class="o">=</span> <span class="p">(</span><span class="nx">int</span><span class="p">)</span> <span class="nx">shmop_read</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">shmop_write</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">,</span> <span class="nx">str_pad</span><span class="p">(</span><span class="nv">$count</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nx">STR_PAD_LEFT</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// echo shmop_read($shm_id, 0, 8);
</span><span class="c1"># 关闭内存块，并不会删除共享内存，只是清除 PHP 的资源
</span><span class="c1"></span><span class="nx">shmop_close</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">);</span>
</code></pre></div><p>以上这段代码没执行一次计数加 1，而且数据是在不同进程之间共享的。也就是说除非手动删除这块内存使用，否则这个数据是不会重置的。</p>
<p>有个需要稍微注意的点：<code>shmop_open</code> 的第二个参数是个 flag，类似 fopen 的第二个参数，其取值有以前几个：</p>
<ul>
<li>&ldquo;a&rdquo; 只读访问；</li>
<li>&ldquo;c&rdquo; 如果内存片段不存在，则创建，如果存在，则可读写；</li>
<li>&ldquo;w&rdquo; 读写；</li>
<li>&ldquo;n&rdquo; 创建新的内存片段，如果同样 key 的已存在，则会创建失败，这是为了安全使用共享内存考虑。</li>
</ul>
<p>此外，由于使用的共享内存片段是固定长度的，在存储和读取的时候要计算好数据的长度，不然可能会写入失败或者读取空值。</p>
<h2 id="信号控制">信号控制</h2>
<p>既然上面使用到了共享内存存储数据，就需要考虑是否有多个进程同时写入数据到共享内存的情况，是否需要避免冲突。如果是这样，就需要引入信号量进行控制。</p>
<p>PHP 也提供了类似的内置扩展 <a href="http://php.net/manual/zh/book.sem.php">sysvsem</a>（这个扩展在 Windows 环境下没有，文档中将 <code>ftok</code> 函数也归到这个扩展中，但实际上 <code>ftok</code> 是在标准函数库中提供的，所以在 Windows 下也是可用的）。</p>
<p>在说信号量控制之前，先说另外一件有意思的事情：看官方文档你会发现这里同样也有共享内存操作的函数（<code>shm_*</code>），因为这其实是同一类别（或者说来自于同一作者）的三个扩展，还有一个是 sysvmsg（队列消息） 。函数的实现上稍有差别，但实际做的事情基本相同。这和上文的 shmop 扩展有什么区别呢？shmop 源码下的 <code>README</code> 文件有简单的说明：</p>
<blockquote>
<p>PHP already had a shared memory extension (sysvshm) written by Christian Cartus <a href="mailto:cartus@atrior.de">cartus@atrior.de</a>, unfortunately this extension was designed with PHP only in mind and offers high level features which are extremely bothersome for basic SHM we had in mind.</p>
</blockquote>
<p>简单说来：sysvshm 扩展提供的方法并不是原封不动的存储用户的数据，而是先使用 PHP 的变量序列化函数对参数进行序列化然后再进行存储。这就导致通过这些方法存储的数据无法和非 PHP 进程共享。不过这样也能存储更丰富的 PHP 数据类型，上文的扩展中 <code>shmop_write</code> 只能写入字符串。那么为什么 sysvshm 同样不支持 Windows 呢？因为其并没有引入封装了 <code>shm*</code> 系列函数的 <code>tsrm_win32.h</code> 的头文件。</p>
<p>引入信号控制之后的示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$id_key</span> <span class="o">=</span> <span class="nx">ftok</span><span class="p">(</span><span class="no">__FILE__</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">);</span>
<span class="nv">$sem_id</span> <span class="o">=</span> <span class="nx">sem_get</span><span class="p">(</span><span class="nv">$id_key</span><span class="p">);</span>
<span class="c1"># 请求信号控制权
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">sem_acquire</span><span class="p">(</span><span class="nv">$sem_id</span><span class="p">))</span> <span class="p">{</span>
    <span class="nv">$shm_id</span> <span class="o">=</span> <span class="nx">shmop_open</span><span class="p">(</span><span class="nv">$id_key</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="c1"># 读取并写入数据
</span><span class="c1"></span>    <span class="nv">$count</span> <span class="o">=</span> <span class="p">(</span><span class="nx">int</span><span class="p">)</span> <span class="nx">shmop_read</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">shmop_write</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">,</span> <span class="nx">str_pad</span><span class="p">(</span><span class="nv">$count</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="nx">STR_PAD_LEFT</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// echo shmop_read($shm_id, 0, 8);
</span><span class="c1"></span>    <span class="c1"># 关闭内存块
</span><span class="c1"></span>    <span class="nx">shmop_close</span><span class="p">(</span><span class="nv">$shm_id</span><span class="p">);</span>
    <span class="c1"># 释放信号
</span><span class="c1"></span>    <span class="nx">sem_release</span><span class="p">(</span><span class="nv">$sem_id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>但是本地想模拟实现写入冲突实际上是非常难的（考虑到计算机的执行速度）。在本地测试中，使用 <code>for</code> 循环操作时如果不使用 <code>shmop_close</code> 关闭资源会出现无法打开共享内存的错误警告。这应该是因为正在共享内存被上一次操作占用中还没有释放导致。</p>
]]></content>
        </item>
        
        <item>
            <title>PHP 代码规范简洁之道</title>
            <link>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</link>
            <pubDate>Sun, 28 Feb 2016 12:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2016-02-28-tidy-your-php-code/</guid>
            <description>1. 统一的编码规范 编码规范往简单说其实就是三个方面：
 换行 空格 变量命名  放在 PHP 里面，还有一些附加的地方，比如关键字大小写，语法糖的使用（array() 与 [] 等）的问题。之前整理过 PSR 的标准，也找过 php-cs-fixer 这样的工具。这些都是规范代码的重要手段。有统一的标准，配合上工具的检查，形成统一的编码约束不是什么难题。
没有规范，不同的人甚至同一个人在空格、换行和命名上都有可能是十分随意的。代码一长，回使整个文件看起来无比杂乱。
典型的例子比如：if 和 else 的组合，可以写出无数种风格，比如：
&amp;lt;?php # 单语句不写大括号 if (true) doSomething(); # else 大括号换行 十分占篇幅 if (true) { doSomething(); } else { doElseThings(); } # 此外还有关键字后不带空格，随意缩进等等 # ... 再比如变量函数命名的问题上，各种混搭风格层出不穷：
&amp;lt;?php # 全小写 $someparam1 = null; # 首字母下环线 $_some_param_1 = null; # 某些库的类，下划线和大小写混用 class Abstract_ClassA { } 这里并不探讨各种写法的优缺点，只是风格需要保持统一，不要混用。
2. 良好的编码习惯 如果你仔细看过 PSR 的标准，可能也会注意到某些地方其实是标准无法涉及到的。比如一个超长的表达式在什么时候换行，如何缩进等。</description>
            <content type="html"><![CDATA[<h2 id="1-统一的编码规范">1. 统一的编码规范</h2>
<p>编码规范往简单说其实就是三个方面：</p>
<ol>
<li>换行</li>
<li>空格</li>
<li>变量命名</li>
</ol>
<p>放在 PHP 里面，还有一些附加的地方，比如关键字大小写，语法糖的使用（<code>array()</code> 与 <code>[]</code> 等）的问题。之前整理过 <a href="https://github.com/XiaoLer/php-develop-standards/blob/master/php-basic-coding-standard.md">PSR</a> 的标准，也找过 <a href="http://0x1.im/blog/php/php-cs-fixer.html">php-cs-fixer</a> 这样的工具。这些都是规范代码的重要手段。有统一的标准，配合上工具的检查，形成统一的编码约束不是什么难题。</p>
<p>没有规范，不同的人甚至同一个人在空格、换行和命名上都有可能是十分随意的。代码一长，回使整个文件看起来无比杂乱。</p>
<p>典型的例子比如：<code>if</code> 和 <code>else</code> 的组合，可以写出无数种风格，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1"># 单语句不写大括号
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="nx">doSomething</span><span class="p">();</span>
<span class="c1"># else 大括号换行 十分占篇幅
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="nx">doElseThings</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1"># 此外还有关键字后不带空格，随意缩进等等
</span><span class="c1"># ...
</span></code></pre></div><p>再比如变量函数命名的问题上，各种混搭风格层出不穷：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1"># 全小写
</span><span class="c1"></span><span class="nv">$someparam1</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1"># 首字母下环线
</span><span class="c1"></span><span class="nv">$_some_param_1</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1"># 某些库的类，下划线和大小写混用
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Abstract_ClassA</span>
<span class="p">{</span>

<span class="p">}</span>
</code></pre></div><p>这里并不探讨各种写法的优缺点，只是风格需要保持统一，不要混用。</p>
<h2 id="2-良好的编码习惯">2. 良好的编码习惯</h2>
<p>如果你仔细看过 PSR 的标准，可能也会注意到某些地方其实是标准无法涉及到的。比如一个超长的表达式在什么时候换行，如何缩进等。</p>
<p>这里涉及到的就是编码习惯的约束问题。</p>
<p>比如方法的链式的调用的问题，比如某些数据库查询的封装：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1"># 不换行的情况下句子会很长
</span><span class="c1"></span><span class="nv">$result</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">db</span><span class="o">-&gt;</span><span class="na">select</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">groupBy</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">orderBy</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;DESC&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">result</span><span class="p">();</span>

<span class="c1"># 这种情况下我建议是一个条件一行，保持缩进
</span><span class="c1"></span><span class="nv">$result</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">db</span><span class="o">-&gt;</span><span class="na">select</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">groupBy</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">orderBy</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;DESC&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">result</span><span class="p">();</span>
</code></pre></div><p>还有数组定义，某些数组成员字符串很长的情况下的写法：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;abcdefg&#39;</span><span class="p">,</span> <span class="s1">&#39;acbdfeg&#39;</span><span class="p">,</span> <span class="s1">&#39;bcadgfe&#39;</span><span class="p">,</span> <span class="s1">&#39;cdadgef&#39;</span><span class="p">];</span>

<span class="c1"># 如果成员太长，我建议拆解，这样
</span><span class="c1"></span><span class="nv">$array</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;abcdefg&#39;</span><span class="p">,</span>
    <span class="s1">&#39;acbdfeg&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bcadgfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cdadgef&#39;</span><span class="p">,</span>
<span class="p">];</span>
</code></pre></div><h2 id="3-寻找最优的写法">3. 寻找最优的写法</h2>
<p>写代码的过程中，最优的写法和编码习惯又不是同一件事情。这里要说的指的是如何遵循 PHP 的语言特性或者框架的特征，充分发挥语言和框架的能力来减少冗余。</p>
<p>比如在获取前端传入的参数的时候，很多时候能见到这样的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$param</span> <span class="o">=</span> <span class="nx">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</code></pre></div><p>更有甚者一些框架将前端传入的参数封装了一层，比如 <code>$this-&gt;request-&gt;data['param']</code>，如果再去用 <code>isset</code> 或者 <code>array_key_exists</code> 判断，整个获取参数的语句就会变得很长。</p>
<p>某些情况下使用三元运算符的时候需要注意 <code>?:</code> 是可以<a href="http://0x1.im/blog/php/add-a-operator-to-php7.html">合并使用</a>的。</p>
<p>其实我们应该去尝试封装这种写法，防止同样的变量出现在一个语句中多次的情况。对于默认值的赋予，可以调研框架是否有封装提供，或者通过强制类型转换的方式进行。</p>
<p>还有一种情况是条件和循环嵌套的时候。比如从数组里抽取某一个字段，或者对某一个字段的值进行处理的时候，善用 <code>array_map</code> 以及引用（<code>&amp;</code>）往往能节省不少工作量。但是使用的时候也要注意数组指针最后的位置。</p>
<p>在根据条件返回结果时，需要善用 <code>return</code>。还有就是合理的抽象与封装。</p>
<h2 id="4-review-自己的代码">4. review 自己的代码</h2>
<p>除了以上提到的在日常开发中需要注意的一些问题。还有就是事后的工作。</p>
<p>我相信很多人在看自己以前的代码的时候都有一种其实有更好的写法的感觉。随着时间的推移自己总会有更丰富的阅历，更多的想法。偶尔 review 自己的代码也是对过去的总结，也许会有新的感知。</p>
<h2 id="5-推广给你的队友">5. 推广给你的队友</h2>
<p>团队项目中，队友的配合对整个代码的规范起着决定性的作用。一个团队中有一个人不遵守规范，而又要到处修改代码的时候，很快就能破坏到所有的约束。</p>
<p>有统一的标准，有良好的执行力才能完成这件工作。</p>
]]></content>
        </item>
        
        <item>
            <title>Googbye 2015 &amp; Hello 2016</title>
            <link>http://0x1.im/posts/2015-12-31-hello-2016/</link>
            <pubDate>Thu, 31 Dec 2015 22:43:22 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-12-31-hello-2016/</guid>
            <description>2015 是我的本命年，24，也是毕业后变动最大的一年。这一年我基本上是在整理我的学习思路，尝试找一些不一样的事情做。
相应的，换工作了，twice。我有疑虑过，现在也有，但并不后悔。一路前行，一路感知吧。
担忧与坚持 我在 PHP 上的一些坚持可能会给人一种我很死板的错觉。但事实上我也很喜欢尝鲜，各种语言、框架、新颖的玩物、前后端的东西，不过始终没有深入。现在也仍然特别想继续扩宽自己的知识面，希望在其他层面有一项掌握的不过的。我个人并没有说真正去粉什么东西，只是觉得既然使用一项工具，那就应该把它掌握好，维护它，也是维护自己。
至于 PHP 未来会怎么样，我觉得期望还是好的，即使是未来 Web 应用流量会慢慢减小，移动端已经慢慢成为主流的一部分，但是这并不是说后端就不重要了。也许会越来越多样化吧。再者一门语言往深里去探究学习的就是语言的原理和基础的理论了，在这个基础上去构建其他上层的东西也不会太难。
2015 做过的事 杂事：
 从武汉到深圳，迈出探险的第一步 有了些自己的想法，自己的坚持 下半年开始认真写博客 下半年组了个交流群、目前有 60 个人，氛围还可以  技术：
 PHP 的应用知识体系更完全 PHP 内核代码和执行终于能认证梳理理解一下了 对 PHP 各种框架、组件、标准以及 PHP 有了更加系统的了解和深入  读书：
 《HTTP 权威指南》 《图解 TCP/IP》 《flex 与 bison》 《Modern PHP》 《Objective-c 程序设计》 一些技术文章和博客 一些没有记住的&amp;hellip;  不好的地方：
 Linux 上并没有长进 MySQL 没长进 前端知识结构没长进  2016 的期望  继续构建并完全自己的知识体系 业余时间系统的有计划学习而不是东一点西一点 认证学习理解 C 语言，争取有些算法上的长进 继续深入了解 PHP 内核 争取在应用后端构建与服务器架构体系上有些更先进的认知  Happy New Year!</description>
            <content type="html"><![CDATA[<p>2015 是我的本命年，24，也是毕业后变动最大的一年。这一年我基本上是在整理我的学习思路，尝试找一些不一样的事情做。</p>
<p>相应的，换工作了，twice。我有疑虑过，现在也有，但并不后悔。一路前行，一路感知吧。</p>
<h2 id="担忧与坚持">担忧与坚持</h2>
<p>我在 PHP 上的一些坚持可能会给人一种我很死板的错觉。但事实上我也很喜欢尝鲜，各种语言、框架、新颖的玩物、前后端的东西，不过始终没有深入。现在也仍然特别想继续扩宽自己的知识面，希望在其他层面有一项掌握的不过的。我个人并没有说真正去粉什么东西，只是觉得既然使用一项工具，那就应该把它掌握好，维护它，也是维护自己。</p>
<p>至于 PHP 未来会怎么样，我觉得期望还是好的，即使是未来 Web 应用流量会慢慢减小，移动端已经慢慢成为主流的一部分，但是这并不是说后端就不重要了。也许会越来越多样化吧。再者一门语言往深里去探究学习的就是语言的原理和基础的理论了，在这个基础上去构建其他上层的东西也不会太难。</p>
<h2 id="2015-做过的事">2015 做过的事</h2>
<p>杂事：</p>
<ul>
<li>从武汉到深圳，迈出探险的第一步</li>
<li>有了些自己的想法，自己的坚持</li>
<li>下半年开始认真写博客</li>
<li>下半年组了个交流群、目前有 60 个人，氛围还可以</li>
</ul>
<p>技术：</p>
<ul>
<li>PHP 的应用知识体系更完全</li>
<li>PHP 内核代码和执行终于能认证梳理理解一下了</li>
<li>对 PHP 各种框架、组件、标准以及 PHP 有了更加系统的了解和深入</li>
</ul>
<p>读书：</p>
<ul>
<li>《HTTP 权威指南》</li>
<li>《图解 TCP/IP》</li>
<li>《flex 与 bison》</li>
<li>《Modern PHP》</li>
<li>《Objective-c 程序设计》</li>
<li>一些技术文章和博客</li>
<li>一些没有记住的&hellip;</li>
</ul>
<p>不好的地方：</p>
<ul>
<li>Linux 上并没有长进</li>
<li>MySQL 没长进</li>
<li>前端知识结构没长进</li>
</ul>
<h2 id="2016-的期望">2016 的期望</h2>
<ul>
<li>继续构建并完全自己的知识体系</li>
<li>业余时间系统的有计划学习而不是东一点西一点</li>
<li>认证学习理解 C 语言，争取有些算法上的长进</li>
<li>继续深入了解 PHP 内核</li>
<li>争取在应用后端构建与服务器架构体系上有些更先进的认知</li>
</ul>
<p>Happy New Year! 2016!</p>
]]></content>
        </item>
        
        <item>
            <title>[译]变量在 PHP7 内部的实现（二）</title>
            <link>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</link>
            <pubDate>Sun, 20 Dec 2015 22:54:48 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-12-20-Internal-value-representation-in-PHP-7-part-2/</guid>
            <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
第一部分讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。
复杂的 zval 数据值有一个共同的头，其结构由 zend_refcounted 定义：
struct _zend_refcounted { uint32_t refcount; union { struct { ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) } v; uint32_t type_info; } u; }; 这个头存储有 refcount（引用计数），值的类型 type 和循环回收的相关信息 gc_info 以及类型标志位 flags。
接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。
字符串 PHP7 中定义了一个新的结构体 zend_string 用于存储字符串变量：
struct _zend_string { zend_refcounted gc; zend_ulong h; /* hash value */ size_t len; char val[1]; }; 除了引用计数的头以外，字符串还包含哈希缓存 h，字符串长度 len 以及字符串的值 val。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。</description>
            <content type="html"><![CDATA[<p><em>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的<a href="http://nikic.github.io/">博客</a>。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。</em></p>
<p><em>要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。</em></p>
<p><a href="http://0x1.im/blog/php/Internal-value-representation-in-PHP-7-part-1.html">第一部分</a>讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。</p>
<p>复杂的 zval 数据值有一个共同的头，其结构由 <code>zend_refcounted</code> 定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zend_refcounted</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">refcount</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">ZEND_ENDIAN_LOHI_3</span><span class="p">(</span>
                <span class="n">zend_uchar</span>    <span class="n">type</span><span class="p">,</span>
                <span class="n">zend_uchar</span>    <span class="n">flags</span><span class="p">,</span>
                <span class="n">uint16_t</span>      <span class="n">gc_info</span><span class="p">)</span>
        <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">uint32_t</span> <span class="n">type_info</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>这个头存储有 <code>refcount</code>（引用计数），值的类型 <code>type</code> 和循环回收的相关信息 <code>gc_info</code> 以及类型标志位 <code>flags</code>。</p>
<p>接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。</p>
<h2 id="字符串">字符串</h2>
<p>PHP7 中定义了一个新的结构体 <code>zend_string</code> 用于存储字符串变量：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zend_string</span> <span class="p">{</span>
    <span class="n">zend_refcounted</span>   <span class="n">gc</span><span class="p">;</span>
    <span class="n">zend_ulong</span>        <span class="n">h</span><span class="p">;</span>        <span class="cm">/* hash value */</span>
    <span class="n">size_t</span>            <span class="n">len</span><span class="p">;</span>
    <span class="kt">char</span>              <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div><p>除了引用计数的头以外，字符串还包含哈希缓存 <code>h</code>，字符串长度 <code>len</code> 以及字符串的值 <code>val</code>。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。</p>
<p>如果你对 C 语言了解的不是很深入的话，可能会觉得 <code>val</code> 的定义有些奇怪：这个声明只有一个元素，但是显然我们想存储的字符串长度肯定大于一个字符的长度。这里其实使用的是结构体的一个『黑』方法：在声明数组时只定义一个元素，但是实际创建 <code>zend_string</code> 时再分配足够的内存来存储整个字符串。这样我们还是可以通过 <code>val</code> 访问完整的字符串。</p>
<p>当然这属于非常规的实现手段，因为我们实际的读和写的内容都超过了单字符数组的边界。但是 C 语言编译器却不知道你是这么做的。虽然 C99 也曾明确规定过支持『柔性数组』，但是感谢我们的好朋友微软，没人能在不同的平台上保证 C99 的一致性（所以这种手段是为了解决 Windows 平台下柔性数组的支持问题）。</p>
<p>新的字符串类型的结构比原生的 C 字符串更方便使用：第一是因为直接存储了字符串的长度，这样就不用每次使用时都去计算。第二是字符串也有引用计数的头，这样也就可以在不同的地方共享字符串本身而无需使用 zval。一个经常使用的地方就是共享 hashtable 的 key。</p>
<p>但是新的字符串类型也有一个很不好的地方：虽然可以很方便的从 zend_string 中取出 C 字符串（使用 <code>str-&gt;val</code> 即可），但反过来，如果将 C 字符串变成 zend_string 就需要先分配 zend_string 需要的内存，再将字符串复制到 zend_string 中。这在实际使用的过程中并不是很方便。</p>
<p>字符串也有一些特有的标志（存储在 GC 的标志位中的）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define IS_STR_PERSISTENT           (1&lt;&lt;0) </span><span class="cm">/* allocated using malloc */</span><span class="cp">
</span><span class="cp">#define IS_STR_INTERNED             (1&lt;&lt;1) </span><span class="cm">/* interned string */</span><span class="cp">
</span><span class="cp">#define IS_STR_PERMANENT            (1&lt;&lt;2) </span><span class="cm">/* interned string surviving request boundary */</span><span class="cp">
</span></code></pre></div><p>持久化的字符串需要的内存直接从系统本身分配而不是 zend 内存管理器（ZMM），这样它就可以一直存在而不是只在单次请求中有效。给这种特殊的分配打上标记便于 zval 使用持久化字符串。在 PHP5 中并不是这样处理的，是在使用前复制一份到 ZMM 中。</p>
<p>保留字符（interned strings）有点特殊，它会一直存在直到请求结束时才销毁，所以也就无需进行引用计数。保留字符串也不可重复（duplicate），所以在创建新的保留字符时也会先检查是否有同样字符的已经存在。所有 PHP 源码中不可变的字符串都是保留字符（包括字符串常量、变量名函数名等）。持久化字符串也是请求开始之前已经创建好的保留字符。但普通的保留字符在请求结束后会销毁，持久化字符串却始终存在。</p>
<p>如果使用了 opcache 的话保留字符会被存储在共享内存（SHM）中这样就可以在所有 PHP 进程质检共享。这种情况下持久化字符串也就没有存在的意义了，因为保留字符也是不会被销毁的。</p>
<h2 id="数组">数组</h2>
<p>因为<a href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">之前的文章</a>有讲过新的数组实现，所以这里就不再详细描述了。虽然最近有些变化导致之前的描述不是十分准确了，但是基本的概念还是一致的。</p>
<p>这里要说的是之前的文章中没有提到的数组相关的概念：不可变数组。其本质上和保留字符类似：没有引用计数且在请求结束之前一直存在（也可能在请求结束之后还存在）。</p>
<p>因为某些内存管理方便的原因，不可变数组只会在开启 opcache 时会使用到。我们来看看实际使用的例子，先看以下的脚本：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="nv">$i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span>
<span class="p">}</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nx">memory_get_usage</span><span class="p">());</span>
</code></pre></div><p>开启 opcache 时，以上代码会使用 32MB 的内存，不开启的情况下因为 <code>$array</code> 每个元素都会复制一份 <code>['foo']</code> ，所以需要 390MB。这里会进行完整的复制而不是增加引用计数值的原因是防止 zend 虚拟机操作符执行的时候出现共享内存出错的情况。我希望不使用 opcache 时内存暴增的问题以后能得到改善。</p>
<h2 id="php5-中的对象">PHP5 中的对象</h2>
<p>在了解 PHP7 中的对象实现直线我们先看一下 PHP5 的并且看一下有什么效率上的问题。PHP5 中的 zval 会存储一个 <code>zend_object_value</code> 结构，其定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zend_object_value</span> <span class="p">{</span>
    <span class="n">zend_object_handle</span> <span class="n">handle</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">zend_object_handlers</span> <span class="o">*</span><span class="n">handlers</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zend_object_value</span><span class="p">;</span>
</code></pre></div><p><code>handle</code> 是对象的唯一 ID，可以用于查找对象数据。<code>handles</code> 是保存对象各种属性方法的虚函数表指针。通常情况下 PHP 对象都有着同样的 handler 表，但是 PHP 扩展创建的对象也可以通过操作符重载等方式对其行为自定义。</p>
<p>对象句柄（handler）是作为索引用于『对象存储』，对象存储本身是一个存储容器（bucket）的数组，bucket 定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zend_object_store_bucket</span> <span class="p">{</span>
    <span class="n">zend_bool</span> <span class="n">destructor_called</span><span class="p">;</span>
    <span class="n">zend_bool</span> <span class="n">valid</span><span class="p">;</span>
    <span class="n">zend_uchar</span> <span class="n">apply_count</span><span class="p">;</span>
    <span class="k">union</span> <span class="n">_store_bucket</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">_store_object</span> <span class="p">{</span>
            <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
            <span class="n">zend_objects_store_dtor_t</span> <span class="n">dtor</span><span class="p">;</span>
            <span class="n">zend_objects_free_object_storage_t</span> <span class="n">free_storage</span><span class="p">;</span>
            <span class="n">zend_objects_store_clone_t</span> <span class="n">clone</span><span class="p">;</span>
            <span class="k">const</span> <span class="n">zend_object_handlers</span> <span class="o">*</span><span class="n">handlers</span><span class="p">;</span>
            <span class="n">zend_uint</span> <span class="n">refcount</span><span class="p">;</span>
            <span class="n">gc_root_buffer</span> <span class="o">*</span><span class="n">buffered</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">obj</span><span class="p">;</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">free_list</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">bucket</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zend_object_store_bucket</span><span class="p">;</span>
</code></pre></div><p>这个结构体包含了很多东西。前三个成员只是些普通的元数据（对象的析构函数是否被调用过、bucke 是否被使用过以及对象被递归调用过多少次）。接下来的联合体用于区分 bucket 是处于使用中的状态还是空闲状态。上面的结构中最重要的是 <code>struct _store_object</code> 子结构体：</p>
<p>第一个成员 <code>object</code> 是指向实际对象（也就是对象最终存储的位置）的指针。对象实际并不是直接嵌入到对象存储的 bucket 中的，因为对象不是定长的。对象指针下面是三个用于管理对象销毁、释放与克隆的操作句柄（handler）。这里要注意的是 PHP 销毁和释放对象是不同的步骤，前者在某些情况下有可能会被跳过（不完全释放）。克隆操作实际上几乎几乎不会被用到，因为这里包含的操作不是普通对象本身的一部分，所以（任何时候）他们在每个对象中他们都会被单独复制（duplicate）一份而不是共享。</p>
<p>这些对象存储操作句柄后面是一个普通的对象 <code>handlers</code> 指针。存储这几个数据是因为有时候可能会在 zval 未知的情况下销毁对象（通常情况下这些操作都是针对 zval 进行的）。</p>
<p>bucket 也包含了 <code>refcount</code> 的字段，不过这种行为在 PHP5 中显得有些奇怪，因为 zval 本身已经存储了引用计数。为什么还需要一个多余的计数呢？问题在于虽然通常情况下 zval 的『复制』行为都是简单的增加引用计数即可，但是偶尔也会有深度复制的情况出现，比如创建一个全新的 zval 但是保存同样的 <code>zend_object_value</code>。这种情况下两个不同的 zval 就用到了同一个对象存储的 bucket，所以 bucket 自身也需要进行引用计数。这种『双重计数』的方式是 PHP5 的实现内在的问题。GC 根缓冲区中的 <code>buffered</code> 指针也是由于同样的原因才需要进行完全复制（duplicate）。</p>
<p>现在看看对象存储中指针指向的实际的 <code>object</code> 的结构，通常情况下用户层面的对象定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zend_object</span> <span class="p">{</span>
    <span class="n">zend_class_entry</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
    <span class="n">HashTable</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
    <span class="n">zval</span> <span class="o">**</span><span class="n">properties_table</span><span class="p">;</span>
    <span class="n">HashTable</span> <span class="o">*</span><span class="n">guards</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zend_object</span><span class="p">;</span>
</code></pre></div><p><code>zend_class_entry</code> 指针指向的是对象实现的类原型。接下来的两个元素是使用不同的方式存储对象属性。动态属性（运行时添加的而不是在类中定义的）全部存在 <code>properties</code> 中，不过只是属性名和值的简单匹配。</p>
<p>不过这里有针对已经声明的属性的一个优化：编译期间每个属性都会被指定一个索引并且属性本身是存储在 <code>properties_table</code> 的索引中。属性名称和索引的匹配存储在类原型的 hashtable 中。这样就可以防止每个对象使用的内存超过 hashtable 的上限，并且属性的索引会在运行时有多处缓存。</p>
<p><code>guards</code> 的哈希表是用于实现魔术方法的递归行为的，比如 <code>__get</code>，这里我们不深入讨论。</p>
<p>除了上文提到过的双重计数的问题，这种实现还有一个问题是一个最小的只有一个属性的对象也需要 136 个字节的内存（这还不算 zval 需要的内存）。而且中间存在很多间接访问动作：比如要从对象 zval 中取出一个元素，先需要取出对象存储 bucket，然后是 <code>zend object</code>，然后才能通过指针找到对象属性表和 zval。这样这里至少就有 4 层间接访问（并且实际使用中可能最少需要七层）。</p>
<h2 id="php7-中的对象">PHP7 中的对象</h2>
<p>PHP7 的实现中试图解决上面这些问题，包括去掉双重引用计数、减少内存使用以及间接访问。新的 <code>zend_object</code> 结构体如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zend_object</span> <span class="p">{</span>
    <span class="n">zend_refcounted</span>   <span class="n">gc</span><span class="p">;</span>
    <span class="n">uint32_t</span>          <span class="n">handle</span><span class="p">;</span>
    <span class="n">zend_class_entry</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">zend_object_handlers</span> <span class="o">*</span><span class="n">handlers</span><span class="p">;</span>
    <span class="n">HashTable</span>        <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
    <span class="n">zval</span>              <span class="n">properties_table</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div><p>可以看到现在这个结构体几乎就是一个对象的全部内容了：<code>zend_object_value</code> 已经被替换成一个直接指向对象和对象存储的指针，虽然没有完全移除，但已经是很大的提升了。</p>
<p>除了 PHP7 中惯用的 <code>zend_refcounted</code> 头以外，<code>handle</code> 和 对象的 <code>handlers</code> 现在也被放到了 <code>zend_object</code> 中。这里的 <code>properties_table</code> 同样用到了 C 结构体的小技巧，这样 <code>zend_object</code> 和属性表就会得到一整块内存。当然，现在属性表是直接嵌入到 zval 中的而不是指针。</p>
<p>现在对象结构体中没有了 <code>guards</code> 表，现在如果需要的话这个字段的值会被存储在 <code>properties_table</code> 的第一位中，也就是使用 <code>__get</code> 等方法的时候。不过如果没有使用魔术方法的话，guards 表会被省略。</p>
<p><code>dtor</code>、<code>free_storage</code>  和  <code>clone</code> 三个操作句柄之前是存储在对象操作 bucket 中，现在直接存在 <code>handlers</code> 表中，其结构体定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zend_object_handlers</span> <span class="p">{</span>
    <span class="cm">/* offset of real object header (usually zero) */</span>
    <span class="kt">int</span>                                     <span class="n">offset</span><span class="p">;</span>
    <span class="cm">/* general object functions */</span>
    <span class="n">zend_object_free_obj_t</span>                  <span class="n">free_obj</span><span class="p">;</span>
    <span class="n">zend_object_dtor_obj_t</span>                  <span class="n">dtor_obj</span><span class="p">;</span>
    <span class="n">zend_object_clone_obj_t</span>                 <span class="n">clone_obj</span><span class="p">;</span>
    <span class="cm">/* individual object functions */</span>
    <span class="c1">// ... rest is about the same in PHP 5
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>handler 表的第一个成员是 <code>offset</code>，很显然这不是一个操作句柄。这个 offset 是现在的实现中必须存在的，因为虽然内部的对象总是嵌入到标准的 <code>zend_object</code> 中，但是也总会有添加一些成员进去的需求。在 PHP5 中解决这个问题的方法是添加一些内容到标准的对象后面：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">custom_object</span> <span class="p">{</span>
    <span class="n">zend_object</span> <span class="n">std</span><span class="p">;</span>
    <span class="n">uint32_t</span> <span class="n">something</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>这样如果你可以轻易的将 <code>zend_object*</code> 添加到 <code>struct custom_object*</code> 中。这也是 C 语言中常用的结构体继承的做法。但是在 PHP7 中这种实现会有一个问题：因为 <code>zend_object</code> 在存储属性表时用了结构体 hack 的技巧，<code>zend_object</code> 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中会把自己添加的成员添加到标准对象结构的前面：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">custom_object</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">something</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">zend_object</span> <span class="n">std</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>不过这样也就意味着现在无法直接在 <code>zend_object*</code> 和 <code>struct custom_object*</code> 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 <code>offsetof()</code> 宏就能确定具体的偏移值。</p>
<p>也许你会好奇既然现在已经直接（在 <code>zend_value</code> 中）存储了 <code>zend_object</code> 的指针，那现在就不需要再到对象存储中去查找对象了，为什么 PHP7 的对象者还保留着 <code>handle</code> 字段呢？</p>
<p>这是因为现在对象存储仍然存在，虽然得到了极大的简化，所以保留 handle 仍然是有必要的。现在它只是一个指向对象的指针数组。当对象被创建时，会有一个指针插入到对象存储中并且其索引会保存在 <code>handle</code> 中，当对象被释放时，索引也会被移除。</p>
<p>那么为什么现在还需要对象存储呢？因为在请求结束的阶段会在存在某个节点，在这之后再去执行用户代码并且取指针数据时就不安全了。为了避免这种情况出现 PHP 会在更早的节点上执行所有对象的析构函数并且之后就不再有此类操作，所以就需要一个活跃对象的列表。</p>
<p>并且 handle 对于调试也是很有用的，它让每个对象都有了一个唯一的 ID，这样就很容易区分两个对象是同一个还是只是有相同的内容。虽然 HHVM 没有对象存储的概念，但它也存了对象的 handle。</p>
<p>和 PHP5 相比，现在的实现中只有一个引用计数（zval 自身不计数），并且内存的使用量有了很大的缩减：40 个字节用于基础对象，每个属性需要 16 个字节，并且这还是算了 zval 之后的。间接访问的情况也有了显著的改善，因为现在中间层的结构体要么被去掉了，要么就是直接嵌入的，所以现在读取一个属性只有一层访问而不再是四层。</p>
<h2 id="间接-zval">间接 zval</h2>
<p>到现在我们已经基本提到过了所有正常的 zval 类型，但是也有一对特殊类型用于某些特定的情况的，其中之一就是 PHP7 新添加的 <code>IS_INDIRECT</code>。</p>
<p>间接 zval 指的就是其真正的值是存储在其他地方的。注意这个 <code>IS_REFERENCE</code> 类型是不同的，间接 zval 是直接指向另外一个 zval 而不是像 <code>zend_reference</code> 结构体一样嵌入 zval。</p>
<p>为了理解在什么时候会出现这种情况，我们来看一下 PHP 中变量的实现（实际上对象属性的存储也是一样的情况）。</p>
<p>所有在编译过程中已知的变量都会被指定一个索引并且其值会被存在编译变量（CV）表的相应位置中。但是 PHP 也允许你动态的引用变量，不管是局部变量还是全局变量（比如 <code>$GLOBALS</code>），只要出现这种情况，PHP 就会为脚本或者函数创建一个符号表，这其中包含了变量名和它们的值之间的映射关系。</p>
<p>但是问题在于：怎么样才能实现两个表的同时访问呢？我们需要在 CV 表中能够访问普通变量，也需要能在符号表中访问编译变量。在 PHP5 中 CV 表用了双重指针 <code>zval**</code>，通常这些指针指向中间的 <code>zval*</code> 的表，<code>zval*</code> 最终指向的才是实际的 zval:</p>
<pre><code>+------ CV_ptr_ptr[0]
| +---- CV_ptr_ptr[1]
| | +-- CV_ptr_ptr[2]
| | |
| | +-&gt; CV_ptr[0] --&gt; some zval
| +---&gt; CV_ptr[1] --&gt; some zval
+-----&gt; CV_ptr[2] --&gt; some zval
</code></pre><p>当需要使用符号表时存储 <code>zval*</code> 的中间表其实是没有用到的而 <code>zval**</code> 指针会被更新到 hashtable buckets 的响应位置中。我们假定有 <code>$a</code>、<code>$b</code> 和 <code>$c</code> 三个变量，下面是简单的示意图：</p>
<pre><code>CV_ptr_ptr[0] --&gt; SymbolTable[&quot;a&quot;].pDataPtr --&gt; some zval
CV_ptr_ptr[1] --&gt; SymbolTable[&quot;b&quot;].pDataPtr --&gt; some zval
CV_ptr_ptr[2] --&gt; SymbolTable[&quot;c&quot;].pDataPtr --&gt; some zval
</code></pre><p>但是 PHP7 的用法中已经没有这个问题了，因为 PHP7 中的 hashtable 大小发生变化时 hashtable bucket 就失效了。所以 PHP7 用了一个相反的策略：为了访问 CV 表中存储的变量，符号表中存储 <code>INDIRECT</code> 来指向 CV 表。CV 表在符号表的生命周期内不会重新分配，所以也就不会存在有无效指针的问题了。</p>
<p>所以加入你有一个函数并且在 CV 表中有 <code>$a</code>、<code>$b</code> 和 <code>$c</code>，同时还有一个动态分配的变量 <code>$d</code>，符号表的结构看起来大概就是这个样子：</p>
<pre><code>SymbolTable[&quot;a&quot;].value = INDIRECT --&gt; CV[0] = LONG 42
SymbolTable[&quot;b&quot;].value = INDIRECT --&gt; CV[1] = DOUBLE 42.0
SymbolTable[&quot;c&quot;].value = INDIRECT --&gt; CV[2] = STRING --&gt; zend_string(&quot;42&quot;)
SymbolTable[&quot;d&quot;].value = ARRAY --&gt; zend_array([4, 2])
</code></pre><p>间接 zval 也可以是一个指向 <code>IS_UNDEF</code> 类型 zval 的指针，当 hashtable 没有和它关联的 key 时就会出现这种情况。所以当使用 <code>unset($a)</code> 将 <code>CV[0]</code> 的类型标记为 <code>UNDEF</code> 时就会判定符号表不存在键值为 <code>a</code> 的数据。</p>
<h2 id="常量和-ast">常量和 AST</h2>
<p>还有两个需要说一下的在 PHP5 和 PHP7 中都存在的特殊类型 <code>IS_CONSTANT</code> 和 <code>IS_CONSTANT_AST</code>。要了解他们我们还是先看以下的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">test</span><span class="p">(</span><span class="nv">$a</span> <span class="o">=</span> <span class="nx">ANSWER</span><span class="p">,</span>
              <span class="nv">$b</span> <span class="o">=</span> <span class="nx">ANSWER</span> <span class="o">*</span> <span class="nx">ANSWER</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">define</span><span class="p">(</span><span class="s1">&#39;ANSWER&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nx">test</span><span class="p">());</span> <span class="c1">// int(42 + 42 * 42)·
</span></code></pre></div><p><code>test()</code> 函数的两个参数的默认值都是由常量 <code>ANSWER</code>构成，但是函数声明时常量的值尚未定义。常量的具体值只有通过 <code>define()</code> 定义时才知道。</p>
<p>由于以上问题的存在，参数和属性的默认值、常量以及其他接受『静态表达式』的东西都支持『延时绑定』直到首次使用时。</p>
<p>常量（或者类的静态属性）这些需要『延时绑定』的数据就是最常需要用到 <code>IS_CONSTANT</code> 类型 zval 的地方。如果这个值是表达式，就会使用 <code>IS_CONSTANT_AST</code> 类型的 zval 指向表达式的抽象语法树（AST）。</p>
<p>到这里我们就结束了对 PHP7 中变量实现的分析。后面我可能还会写两篇文章来介绍一些虚拟机优化、新的命名约定以及一些编译器基础结构的优化的内容（这是作者原话）。</p>
<p><em>译者注：两篇文章篇幅较长，翻译中可能有疏漏或不正确的地方，如果发现了请及时指正。</em></p>
]]></content>
        </item>
        
        <item>
            <title>php-cs-fixer (PHP Coding Standards Fixer)</title>
            <link>http://0x1.im/posts/2015-12-18-php-cs-fixer/</link>
            <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-12-18-php-cs-fixer/</guid>
            <description>php-cs-fixer 是个代码格式化工具，格式化的标准是 PSR-1、PSR-2 以及一些 symfony 的标准。这个工具也和 symfony、twig 等优秀的 PHP 库出自同门。
安装与更新 需要使用 PHP 5.3.6 以上的版本。
你可以直接下载封装好的 phar 包：php-cs-fixer.phar；
或者通过 wget 下载（下面的都是 OSX 和 Linux 上的用法）：
wget http://get.sensiolabs.org/php-cs-fixer.phar -O php-cs-fixer 或者通过 curl 下载：
curl http://get.sensiolabs.org/php-cs-fixer.phar -o php-cs-fixer 下载完成后给可执行的权限，然后移动到 bin 目录下面即可：
sudo chmod a+x php-cs-fixer sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer 这样就可以在任何地方直接使用 php-cs-fixer 命令来调用了。
也可以用过 Composer 来安装：
composer global require fabpot/php-cs-fixer 如果你是 Mac 用户、homebrew 用户并且已经 tap 过 homebrew/php 的话，也可以直接：
brew install php-cs-fixer 或者：
brew install homebrew/php/php-cs-fixer 如果后续需要更新的话：</description>
            <content type="html"><![CDATA[<p><a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">php-cs-fixer</a> 是个代码格式化工具，格式化的标准是 PSR-1、PSR-2 以及一些 symfony 的标准。这个工具也和 symfony、twig 等优秀的 PHP 库出自同门。</p>
<h2 id="安装与更新">安装与更新</h2>
<p>需要使用 PHP 5.3.6 以上的版本。</p>
<p>你可以直接下载封装好的 phar 包：<a href="http://get.sensiolabs.org/php-cs-fixer.phar">php-cs-fixer.phar</a>；</p>
<p>或者通过 wget 下载（下面的都是 OSX 和 Linux 上的用法）：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">wget http://get.sensiolabs.org/php-cs-fixer.phar -O php-cs-fixer
</code></pre></div><p>或者通过 curl 下载：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">curl http://get.sensiolabs.org/php-cs-fixer.phar -o php-cs-fixer
</code></pre></div><p>下载完成后给可执行的权限，然后移动到 bin 目录下面即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">sudo chmod a+x php-cs-fixer
sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer
</code></pre></div><p>这样就可以在任何地方直接使用 <code>php-cs-fixer</code> 命令来调用了。</p>
<p>也可以用过 Composer 来安装：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">composer global require fabpot/php-cs-fixer
</code></pre></div><p>如果你是 Mac 用户、homebrew 用户并且已经 tap 过 homebrew/php 的话，也可以直接：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">brew install php-cs-fixer
</code></pre></div><p>或者：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">brew install homebrew/php/php-cs-fixer
</code></pre></div><p>如果后续需要更新的话：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">php-cs-fixer self-update
</code></pre></div><p>如果是通过 homebrew 安装的：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">brew upgrade php-cs-fixer
</code></pre></div><p>如果没有将执行文件放到 bin 目录下或者在 Windows需要使用 <code>php php-cs-fixer.phar</code> 代替 <code>php-cs-fixer</code>。</p>
<h2 id="用法">用法</h2>
<p>用法也很简单，最基本的命令参数就是 <code>fix</code>，直接执行时会尽可能多的根据默认标准格式化代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 格式化目录 如果是当前目录的话可以省略目录</span>
php-cs-fixer fix /path/to/dir
<span class="c1"># 格式化文件</span>
php-cs-fixer.phar fix /path/to/file
</code></pre></div><p><code>--verbose</code> 选项用于展示应用了的规则，默认是文本（<code>txt</code>）格式。</p>
<p><code>--level</code> 选项用于控制需要使用的规则层级：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">php-cs-fixer fix /path/to/project --level<span class="o">=</span>psr0
php-cs-fixer fix /path/to/project --level<span class="o">=</span>psr1
php-cs-fixer fix /path/to/project --level<span class="o">=</span>psr2
php-cs-fixer fix /path/to/project --level<span class="o">=</span>symfony
</code></pre></div><p>默认情况下执行的是 PSR-2 的所有选项以及一些附加选项（主要是 symfony 相关的）。还有一些属于『贡献级别』的选项，你可以通过 <code>--fixers</code> 选择性的添加，<code>--fixers</code> 的多个条件要用逗号分开：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">php-cs-fixer fix /path/to/dir --fixers<span class="o">=</span>linefeed,short_tag,indentation
</code></pre></div><p>如果有需要的话也可以使用 <code>-name_of_fixer</code> 采取黑名单的方式设定禁用哪些选项。如果同时设定了 <code>--fixers</code> 和 <code>-name_of_fixer</code>，前者的优先级更高。</p>
<p>同时使用 <code>--dry-run</code> 和 <code>--diff</code> 命令可以显示出需要修改的汇总，但是并不实际修改。</p>
<p>通过以下方式也可以查看有哪些内容是会修改的，但是并不实际改动文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">cat foo.php <span class="p">|</span> php-cs-fixer fix --diff -
</code></pre></div><h2 id="自定义配置">自定义配置</h2>
<p><code>--config</code> 选项可以用来设置选取目录以及文件进行分析并格式化，但是这个选项只能设置一些常见的已知的项目，比如 symfony：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># For the Symfony 2.3+ branch
</span><span class="cp"></span><span class="n">php</span><span class="o">-</span><span class="n">cs</span><span class="o">-</span><span class="n">fixer</span> <span class="n">fix</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">sf23</span> <span class="o">--</span><span class="n">config</span><span class="o">=</span><span class="n">sf23</span>
</code></pre></div><p>已有选项：</p>
<ul>
<li>default 默认配置</li>
<li>magento magento 项目</li>
<li>sf23 symfony 的项目</li>
</ul>
<p>更多时候，我们可以通过配置文件来自定义格式化选项以及搜索的目录和文件。自定义配置通过在项目根目录添加一个 <code>.php_cs</code> 文件的方式实现。</p>
<p>设置本身就是 PHP 代码，最后返回一个 Symfony\CS\ConfigInterface 的实例即可。你可以设置格式化的选项、级别、文件以及目录。</p>
<p>下面是一个简单的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$finder</span> <span class="o">=</span> <span class="nx">Symfony\CS\Finder\DefaultFinder</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">exclude</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span> <span class="c1">// 忽略 somedir
</span><span class="c1"></span>    <span class="o">-&gt;</span><span class="na">in</span><span class="p">(</span><span class="no">__DIR__</span><span class="p">)</span> <span class="c1">// 当前目录
</span><span class="c1"></span><span class="p">;</span>

<span class="k">return</span> <span class="nx">Symfony\CS\Config\Config</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">fixers</span><span class="p">([</span><span class="s1">&#39;strict_param&#39;</span><span class="p">,</span> <span class="s1">&#39;short_array_syntax&#39;</span><span class="p">])</span> <span class="c1">// 添加两个选项
</span><span class="c1"></span>    <span class="o">-&gt;</span><span class="na">finder</span><span class="p">(</span><span class="nv">$finder</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div><p>如果你想完全自定义格式化选项，就需要将格式化级别清空，并指定好所有需要的选项：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$finder</span> <span class="o">=</span> <span class="nx">Symfony\CS\Finder\DefaultFinder</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">in</span><span class="p">(</span><span class="no">__DIR__</span><span class="p">)</span>
<span class="p">;</span>

<span class="k">return</span> <span class="nx">Symfony\CS\Config\Config</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">level</span><span class="p">(</span><span class="nx">Symfony\CS\FixerInterface</span><span class="o">::</span><span class="na">NONE_LEVEL</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">fixers</span><span class="p">([</span><span class="s1">&#39;trailing_spaces&#39;</span><span class="p">,</span> <span class="s1">&#39;encoding&#39;</span><span class="p">])</span>
    <span class="o">-&gt;</span><span class="na">finder</span><span class="p">(</span><span class="nv">$finder</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div><p>你也可以通过在选项前面添加 <code>-</code> 的方式来禁用某些选项，比如下面这个例子不采用 PSR-0：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="nv">$finder</span> <span class="o">=</span> <span class="nx">Symfony\CS\Finder\DefaultFinder</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">exclude</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">in</span><span class="p">(</span><span class="no">__DIR__</span><span class="p">)</span>
<span class="p">;</span>

<span class="k">return</span> <span class="nx">Symfony\CS\Config\Config</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">fixers</span><span class="p">([</span><span class="s1">&#39;-psr0&#39;</span><span class="p">])</span>
    <span class="o">-&gt;</span><span class="na">finder</span><span class="p">(</span><span class="nv">$finder</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div><p>默认条件下的格式化级别是 symfony (最严格)，你可以修改这个级别：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="k">return</span> <span class="nx">Symfony\CS\Config\Config</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">level</span><span class="p">(</span><span class="nx">Symfony\CS\FixerInterface</span><span class="o">::</span><span class="na">PSR2_LEVEL</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div><p>通过这些设置选项的组合，可以很轻易的定制出自己想要的效果。</p>
<p>你也可以通过 <code>--config-file</code> 选项指定 <code>.php_cs</code> 文件的位置。</p>
<p>启用缓存可以在后续的执行中加快速度，通过以下方法设置：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="k">return</span> <span class="nx">Symfony\CS\Config\Config</span><span class="o">::</span><span class="na">create</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="na">setUsingCache</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">;</span>
</code></pre></div><h2 id="编辑器插件">编辑器插件</h2>
<p>下面这些编辑器/IDE 的插件可以帮你简化格式化的工作：</p>
<ul>
<li><a href="https://github.com/Glavin001/atom-beautify">Atom</a></li>
<li><a href="http://plugins.netbeans.org/plugin/49042/php-cs-fixer">NetBeans</a></li>
<li><a href="http://tzfrs.de/2015/01/automatically-format-code-to-match-psr-standards-with-phpstorm">PhpStorm</a></li>
<li><a href="https://github.com/benmatselby/sublime-phpcs">Sublime Text</a></li>
<li><a href="https://github.com/stephpy/vim-php-cs-fixer">Vim</a></li>
</ul>
<h2 id="格式化选项">格式化选项</h2>
<ul>
<li>
<p><strong>psr0 [PSR-0]</strong></p>
<p>PSR-0 的路径和命名空间标准</p>
</li>
<li>
<p><strong>encoding [PSR-1]</strong></p>
<p>文件必须是不带 BOM 的 UTF-8 编码；</p>
</li>
<li>
<p><strong>short_tag [PSR-1]</strong></p>
<p>只能使用 <code>&lt;?php ?&gt;</code> 和 <code>&lt;?= ?&gt;</code> 两种 PHP 代码标签；</p>
</li>
<li>
<p><strong>braces [PSR-2]</strong></p>
<p>所有语句块都必须包含在花括号内，且位置以及缩进是符合标准的；</p>
</li>
<li>
<p><strong>class_definition [PSR-2]</strong></p>
<p>class、trait、interfaces 关键字和名称之间只能有一个空格；</p>
</li>
<li>
<p><strong>elseif [PSR-2]</strong></p>
<p>使用 <code>elseif</code> 替代 <code>else if</code>；</p>
</li>
<li>
<p><strong>eof_ending [PSR-2]</strong></p>
<p>文件必须以空白行结尾；</p>
</li>
<li>
<p><strong>function_call_space [PSR-2]</strong></p>
<p>调用函数和方法时，函数名和方法名与参数扩展之间不能有空格；</p>
</li>
<li>
<p><strong>function_declaration [PSR-2]</strong></p>
<p>函数声明时空格的使用需要符合 PSR-2；</p>
</li>
<li>
<p><strong>indentation [PSR-2]</strong></p>
<p>代码必须使用四个空格缩进而不是制表符；</p>
</li>
<li>
<p><strong>line_after_namespace [PSR-2]</strong></p>
<p>命名空间的声明后必须有一个空白行；</p>
</li>
<li>
<p><strong>linefeed [PSR-2]</strong></p>
<p>所有 PHP 文件都只能使用 LF(Unix) 结尾；</p>
</li>
<li>
<p><strong>lowercase_constants [PSR-2]</strong></p>
<p>PHP 常量 true、false 和 null 必须使用小写；</p>
</li>
<li>
<p><strong>lowercase_keywords [PSR-2]</strong></p>
<p>PHP 关键字必须都是小写；</p>
</li>
<li>
<p><strong>method_argument_space [PSR-2]</strong></p>
<p>方法声明及调用时，参数之间的逗号前不能有空格，逗号后必须有一个空格；</p>
</li>
<li>
<p><strong>multiple_use [PSR-2]</strong></p>
<p>每个 use 只能声明一个元素；</p>
</li>
<li>
<p><strong>parenthesis [PSR-2]</strong></p>
<p>圆括号内两侧不能有空格；</p>
</li>
<li>
<p><strong>php_closing_tag [PSR-2]</strong></p>
<p>纯 PHP 文件必须省略 <code>?&gt;</code> 标签；</p>
</li>
<li>
<p><strong>single_line_after_imports [PSR-2]</strong></p>
<p>每个 use 声明独立一行，且 use 语句块之后要有一个空白行；</p>
</li>
<li>
<p><strong>trailing_spaces [PSR-2]</strong></p>
<p>删除非空行之后多余的空格；</p>
</li>
<li>
<p><strong>visibility [PSR-2]</strong></p>
<p>每个属性和方法都必须指定作用域是 <code>public</code>、<code>protected</code> 还是 <code>private</code>，<code>abstract</code> 和 <code>final</code> 必须位于作用域关键字之前，<code>static</code> 必须位于作用域之后；</p>
</li>
<li>
<p><strong>array_element_no_space_before_comma [symfony]</strong></p>
<p>数组声明中，逗号之前不能有空格；</p>
</li>
<li>
<p><strong>array_element_white_space_after_comma [symfony]</strong></p>
<p>数组声明中，逗号之后必须有一个人空格；</p>
</li>
<li>
<p><strong>blankline_after_open_tag [symfony]</strong></p>
<p>PHP 开始标签的同一行不能有代码，且下面必须有一个空白行；</p>
</li>
<li>
<p><strong>concat_without_spaces [symfony]</strong></p>
<p>点连接符左右两边不能有多余的空格；</p>
</li>
<li>
<p><strong>double_arrow_multiline_whitespaces [symfony]</strong></p>
<p><code>=&gt;</code> 操作符两端不能有多个空白行；</p>
</li>
<li>
<p><strong>duplicate_semicolon [symfony]</strong></p>
<p>删除重复的分号；</p>
</li>
<li>
<p><strong>empty_return [symfony]</strong></p>
<p>return 语句如果没有任何返回的话直接写 return 即可（不用 return null）；</p>
</li>
<li>
<p><strong>extra_empty_lines [symfony]</strong></p>
<p>删除多余的空白行；</p>
</li>
<li>
<p><strong>function_typehint_space [symfony]</strong></p>
<p>修正函数参数和类型提示之间的缺失的空格问题；</p>
</li>
<li>
<p><strong>include [symfony]</strong></p>
<p><code>include</code> 和文件路径之间需要有一个空格，文件路径不需要用括号括起来；</p>
</li>
<li>
<p><strong>join_function [symfony]</strong></p>
<p>使用 <code>join</code> 替换 <code>implode</code> 函数；</p>
</li>
<li>
<p><strong>list_commas [symfony]</strong></p>
<p>删除 <code>list</code> 语句中多余的逗号；</p>
</li>
<li>
<p><strong>method_argument_default_value [symfony]</strong></p>
<p>函数参数中有默认值的参数不能位于无默认值的参数之前；</p>
</li>
<li>
<p><strong>multiline_array_trailing_comma [symfony]</strong></p>
<p>多行数组最后一个元素应该也有一个逗号；</p>
</li>
<li>
<p><strong>namespace_no_leading_whitespace [symfony]</strong></p>
<p>命名空间前面不应该有空格；</p>
</li>
<li>
<p><strong>new_with_braces [symfony]</strong></p>
<p>使用 new 新建实例时后面都应该带上括号；</p>
</li>
<li>
<p><strong>no_blank_lines_after_class_opening [symfony]</strong></p>
<p>类开始标签后不应该有空白行；</p>
</li>
<li>
<p><strong>no_empty_lines_after_phpdocs [symfony]</strong></p>
<p>PHP 文档块开始开始元素下面不应该有空白行；</p>
</li>
<li>
<p><strong>object_operator [symfony]</strong></p>
<p><code>T_OBJECT_OPERATOR</code> (<code>-&gt;</code>) 两端不应有空格；</p>
</li>
<li>
<p><strong>operators_spaces [symfony]</strong></p>
<p>二进制操作符两端至少有一个空格；</p>
</li>
<li>
<p><strong>phpdoc_indent [symfony]</strong></p>
<p>phpdoc 应该保持缩进；</p>
</li>
<li>
<p><strong>phpdoc_inline_tag [symfony]</strong></p>
<p>修正 phpdoc 内联标签格式，使标签与后续内容始终位于一行；</p>
</li>
<li>
<p><strong>phpdoc_no_access [symfony]</strong></p>
<p><code>@access</code> 不应该出现在 phpdoc 中；</p>
</li>
<li>
<p><strong>phpdoc_no_empty_return [symfony]</strong></p>
<p><code>@return void</code> 和 <code>@return null</code> 不应该出现在 phpdoc 中；</p>
</li>
<li>
<p><strong>phpdoc_no_package [symfony]</strong></p>
<p><code>@package</code> 和 <code>@subpackage</code> 不应该出现在 phpdoc 中；</p>
</li>
<li>
<p><strong>phpdoc_params [symfony]</strong></p>
<p><code>@param</code>, <code>@throws</code>, <code>@return</code>, <code>@var</code>, 和 <code>@type</code> 等 phpdoc 标签都要垂直对齐；</p>
</li>
<li>
<p><strong>phpdoc_scalar [symfony]</strong></p>
<p>phpdoc 标量类型声明时应该使用 <code>int</code> 而不是 <code>integer</code>，<code>bool</code> 而不是 <code>boolean</code>，<code>float</code> 而不是 <code>real</code> 或者 <code>double</code>；</p>
</li>
<li>
<p><strong>phpdoc_separation [symfony]</strong></p>
<p>phpdoc 中注释相同的属性应该放在一起，不同的属性之间应该有一个空白行分割；</p>
</li>
<li>
<p><strong>phpdoc_short_description [symfony]</strong></p>
<p>phpdoc 的简要描述应该以 <code>.</code>、<code>!</code> 或 <code>?</code> 结尾；</p>
</li>
<li>
<p><strong>phpdoc_to_comment [symfony]</strong></p>
<p>文档块应该都是结构化的元素；</p>
</li>
<li>
<p><strong>phpdoc_trim [symfony]</strong></p>
<p>除了文档块最开始的部分和最后的部分，phpdoc 开始和结束都应该是有内容的；</p>
</li>
<li>
<p><strong>phpdoc_type_to_var [symfony]</strong></p>
<p><code>@type</code> 需要使用 <code>@var</code> 代替；</p>
</li>
<li>
<p><strong>phpdoc_types [symfony]</strong></p>
<p>phpdoc 中应该正确使用大小写；</p>
</li>
<li>
<p><strong>phpdoc_var_without_name [symfony]</strong></p>
<p><code>@var</code> 和 <code>@type</code> 注释中不应该包含变量名；</p>
</li>
<li>
<p><strong>pre_increment [symfony]</strong></p>
<p>不应该使用 <code>++i</code> 或 <code>--i</code> 的用法；</p>
</li>
<li>
<p><strong>print_to_echo [symfony]</strong></p>
<p>如果可能的话，使用 <code>echo</code> 代替 <code>print</code> 语句；</p>
</li>
<li>
<p><strong>remove_leading_slash_use [symfony]</strong></p>
<p>删除 <code>use</code> 前的空行；</p>
</li>
<li>
<p><strong>remove_lines_between_uses [symfony]</strong></p>
<p>删除 <code>use</code> 语句块中的空行；</p>
</li>
<li>
<p><strong>return [symfony]</strong></p>
<p><code>return</code> 之前应该有一个空行；</p>
</li>
<li>
<p><strong>self_accessor [symfony]</strong></p>
<p>在当前类中使用 <code>self</code> 代替类名；</p>
</li>
<li>
<p><strong>short_bool_cast [symfony]</strong></p>
<p><code>bool</code> 类型数据前不应该试用两个感叹号；</p>
</li>
<li>
<p><strong>single_array_no_trailing_comma [symfony]</strong></p>
<p>PHP 单行数组最后一个元素后面不应该有空格；</p>
</li>
<li>
<p><strong>single_blank_line_before_namespace [symfony]</strong></p>
<p>命名空间声明前应该有一个空白行；</p>
</li>
<li>
<p><strong>single_quote [symfony]</strong></p>
<p>简单字符串应该使用单引号代替双引号；</p>
</li>
<li>
<p><strong>spaces_after_semicolon [symfony]</strong></p>
<p>修复分号后面的空格；</p>
</li>
<li>
<p><strong>spaces_before_semicolon [symfony]</strong></p>
<p>禁止只有单行空格和分号的写法；</p>
</li>
<li>
<p><strong>spaces_cast [symfony]</strong></p>
<p>变量和修饰符之间应该有一个空格；</p>
</li>
<li>
<p><strong>standardize_not_equal [symfony]</strong></p>
<p>使用 <code>&lt;&gt;</code> 代替 <code>!=</code>；</p>
</li>
<li>
<p><strong>ternary_spaces [symfony]</strong></p>
<p>三元运算符之间的空格标准化；</p>
</li>
<li>
<p><strong>trim_array_spaces [symfony]</strong></p>
<p>数组需要格式化成和函数/方法参数类似，上下没有空白行；</p>
</li>
<li>
<p><strong>unalign_double_arrow [symfony]</strong></p>
<p>不对齐 <code>=&gt;</code>；</p>
</li>
<li>
<p><strong>unalign_equals [symfony]</strong></p>
<p>不对齐等号；</p>
</li>
<li>
<p><strong>unary_operators_spaces [symfony]</strong></p>
<p>一元运算符和运算数需要相邻；</p>
</li>
<li>
<p><strong>unneeded_control_parentheses [symfony]</strong></p>
<p>删除控制结构语句中多余的括号；</p>
</li>
<li>
<p><strong>unused_use [symfony]</strong></p>
<p>删除没有用到的 use 语句；</p>
</li>
<li>
<p><strong>whitespacy_lines [symfony]</strong></p>
<p>删除空白行中多余的空格；</p>
</li>
</ul>
<p>除了以上这些选项以外，还有一些用户贡献的选项，这里就不再一一介绍了。</p>
<p>对于代码风格是否统一，执行什么样的标准，每个人、每个团队可能都有自己的看法。这里只是介绍一下这个工具，至于如何选用，还在于大家自己。如果是开源项目，你也可以试用一下 <a href="https://styleci.io/">StyleCI</a>。</p>
]]></content>
        </item>
        
        <item>
            <title>[译]变量在 PHP7 内部的实现（一）</title>
            <link>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</link>
            <pubDate>Thu, 10 Dec 2015 00:39:46 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-12-10-Internal-value-representation-in-PHP-7-part-1/</guid>
            <description>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。
要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。
由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。
PHP5 中的 zval PHP5 中 zval 结构体定义如下：
typedef struct _zval_struct { zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; } zval; 如上，zval 包含一个 value、一个 type 以及两个 __gc 后缀的字段。value 是个联合体，用于存储不同类型的值：
typedef union _zvalue_value { long lval; // 用于 bool 类型、整型和资源类型  double dval; // 用于浮点类型  struct { // 用于字符串  char *val; int len; } str; HashTable *ht; // 用于数组  zend_object_value obj; // 用于对象  zend_ast *ast; // 用于常量表达式(PHP5.</description>
            <content type="html"><![CDATA[<p><em>本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的<a href="http://nikic.github.io/">博客</a>。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。</em></p>
<p><em>要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。</em></p>
<p>由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。</p>
<h2 id="php5-中的-zval">PHP5 中的 zval</h2>
<p>PHP5 中 zval 结构体定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zval_struct</span> <span class="p">{</span>
    <span class="n">zvalue_value</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">zend_uint</span> <span class="n">refcount__gc</span><span class="p">;</span>
    <span class="n">zend_uchar</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">zend_uchar</span> <span class="n">is_ref__gc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zval</span><span class="p">;</span>
</code></pre></div><p>如上，zval 包含一个 <code>value</code>、一个 <code>type</code> 以及两个 <code>__gc</code> 后缀的字段。<code>value</code> 是个联合体，用于存储不同类型的值：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">union</span> <span class="n">_zvalue_value</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">lval</span><span class="p">;</span>                 <span class="c1">// 用于 bool 类型、整型和资源类型
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">dval</span><span class="p">;</span>               <span class="c1">// 用于浮点类型
</span><span class="c1"></span>    <span class="k">struct</span> <span class="p">{</span>                   <span class="c1">// 用于字符串
</span><span class="c1"></span>        <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">HashTable</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>             <span class="c1">// 用于数组
</span><span class="c1"></span>    <span class="n">zend_object_value</span> <span class="n">obj</span><span class="p">;</span>     <span class="c1">// 用于对象
</span><span class="c1"></span>    <span class="n">zend_ast</span> <span class="o">*</span><span class="n">ast</span><span class="p">;</span>             <span class="c1">// 用于常量表达式(PHP5.6 才有)
</span><span class="c1"></span><span class="p">}</span> <span class="n">zvalue_value</span><span class="p">;</span>
</code></pre></div><p>C 语言联合体的特征是一次只有一个成员是有效的并且分配的内存与需要内存最多的成员匹配（也要考虑内存对齐）。所有成员都存储在内存的同一个位置，根据需要存储不同的值。当你需要 <code>lval</code> 的时候，它存储的是有符号整形，需要 <code>dval</code> 时，会存储双精度浮点数。</p>
<p>需要指出的是是联合体中当前存储的数据类型会记录到 <code>type</code> 字段，用一个整型来标记：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define IS_NULL     0      </span><span class="cm">/* Doesn&#39;t use value */</span><span class="cp">
</span><span class="cp">#define IS_LONG     1      </span><span class="cm">/* Uses lval */</span><span class="cp">
</span><span class="cp">#define IS_DOUBLE   2      </span><span class="cm">/* Uses dval */</span><span class="cp">
</span><span class="cp">#define IS_BOOL     3      </span><span class="cm">/* Uses lval with values 0 and 1 */</span><span class="cp">
</span><span class="cp">#define IS_ARRAY    4      </span><span class="cm">/* Uses ht */</span><span class="cp">
</span><span class="cp">#define IS_OBJECT   5      </span><span class="cm">/* Uses obj */</span><span class="cp">
</span><span class="cp">#define IS_STRING   6      </span><span class="cm">/* Uses str */</span><span class="cp">
</span><span class="cp">#define IS_RESOURCE 7      </span><span class="cm">/* Uses lval, which is the resource ID */</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* Special types used for late-binding of constants */</span>
<span class="cp">#define IS_CONSTANT 8
</span><span class="cp">#define IS_CONSTANT_AST 9
</span></code></pre></div><h2 id="php5-中的引用计数">PHP5 中的引用计数</h2>
<p>在PHP5中，zval 的内存是单独从堆（heap）中分配的（有少数例外情况），PHP 需要知道哪些 zval 是正在使用的，哪些是需要释放的。所以这就需要用到引用计数：zval 中 <code>refcount__gc</code> 的值用于保存 zval 本身被引用的次数，比如 <code>$a = $b = 42</code> 语句中，<code>42</code> 被两个变量引用，所以它的引用计数就是 2。如果引用计数变成 0，就意味着这个变量已经没有用了，内存也就可以释放了。</p>
<p>注意这里提及到的引用计数指的不是 PHP 代码中的引用（使用 <code>&amp;</code>），而是变量的使用次数。后面两者需要同时出现时会使用『PHP 引用』和『引用』来区分两个概念，这里先忽略掉 PHP 的部分。</p>
<p>一个和引用计数紧密相关的概念是『写时复制』：对于多个引用来说，zaval 只有在没有变化的情况下才是共享的，一旦其中一个引用改变 zval 的值，就需要复制（&ldquo;separated&rdquo;）一份 zval，然后修改复制后的 zval。</p>
<p>下面是一个关于『写时复制』和 zval 的销毁的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>   <span class="c1">// $a         -&gt; zval_1(type=IS_LONG, value=42, refcount=1)
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>   <span class="c1">// $a, $b     -&gt; zval_1(type=IS_LONG, value=42, refcount=2)
</span><span class="c1"></span><span class="nv">$c</span> <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span>   <span class="c1">// $a, $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=3)
</span><span class="c1"></span>
<span class="c1">// 下面几行是关于 zval 分离的
</span><span class="c1"></span><span class="nv">$a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=2)
</span><span class="c1"></span>           <span class="c1">// $a     -&gt; zval_2(type=IS_LONG, value=43, refcount=1)
</span><span class="c1"></span>
<span class="nx">unset</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span> <span class="c1">// $c -&gt; zval_1(type=IS_LONG, value=42, refcount=1)
</span><span class="c1"></span>           <span class="c1">// $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)
</span><span class="c1"></span>
<span class="nx">unset</span><span class="p">(</span><span class="nv">$c</span><span class="p">);</span> <span class="c1">// zval_1 is destroyed, because refcount=0
</span><span class="c1"></span>           <span class="c1">// $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)
</span></code></pre></div><p>引用计数有个致命的问题：无法检查并释放<a href="http://derickrethans.nl/circular-references.html">循环引用</a>（使用的内存）。为了解决这问题，PHP 使用了<a href="http://php.net/manual/zh/features.gc.collecting-cycles.php">循环回收</a>的方法。当一个 zval 的计数减一时，就有可能属于循环的一部分，这时将 zval 写入到『根缓冲区』中。当缓冲区满时，潜在的循环会被打上标记并进行回收。</p>
<p>因为要支持循环回收，实际使用的 zval 的结构实际上如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zval_gc_info</span> <span class="p">{</span>
    <span class="n">zval</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">gc_root_buffer</span>       <span class="o">*</span><span class="n">buffered</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">_zval_gc_info</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zval_gc_info</span><span class="p">;</span>
</code></pre></div><p><code>zval_gc_info</code> 结构体中嵌入了一个正常的 zval 结构，同时也增加了两个指针参数，但是共属于同一个联合体 <code>u</code>，所以实际使用中只有一个指针是有用的。<code>buffered</code> 指针用于存储 zval 在根缓冲区的引用地址，所以如果在循环回收执行之前 zval 已经被销毁了，这个字段就可能被移除了。<code>next</code> 在回收销毁值的时候使用，这里不会深入。</p>
<h2 id="修改动机">修改动机</h2>
<p>下面说说关于内存使用上的情况，这里说的都是指在 64 位的系统上。首先，由于 <code>str</code> 和 <code>obj</code> 占用的大小一样， <code>zvalue_value</code> 这个联合体占用 16 个字节（bytes）的内存。整个 <code>zval</code> 结构体占用的内存是 24 个字节（考虑到内存对齐），<code>zval_gc_info</code> 的大小是 32 个字节。综上，在堆（相对于栈）分配给 zval 的内存需要额外的 16 个字节，所以每个 zval 在不同的地方一共需要用到 48 个字节（要理解上面的计算方式需要注意每个指针在 64 位的系统上也需要占用 8 个字节）。</p>
<p>在这点上不管从什么方面去考虑都可以认为 zval 的这种设计效率是很低的。比如 zval 在存储整型的时候本身只需要 8 个字节，即使考虑到需要存一些附加信息以及内存对齐，额外 8 个字节应该也是足够的。</p>
<p>在存储整型时本来确实需要 16 个字节，但是实际上还有 16 个字节用于引用计数、16 个字节用于循环回收。所以说 zval 的内存分配和释放都是消耗很大的操作，我们有必要对其进行优化。</p>
<p>从这个角度思考：一个整型数据真的需要存储引用计数、循环回收的信息并且单独在堆上分配内存吗？答案是当然不，这种处理方式一点都不好。</p>
<p>这里总结一下 PHP5 中 zval 实现方式存在的主要问题：</p>
<ul>
<li>zval 总是单独从堆中分配内存；</li>
<li>zval 总是存储引用计数和循环回收的信息，即使是整型这种可能并不需要此类信息的数据；</li>
<li>在使用对象或者资源时，直接引用会导致两次计数（原因会在下一部分讲）；</li>
<li>某些间接访问需要一个更好的处理方式。比如现在访问存储在变量中的对象间接使用了四个指针（指针链的长度为四）。这个问题也放到下一部分讨论；</li>
<li>直接计数也就意味着数值只能在 zval 之间共享。如果想在 zval 和 hashtable key 之间共享一个字符串就不行（除非 hashtable key 也是 zval）。</li>
</ul>
<h2 id="php7-中的-zval">PHP7 中的 zval</h2>
<p>在 PHP7 中 zval 有了新的实现方式。最基础的变化就是 zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。复杂数据类型（比如字符串、数组和对象）的引用计数由其自身来存储。这种实现方式有以下好处：</p>
<ul>
<li>简单数据类型不需要单独分配内存，也不需要计数；</li>
<li>不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的；</li>
<li>由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间；</li>
<li>间接访问需要的指针数减少了。</li>
</ul>
<p>我们看看现在 zval 结构体的定义（现在在 zend_types.h 文件中）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zval_struct</span> <span class="p">{</span>
	<span class="n">zend_value</span>        <span class="n">value</span><span class="p">;</span>			<span class="cm">/* value */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">ZEND_ENDIAN_LOHI_4</span><span class="p">(</span>
				<span class="n">zend_uchar</span>    <span class="n">type</span><span class="p">,</span>			<span class="cm">/* active type */</span>
				<span class="n">zend_uchar</span>    <span class="n">type_flags</span><span class="p">,</span>
				<span class="n">zend_uchar</span>    <span class="n">const_flags</span><span class="p">,</span>
				<span class="n">zend_uchar</span>    <span class="n">reserved</span><span class="p">)</span>	    <span class="cm">/* call info for EX(This) */</span>
		<span class="p">}</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">uint32_t</span> <span class="n">type_info</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">uint32_t</span>     <span class="n">var_flags</span><span class="p">;</span>
		<span class="n">uint32_t</span>     <span class="n">next</span><span class="p">;</span>                 <span class="cm">/* hash collision chain */</span>
		<span class="n">uint32_t</span>     <span class="n">cache_slot</span><span class="p">;</span>           <span class="cm">/* literal cache slot */</span>
		<span class="n">uint32_t</span>     <span class="n">lineno</span><span class="p">;</span>               <span class="cm">/* line number (for ast nodes) */</span>
		<span class="n">uint32_t</span>     <span class="n">num_args</span><span class="p">;</span>             <span class="cm">/* arguments number for EX(This) */</span>
		<span class="n">uint32_t</span>     <span class="n">fe_pos</span><span class="p">;</span>               <span class="cm">/* foreach position */</span>
		<span class="n">uint32_t</span>     <span class="n">fe_iter_idx</span><span class="p">;</span>          <span class="cm">/* foreach iterator index */</span>
	<span class="p">}</span> <span class="n">u2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>结构体的第一个元素没太大变化，仍然是一个 <code>value</code> 联合体。第二个成员是由一个表示类型信息的整型和一个包含四个字符变量的结构体组成的联合体（可以忽略 <code>ZEND_ENDIAN_LOHI_4</code> 宏，它只是用来解决跨平台大小端问题的）。这个子结构中比较重要的部分是 <code>type</code>（和以前类似）和 <code>type_flags</code>，这个接下来会解释。</p>
<p>上面这个地方也有一点小问题：<code>value</code> 本来应该占 8 个字节，但是由于内存对齐，哪怕只增加一个字节，实际上也是占用 16 个字节（使用一个字节就意味着需要额外的 8 个字节）。但是显然我们并不需要 8 个字节来存储一个 type 字段，所以我们在 <code>u1</code> 的后面增加了了一个名为 <code>u2</code> 的联合体。默认情况下是用不到的，需要使用的时候可以用来存储 4 个字节的数据。这个联合体可以满足不同场景下的需求。</p>
<p>PHP7 中 <code>value</code> 的结构定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">union</span> <span class="n">_zend_value</span> <span class="p">{</span>
	<span class="n">zend_long</span>         <span class="n">lval</span><span class="p">;</span>				<span class="cm">/* long value */</span>
	<span class="kt">double</span>            <span class="n">dval</span><span class="p">;</span>				<span class="cm">/* double value */</span>
	<span class="n">zend_refcounted</span>  <span class="o">*</span><span class="n">counted</span><span class="p">;</span>
	<span class="n">zend_string</span>      <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="n">zend_array</span>       <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
	<span class="n">zend_object</span>      <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="n">zend_resource</span>    <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">zend_reference</span>   <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="n">zend_ast_ref</span>     <span class="o">*</span><span class="n">ast</span><span class="p">;</span>
	<span class="n">zval</span>             <span class="o">*</span><span class="n">zv</span><span class="p">;</span>
	<span class="kt">void</span>             <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">zend_class_entry</span> <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
	<span class="n">zend_function</span>    <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">uint32_t</span> <span class="n">w1</span><span class="p">;</span>
		<span class="n">uint32_t</span> <span class="n">w2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ww</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zend_value</span><span class="p">;</span>
</code></pre></div><p>首先需要注意的是现在 value 联合体需要的内存是 8 个字节而不是 16。它只会直接存储整型（<code>lval</code>）或者浮点型（<code>dval</code>）数据，其他情况下都是指针（上面提到过，指针占用 8 个字节，最下面的结构体由两个 4 字节的无符号整型组成）。上面所有的指针类型（除了特殊标记的）都有一个同样的头（<code>zend_refcounted</code>）用来存储引用计数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_zend_refcounted_h</span> <span class="p">{</span>
	<span class="n">uint32_t</span>         <span class="n">refcount</span><span class="p">;</span>			<span class="cm">/* reference counter 32-bit */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">ZEND_ENDIAN_LOHI_3</span><span class="p">(</span>
				<span class="n">zend_uchar</span>    <span class="n">type</span><span class="p">,</span>
				<span class="n">zend_uchar</span>    <span class="n">flags</span><span class="p">,</span>    <span class="cm">/* used for strings &amp; objects */</span>
				<span class="n">uint16_t</span>      <span class="n">gc_info</span><span class="p">)</span>  <span class="cm">/* keeps GC root number (or 0) and color */</span>
		<span class="p">}</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">uint32_t</span> <span class="n">type_info</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zend_refcounted_h</span><span class="p">;</span>
</code></pre></div><p>现在，这个结构体肯定会包含一个存储引用计数的字段。除此之外还有 <code>type</code>、<code>flags</code> 和 <code>gc_info</code>。<code>type</code> 存储的和 zval 中的 type 相同的内容，这样 GC 在不存储 zval 的情况下单独使用引用计数。<code>flags</code> 在不同的数据类型中有不同的用途，这个放到下一部分讲。</p>
<p><code>gc_info</code> 和 PHP5 中的 <code>buffered</code> 作用相同，不过不再是位于根缓冲区的指针，而是一个索引数字。因为以前根缓冲区的大小是固定的（10000 个元素），所以使用一个 16 位（2 字节）的数字代替 64 位（8 字节）的指针足够了。<code>gc_info</code> 中同样包含一个『颜色』位用于回收时标记结点。</p>
<h2 id="zval-内存管理">zval 内存管理</h2>
<p>上文提到过 zval 需要的内存不再单独从堆上分配。但是显然总要有地方来存储它，所以会存在哪里呢？实际上大多时候它还是位于堆中（所以前文中提到的地方重点不是<code>堆</code>，而是<code>单独分配</code>），只不过是嵌入到其他的数据结构中的，比如 hashtable 和 bucket 现在就会直接有一个 zval 字段而不是指针。所以函数表编译变量和对象属性在存储时会是一个 zval 数组并得到一整块内存而不是散落在各处的 zval 指针。之前的 <code>zval *</code> 现在都变成了 <code>zval</code>。</p>
<p>之前当 zval 在一个新的地方使用时会复制一份 <code>zval *</code> 并增加一次引用计数。现在就直接复制 zval 的值（忽略 <code>u2</code>），某些情况下<em>可能</em>会增加其结构指针指向的引用计数（如果在进行计数）。</p>
<p>那么 PHP 怎么知道 zval 是否正在计数呢？不是所有的数据类型都能知道，因为有些类型（比如字符串或数组）并不是总需要进行引用计数。所以 <code>type_info</code> 字段就是用来记录 zval 是否在进行计数的，这个字段的值有以下几种情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define IS_TYPE_CONSTANT            (1&lt;&lt;0)   </span><span class="cm">/* special */</span><span class="cp">
</span><span class="cp">#define IS_TYPE_IMMUTABLE           (1&lt;&lt;1)   </span><span class="cm">/* special */</span><span class="cp">
</span><span class="cp">#define IS_TYPE_REFCOUNTED          (1&lt;&lt;2)
</span><span class="cp">#define IS_TYPE_COLLECTABLE         (1&lt;&lt;3)
</span><span class="cp">#define IS_TYPE_COPYABLE            (1&lt;&lt;4)
</span><span class="cp">#define IS_TYPE_SYMBOLTABLE         (1&lt;&lt;5)   </span><span class="cm">/* special */</span><span class="cp">
</span></code></pre></div><p><em>注：在 7.0.0 的正式版本中，上面这一段宏定义的注释这几个宏是供 <code>zval.u1.v.type_flags</code> 使用的。这应该是注释的错误，因为这个上述字段是 <code>zend_uchar</code> 类型。</em></p>
<p><code>type_info</code> 的三个主要的属性就是『可计数』（refcounted）、『可回收』（collectable）和『可复制』（copyable）。计数的问题上面已经提过了。『可回收』用于标记 zval 是否参与循环，不如字符串通常是可计数的，但是你却没办法给字符串制造一个循环引用的情况。</p>
<p>是否可复制用于表示在复制时是否需要在复制时制造（原文用的 &ldquo;duplication&rdquo; 来表述，用中文表达出来可能不是很好理解）一份一模一样的实体。&ldquo;duplication&rdquo; 属于深度复制，比如在复制数组时，不仅仅是简单增加数组的引用计数，而是制造一份全新值一样的数组。但是某些类型（比如对象和资源）即使 &ldquo;duplication&rdquo; 也只能是增加引用计数，这种就属于不可复制的类型。这也和对象和资源现有的语义匹配（现有，PHP7 也是这样，不单是 PHP5）。</p>
<p>下面的表格上标明了不同的类型会使用哪些标记（<code>x</code> 标记的都是有的特性）。『简单类型』（simple types）指的是整型或布尔类型这些不使用指针指向一个结构体的类型。下表中也有『不可变』（immutable）的标记，它用来标记不可变数组的，这个在下一部分再详述。</p>
<p><em>interned string（保留字符）在这之前没有提过，其实就是函数名、变量名等无需计数、不可重复的字符串。</em></p>
<pre><code>                | refcounted | collectable | copyable | immutable
----------------+------------+-------------+----------+----------
simple types    |            |             |          |
string          |      x     |             |     x    |
interned string |            |             |          |
array           |      x     |      x      |     x    |
immutable array |            |             |          |     x
object          |      x     |      x      |          |
resource        |      x     |             |          |
reference       |      x     |             |          |
</code></pre><p>要理解这一点，我们可以来看几个例子，这样可以更好的认识 zval 内存管理是怎么工作的。</p>
<p>下面是整数行为模式，在上文中 PHP5 的例子的基础上进行了一些简化 ：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>   <span class="c1">// $a = zval_1(type=IS_LONG, value=42)
</span><span class="c1"></span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>   <span class="c1">// $a = zval_1(type=IS_LONG, value=42)
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_LONG, value=42)
</span><span class="c1"></span>
<span class="nv">$a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// $a = zval_1(type=IS_LONG, value=43)
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_LONG, value=42)
</span><span class="c1"></span>
<span class="nx">unset</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span> <span class="c1">// $a = zval_1(type=IS_UNDEF)
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_LONG, value=42)
</span></code></pre></div><p>这个过程其实挺简单的。现在整数不再是共享的，变量直接就会分离成两个单独的 zval，由于现在 zval 是内嵌的所以也不需要单独分配内存，所以这里的注释中使用 <code>=</code> 来表示的而不是指针符号 <code>-&gt;</code>，unset 时变量会被标记为 <code>IS_UNDEF</code>。下面看一下更复杂的情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span>   <span class="c1">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])
</span><span class="c1"></span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>   <span class="c1">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[])
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_ARRAY) ---^
</span><span class="c1"></span>
<span class="c1">// zval 分离在这里进行
</span><span class="c1"></span><span class="nv">$a</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1, value=[1])
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])
</span><span class="c1"></span>
<span class="nx">unset</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span> <span class="c1">// $a = zval_1(type=IS_UNDEF),   zend_array_2 被销毁
</span><span class="c1"></span>           <span class="c1">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])
</span></code></pre></div><p>这种情况下每个变量变量有一个单独的 zval，但是是指向同一个（有引用计数） <code>zend_array</code> 的结构体。修改其中一个数组的值时才会进行复制。这点和 PHP5 的情况类似。</p>
<h2 id="类型types">类型（Types）</h2>
<p>我们大概看一下 PHP7 支持哪些类型（zval 使用的类型标记）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* regular data types */</span>
<span class="cp">#define IS_UNDEF					0
</span><span class="cp">#define IS_NULL						1
</span><span class="cp">#define IS_FALSE					2
</span><span class="cp">#define IS_TRUE						3
</span><span class="cp">#define IS_LONG						4
</span><span class="cp">#define IS_DOUBLE					5
</span><span class="cp">#define IS_STRING					6
</span><span class="cp">#define IS_ARRAY					7
</span><span class="cp">#define IS_OBJECT					8
</span><span class="cp">#define IS_RESOURCE					9
</span><span class="cp">#define IS_REFERENCE				10
</span><span class="cp"></span>
<span class="cm">/* constant expressions */</span>
<span class="cp">#define IS_CONSTANT					11
</span><span class="cp">#define IS_CONSTANT_AST				12
</span><span class="cp"></span>
<span class="cm">/* internal types */</span>
<span class="cp">#define IS_INDIRECT					15
</span><span class="cp">#define IS_PTR						17
</span></code></pre></div><p>这个列表和 PHP5 使用的类似，不过增加了几项：</p>
<ul>
<li><code>IS_UNDEF</code> 用来标记之前为 <code>NULL</code> 的 zval 指针（和 <code>IS_NULL</code> 并不冲突）。比如在上面的例子中使用 <code>unset</code> 注销变量；</li>
<li><code>IS_BOOL</code> 现在分割成了 <code>IS_FALSE</code> 和 <code>IS_TRUE</code> 两项。现在布尔类型的标记是直接记录到 type 中，这么做可以优化类型检查。不过这个变化对用户是透明的，还是只有一个『布尔』类型的数据（PHP 脚本中）。</li>
<li>PHP 引用不再使用 <code>is_ref</code> 来标记，而是使用 <code>IS_REFERENCE</code> 类型。这个也要放到下一部分讲；</li>
<li><code>IS_INDIRECT</code>  和  <code>IS_PTR</code> 是特殊的内部标记。</li>
</ul>
<p><em>实际上上面的列表中应该还存在两个 fake types，这里忽略了。</em></p>
<p><code>IS_LONG</code> 类型表示的是一个 <code>zend_long</code> 的值，而不是原生的 C 语言的 long 类型。原因是 Windows 的 64 位系统（LLP64）上的 <code>long</code> 类型只有 32 位的位深度。所以 PHP5 在 Windows 上只能使用 32 位的数字。PHP7 允许你在 64 位的操作系统上使用 64 位的数字，即使是在 Windows 上面也可以。</p>
<p><code>zend_refcounted</code> 的内容会在下一部分讲。下面看看 PHP 引用的实现。</p>
<h2 id="引用">引用</h2>
<p>PHP7 使用了和 PHP5 中完全不同的方法来处理 PHP <code>&amp;</code> 符号引用的问题（这个改动也是 PHP7 开发过程中大量 bug 的根源）。我们先从 PHP5 中 PHP 引用的实现方式说起。</p>
<p>通常情况下， 写时复制原则意味着当你修改一个 zval 之前需要对其进行分离来保证始终修改的只是某一个 PHP 变量的值。这就是传值调用的含义。</p>
<p>但是使用 PHP 引用时这条规则就不适用了。如果一个 PHP 变量是 PHP 引用，就意味着你<em>想要</em>在将多个 PHP 变量指向同一个值。PHP5 中的 <code>is_ref</code> 标记就是用来注明一个 PHP 变量是不是 PHP 引用，在修改时需不需要进行分离的。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// $a     -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=&amp;</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[])
</span><span class="c1"></span>
<span class="nv">$b</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1])
</span><span class="c1"></span>          <span class="c1">// 因为 is_ref 的值是 1, 所以 PHP 不会对 zval 进行分离
</span></code></pre></div><p>但是这个设计的一个很大的问题在于它无法在一个 PHP 引用变量和 PHP 非引用变量之间共享同一个值。比如下面这种情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// $a         -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>  <span class="c1">// $a, $b     -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span><span class="nv">$c</span> <span class="o">=</span> <span class="nv">$b</span>   <span class="c1">// $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span>
<span class="nv">$d</span> <span class="o">=&amp;</span> <span class="nv">$c</span><span class="p">;</span> <span class="c1">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span>          <span class="c1">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[])
</span><span class="c1"></span>          <span class="c1">// $d 是 $c 的引用, 但却不是 $a 的 $b, 所以这里 zval 还是需要进行复制
</span><span class="c1"></span>          <span class="c1">// 这样我们就有了两个 zval, 一个 is_ref 的值是 0, 一个 is_ref 的值是 1.
</span><span class="c1"></span>
<span class="nv">$d</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])
</span><span class="c1"></span>          <span class="c1">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1])
</span><span class="c1"></span>          <span class="c1">// 因为有两个分离了的 zval, $d[] = 1 的语句就不会修改 $a 和 $b 的值.
</span></code></pre></div><p>这种行为方式也导致在 PHP 中使用引用比普通的值要慢。比如下面这个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$array</span> <span class="o">=</span> <span class="nx">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>
<span class="nv">$ref</span> <span class="o">=&amp;</span> <span class="nv">$array</span><span class="p">;</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nx">count</span><span class="p">(</span><span class="nv">$array</span><span class="p">));</span> <span class="c1">// &lt;-- 这里会进行分离
</span></code></pre></div><p>因为 <code>count()</code> 只接受传值调用，但是 <code>$array</code> 是一个 PHP 引用，所以 <code>count()</code> 在执行之前实际上会有一个对数组进行完整的复制的过程。如果 <code>$array</code> 不是引用，这种情况就不会发生了。</p>
<p>现在我们来看看 PHP7 中 PHP 引用的实现。因为 zval 不再单独分配内存，也就没办法再使用和 PHP5 中相同的实现了。所以增加了一个 <code>IS_REFERENCE</code> 类型，并且专门使用 <code>zend_reference</code> 来存储引用值：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">_zend_reference</span> <span class="p">{</span>
    <span class="n">zend_refcounted</span>   <span class="n">gc</span><span class="p">;</span>
    <span class="n">zval</span>              <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>本质上 <code>zend_reference</code> 只是增加了引用计数的 zval。所有引用变量都会存储一个 zval 指针并且被标记为 <code>IS_REFERENCE</code>。<code>val</code> 和其他的 zval 的行为一样，尤其是它也可以在共享其所存储的复杂变量的指针，比如数组可以在引用变量和值变量之间共享。</p>
<p>我们还是看例子，这次是 PHP7 中的语义。为了简洁明了这里不再单独写出 zval，只展示它们指向的结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// $a                                     -&gt; zend_array_1(refcount=1, value=[])
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=&amp;</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[])
</span><span class="c1"></span>
<span class="nv">$b</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1])
</span></code></pre></div><p>上面的例子中进行引用传递时会创建一个 <code>zend_reference</code>，注意它的引用计数是 2（因为有两个变量在使用这个 PHP 引用）。但是值本身的引用计数是 1（因为 <code>zend_reference</code> 只是有一个指针指向它）。下面看看引用和非引用混合的情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[];</span>  <span class="c1">// $a         -&gt; zend_array_1(refcount=1, value=[])
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>  <span class="c1">// $a, $b,    -&gt; zend_array_1(refcount=2, value=[])
</span><span class="c1"></span><span class="nv">$c</span> <span class="o">=</span> <span class="nv">$b</span>   <span class="c1">// $a, $b, $c -&gt; zend_array_1(refcount=3, value=[])
</span><span class="c1"></span>
<span class="nv">$d</span> <span class="o">=&amp;</span> <span class="nv">$c</span><span class="p">;</span> <span class="c1">// $a, $b                                 -&gt; zend_array_1(refcount=3, value=[])
</span><span class="c1"></span>          <span class="c1">// $c, $d -&gt; zend_reference_1(refcount=2) ---^
</span><span class="c1"></span>          <span class="c1">// 注意所有变量共享同一个 zend_array, 即使有的是 PHP 引用有的不是
</span><span class="c1"></span>
<span class="nv">$d</span><span class="p">[]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// $a, $b                                 -&gt; zend_array_1(refcount=2, value=[])
</span><span class="c1"></span>          <span class="c1">// $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1])
</span><span class="c1"></span>          <span class="c1">// 只有在这时进行赋值的时候才会对 zend_array 进行赋值
</span></code></pre></div><p>这里和 PHP5 最大的不同就是所有的变量都可以共享同一个数组，即使有的是 PHP 引用有的不是。只有当其中某一部分被修改的时候才会对数组进行分离。这也意味着使用 <code>count()</code> 时即使给其传递一个很大的引用数组也是安全的，不会再进行复制。不过引用仍然会比普通的数值慢，因为存在需要为 <code>zend_reference</code> 结构体分配内存（间接）并且引擎本身处理这一块儿也不快的的原因。</p>
<h2 id="结语">结语</h2>
<p>总结一下 PHP7 中最重要的改变就是 zval 不再单独从堆上分配内存并且不自己存储引用计数。需要使用 zval 指针的复杂类型（比如字符串、数组和对象）会自己存储引用计数。这样就可以有更少的内存分配操作、更少的间接指针使用以及更少的内存分配。</p>
<p>文章的第二部分我们会讨论复杂类型的问题。</p>
]]></content>
        </item>
        
        <item>
            <title>PHP7 的抽象语法树（AST）带来的变化</title>
            <link>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</link>
            <pubDate>Fri, 20 Nov 2015 12:58:25 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-11-20-changes-of-php7-because-of-ast/</guid>
            <description>本文大部分内容参照 AST 的 RFC 文档而成：https://wiki.php.net/rfc/abstract_syntax_tree，为了易于理解从源文档中节选部分进行介绍。
本文并不会告诉你抽象语法树是什么，这需要你自己去了解，这里只是描述 AST 给 PHP 带来的一些变化。
新的执行过程 PHP7 的内核中有一个重要的变化是加入了 AST。在 PHP5中，从 php 脚本到 opcodes 的执行的过程是：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，在此阶段生成 op arrays。  PHP7 中在语法分析阶段不再直接生成 op arrays，而是先生成 AST，所以过程多了一步：
 Lexing：词法扫描分析，将源文件转换成 token 流； Parsing：语法分析，从 token 流生成抽象语法树； Compilation：从抽象语法树生成 op arrays。  执行时间和内存消耗 从以上的步骤来看，这比之前的过程还多了一步，所以按常理来说这反而会增加程序的执行时间和内存的使用。但事实上内存的使用确实增加了，但是执行时间上却有所降低。
以下结果是使用小（代码大约 100 行）、中（大约 700 行）、大（大约 2800 行）三个脚本分别进行测试得到的，测试脚本： https://gist.github.com/nikic/289b0c7538b46c2220bc.
每个文件编译 100 次的执行时间（注意文章的测试结果时间是 14 年，PHP7 还叫 PHP-NG 的时候）：
    php-ng php-ast diff     SMALL 0.</description>
            <content type="html"><![CDATA[<p><em>本文大部分内容参照 AST 的 RFC 文档而成：<a href="https://wiki.php.net/rfc/abstract_syntax_tree">https://wiki.php.net/rfc/abstract_syntax_tree</a>，为了易于理解从源文档中节选部分进行介绍。</em></p>
<p><em>本文并不会告诉你抽象语法树是什么，这需要你自己去了解，这里只是描述 AST 给 PHP 带来的一些变化。</em></p>
<h2 id="新的执行过程">新的执行过程</h2>
<p>PHP7 的内核中有一个重要的变化是加入了 AST。在 PHP5中，从 php 脚本到 opcodes 的执行的过程是：</p>
<ol>
<li>Lexing：词法扫描分析，将源文件转换成 token 流；</li>
<li>Parsing：语法分析，在此阶段生成 op arrays。</li>
</ol>
<p>PHP7 中在语法分析阶段不再直接生成 op arrays，而是先生成 AST，所以过程多了一步：</p>
<ol>
<li>Lexing：词法扫描分析，将源文件转换成 token 流；</li>
<li>Parsing：语法分析，从 token 流生成抽象语法树；</li>
<li>Compilation：从抽象语法树生成 op arrays。</li>
</ol>
<h2 id="执行时间和内存消耗">执行时间和内存消耗</h2>
<p>从以上的步骤来看，这比之前的过程还多了一步，所以按常理来说这反而会增加程序的执行时间和内存的使用。但事实上内存的使用确实增加了，但是执行时间上却有所降低。</p>
<p>以下结果是使用小（代码大约 100 行）、中（大约 700 行）、大（大约 2800 行）三个脚本分别进行测试得到的，测试脚本： <a href="https://gist.github.com/nikic/289b0c7538b46c2220bc">https://gist.github.com/nikic/289b0c7538b46c2220bc</a>.</p>
<p>每个文件编译 100 次的执行时间（注意文章的测试结果时间是 14 年，PHP7 还叫 PHP-NG 的时候）：</p>
<table>
<thead>
<tr>
<th></th>
<th>php-ng</th>
<th>php-ast</th>
<th>diff</th>
</tr>
</thead>
<tbody>
<tr>
<td>SMALL</td>
<td>0.180s</td>
<td>0.160s</td>
<td>-12.5%</td>
</tr>
<tr>
<td>MEDIUM</td>
<td>1.492s</td>
<td>1.268s</td>
<td>-17.7%</td>
</tr>
<tr>
<td>LARGE</td>
<td>6.703s</td>
<td>5.736s</td>
<td>-16.9%</td>
</tr>
</tbody>
</table>
<p>单次编译中的内存峰值：</p>
<table>
<thead>
<tr>
<th></th>
<th>php-ng</th>
<th>php-ast</th>
<th>diff</th>
</tr>
</thead>
<tbody>
<tr>
<td>SMALL</td>
<td>378kB</td>
<td>414kB</td>
<td>+9.5%</td>
</tr>
<tr>
<td>MEDIUM</td>
<td>507kB</td>
<td>643kB</td>
<td>+26.8%</td>
</tr>
<tr>
<td>LARGE</td>
<td>1084kB</td>
<td>1857kB</td>
<td>+71.3%</td>
</tr>
</tbody>
</table>
<p>单次编译的测试结果可能并不能代表实际使用的情况，以下是使用 <a href="https://github.com/nikic/PHP-Parser/tree/master/lib/PhpParser">PhpParser</a> 进行完整项目测试得到的结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>php-ng</th>
<th>php-ast</th>
<th>diff</th>
</tr>
</thead>
<tbody>
<tr>
<td>TIME</td>
<td>25.5ms</td>
<td>22.8ms</td>
<td>-11.8%</td>
</tr>
<tr>
<td>MEMORY</td>
<td>2360kB</td>
<td>2482kB</td>
<td>+5.1%</td>
</tr>
</tbody>
</table>
<p>测试表明，使用 AST 之后程序的执行时间整体上大概有 10% 到 15% 的提升，但是内存消耗也有增加，在大文件单次编译中增加明显，但是在整个项目执行过程中并不是很严重的问题。</p>
<p>还有注意的是以上的结果都是在没有 Opcache 的情况下，生产环境中打开 Opcache 的情况下，内存的消耗增加也不是很大的问题。</p>
<h2 id="语义上的改变">语义上的改变</h2>
<p>如果仅仅是时间上的优化，似乎也不是使用 AST 的充足理由。其实实现 AST 并不是基于时间优化上的考虑，而是为了解决语法上的问题。下面来看一下语义上的一些变化。</p>
<h4 id="yield-不需要括号">yield 不需要括号</h4>
<p>在 PHP5 的实现中，如果在一个表达式上下文（例如在一个赋值表达式的右侧）中使用 yield，你必须在 yield 申明两边使用括号：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">fn</span><span class="p">();</span>   <span class="c1">// 不合法的
</span><span class="c1"></span><span class="nv">$result</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="nx">fn</span><span class="p">());</span> <span class="c1">// 合法的
</span></code></pre></div><p>这种行为仅仅是因为 PHP5 的实现方式的限制，在 PHP7 中，括号不再是必须的了。所以下面这些写法也都是合法的：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="k">yield</span><span class="p">;</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nv">$v</span><span class="p">;</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nv">$k</span> <span class="o">=&gt;</span> <span class="nv">$v</span><span class="p">;</span>
</code></pre></div><p>当然了，还得遵循 yield 的应用场景才行。</p>
<h4 id="括号不影响行为">括号不影响行为</h4>
<p>在 PHP5 中，<code>($foo)['bar'] = 'baz'</code> 和 <code>$foo['bar'] = 'baz'</code> 两个语句的含义不一样。事实上前一种写法是不合法的，你会得到下面这样的错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="p">(</span><span class="nv">$foo</span><span class="p">)[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;baz&#39;</span><span class="p">;</span>
<span class="c1"># PHP Parse error: Syntax error, unexpected &#39;[&#39; on line 1
</span></code></pre></div><p>但是在 PHP7 中，两种写法表示同样的意思。</p>
<p>同样，如果函数的参数被括号包裹，类型检查存在问题，在 PHP7 中这个问题也得到了解决：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="k">function</span> <span class="nf">byRef</span><span class="p">(</span><span class="k">array</span> <span class="o">&amp;</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="nx">byRef</span><span class="p">((</span><span class="nx">func</span><span class="p">()));</span>
</code></pre></div><p>以上代码在 PHP5 中不会告警，除非使用 <code>byRef(func())</code> 的方式调用，但是在 PHP7 中，不管 <code>func()</code> 两边有没有括号都会产生以下错误：</p>
<pre><code>PHP Strict standards:  Only variables should be passed by reference ...
</code></pre><h4 id="list-的变化">list() 的变化</h4>
<p>list 关键字的行为改变了很多。list 给变量赋值的顺序（等号左右同时的顺序）以前是从右至左，现在是从左到右：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$array</span><span class="p">[],</span> <span class="nv">$array</span><span class="p">[],</span> <span class="nv">$array</span><span class="p">[])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nv">$array</span><span class="p">);</span>

<span class="c1">// PHP5: $array = [3, 2, 1]
</span><span class="c1">// PHP7: $array = [1, 2, 3]
</span><span class="c1"></span>
<span class="c1"># 注意这里的左右的顺序指的是等号左右同时的顺序，
</span><span class="c1"># list($a, $b) = [1, 2] 这种使用中 $a == 1, $b == 2 是没有疑问的。
</span></code></pre></div><p>产生上面变化的原因正是因为在 PHP5 的赋值过程中，<code>3</code> 会最先被填入数组，<code>1</code> 最后，但是现在顺序改变了。</p>
<p>同样的变化还有：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>

<span class="c1">// PHP5: $a = 1, $b = 2
</span><span class="c1">// PHP7: $a = 1, $b = null + &#34;Undefined index 1&#34;
</span></code></pre></div><p>这是因为在以前的赋值过程中 <code>$b</code> 先得到 <code>2</code>，然后 <code>$a</code> 的值才变成 <code>1</code>，但是现在 <code>$a</code> 先变成了 <code>1</code>，不再是数组，所以 <code>$b</code> 就成了 <code>null</code>。</p>
<p>list 现在只会访问每个偏移量一次：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">(</span><span class="k">list</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">))</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">;</span>

<span class="c1">// PHP5:
</span><span class="c1"></span><span class="nv">$b</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// PHP7:
</span><span class="c1">// 会产生一个中间变量，得到 $array[0] 的值
</span><span class="c1"></span><span class="nv">$_tmp</span> <span class="o">=</span> <span class="nv">$array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nv">$_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div><p>空的 list 成员现在是全部禁止的，以前只是在某些情况下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">list</span><span class="p">()</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>           <span class="c1">// 不合法
</span><span class="c1"></span><span class="k">list</span><span class="p">(</span><span class="nv">$b</span><span class="p">,</span> <span class="k">list</span><span class="p">())</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1">// 不合法
</span><span class="c1"></span><span class="k">foreach</span> <span class="p">(</span><span class="nv">$a</span> <span class="k">as</span> <span class="k">list</span><span class="p">())</span> <span class="c1">// 不合法 (PHP5 中也不合法)
</span></code></pre></div><h4 id="引用赋值的顺序">引用赋值的顺序</h4>
<p>引用赋值的顺序在 PHP5 中是从右到左的，现在时从左到右：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$obj</span> <span class="o">=</span> <span class="k">new</span> <span class="k">stdClass</span><span class="p">;</span>
<span class="nv">$obj</span><span class="o">-&gt;</span><span class="na">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$obj</span><span class="o">-&gt;</span><span class="na">b</span><span class="p">;</span>
<span class="nv">$obj</span><span class="o">-&gt;</span><span class="na">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">var_dump</span><span class="p">(</span><span class="nv">$obj</span><span class="p">);</span>

<span class="c1">// PHP5:
</span><span class="c1"></span><span class="nx">object</span><span class="p">(</span><span class="k">stdClass</span><span class="p">)</span><span class="c1">#1 (2) {
</span><span class="c1"></span>  <span class="p">[</span><span class="s2">&#34;b&#34;</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">&amp;</span><span class="nx">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">[</span><span class="s2">&#34;a&#34;</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">&amp;</span><span class="nx">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PHP7:
</span><span class="c1"></span><span class="nx">object</span><span class="p">(</span><span class="k">stdClass</span><span class="p">)</span><span class="c1">#1 (2) {
</span><span class="c1"></span>  <span class="p">[</span><span class="s2">&#34;a&#34;</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">&amp;</span><span class="nx">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">[</span><span class="s2">&#34;b&#34;</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">&amp;</span><span class="nx">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="__clone-方法可以直接调用">__clone 方法可以直接调用</h4>
<p>现在可以直接使用 <code>$obj-&gt;__clone()</code> 的写法去调用 <code>__clone</code> 方法。<code>__clone</code> 是之前唯一一个被禁止直接调用的魔术方法，之前你会得到一个这样的错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-s" data-lang="s"><span class="n">Fatal</span> <span class="n">error</span><span class="o">:</span> <span class="n">Cannot</span> <span class="n">call</span> <span class="nf">__clone</span><span class="p">()</span> <span class="n">method</span> <span class="n">on</span> <span class="n">objects</span> <span class="o">-</span> <span class="n">use</span> <span class="s">&#39;clone $obj&#39;</span> <span class="n">instead</span> <span class="n">in</span> <span class="kc">...</span>
</code></pre></div><h2 id="变量语法一致性">变量语法一致性</h2>
<p>AST 也解决了一些语法一致性的问题，这些问题是在另外一个 RFC 中被提出的：<a href="https://wiki.php.net/rfc/uniform_variable_syntax">https://wiki.php.net/rfc/uniform_variable_syntax</a>.</p>
<p>在新的实现上，以前的一些语法表达的含义和现在有些不同，具体的可以参照下面的表格：</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>PHP5</th>
<th>PHP7</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$foo[&lsquo;bar&rsquo;][&lsquo;baz&rsquo;]</td>
<td>${$foo[&lsquo;bar&rsquo;][&lsquo;baz&rsquo;]}</td>
<td>($$foo)[&lsquo;bar&rsquo;][&lsquo;baz&rsquo;]</td>
</tr>
<tr>
<td>$foo-&gt;$bar[&lsquo;baz&rsquo;]</td>
<td>$foo-&gt;{$bar[&lsquo;baz&rsquo;]}</td>
<td>($foo-&gt;$bar)[&lsquo;baz&rsquo;]</td>
</tr>
<tr>
<td>$foo-&gt;$bar[&lsquo;baz&rsquo;]()</td>
<td>$foo-&gt;{$bar[&lsquo;baz&rsquo;]}()</td>
<td>($foo-&gt;$bar)[&lsquo;baz&rsquo;]()</td>
</tr>
<tr>
<td>Foo::$bar[&lsquo;baz&rsquo;]()</td>
<td>Foo::{$bar[&lsquo;baz&rsquo;]}()</td>
<td>(Foo::$bar)[&lsquo;baz&rsquo;]()</td>
</tr>
</tbody>
</table>
<p>整体上还是以前的顺序是从右到左，现在从左到右，同时也遵循括号不影响行为的原则。这些复杂的变量写法是在实际开发中需要注意的。</p>
]]></content>
        </item>
        
        <item>
            <title>两行代码给 PHP7 添加一个“非空合并”语法糖</title>
            <link>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</link>
            <pubDate>Sun, 08 Nov 2015 18:22:26 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-11-08-add-a-operator-to-php7/</guid>
            <description>我们知道从 PHP 5.3 起三元运算符 ? : 有一个写法简洁写法是这样的：
&amp;lt;?php $a = 0; $b = $a ?: 1; # $b === 1 这实际上相当于：
&amp;lt;?php $a = 0; $b = $a ? $a : 1; # $b === 1 在 PHP5 中，语法分析是这样写的：
| expr &amp;#39;?&amp;#39; { zend_do_begin_qm_op(&amp;amp;$1, &amp;amp;$2 TSRMLS_CC); } expr &amp;#39;:&amp;#39; { zend_do_qm_true(&amp;amp;$4, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } expr { zend_do_qm_false(&amp;amp;$$, &amp;amp;$7, &amp;amp;$2, &amp;amp;$5 TSRMLS_CC); } | expr &amp;#39;?&amp;#39; &amp;#39;:&amp;#39; { zend_do_jmp_set(&amp;amp;$1, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } expr { zend_do_jmp_set_else(&amp;amp;$$, &amp;amp;$5, &amp;amp;$2, &amp;amp;$3 TSRMLS_CC); } 在 PHP7 中，由于 AST（抽象语法树）的引入，语法分析有些简化：</description>
            <content type="html"><![CDATA[<p>我们知道从 PHP 5.3 起三元运算符 <code>?  :</code> 有一个写法简洁写法是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># $b === 1
</span></code></pre></div><p>这实际上相当于：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">?</span> <span class="nv">$a</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># $b === 1
</span></code></pre></div><p>在 PHP5 中，语法分析是这样写的：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="o">|</span>   <span class="n">expr</span> <span class="sc">&#39;?&#39;</span> <span class="p">{</span> <span class="n">zend_do_begin_qm_op</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">expr</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span> <span class="n">zend_do_qm_true</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">5</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">expr</span>     <span class="p">{</span> <span class="n">zend_do_qm_false</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$$</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">7</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">5</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
<span class="o">|</span>   <span class="n">expr</span> <span class="sc">&#39;?&#39;</span> <span class="sc">&#39;:&#39;</span> <span class="p">{</span> <span class="n">zend_do_jmp_set</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">3</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">expr</span>     <span class="p">{</span> <span class="n">zend_do_jmp_set_else</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$$</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mi">3</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>在 PHP7 中，由于 AST（抽象语法树）的引入，语法分析有些简化：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="o">|</span>   <span class="n">expr</span> <span class="sc">&#39;?&#39;</span> <span class="n">expr</span> <span class="sc">&#39;:&#39;</span> <span class="n">expr</span>
        <span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="n">zend_ast_create</span><span class="p">(</span><span class="n">ZEND_AST_CONDITIONAL</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">,</span> <span class="err">$</span><span class="mi">5</span><span class="p">);</span> <span class="p">}</span>
<span class="o">|</span>   <span class="n">expr</span> <span class="sc">&#39;?&#39;</span> <span class="sc">&#39;:&#39;</span> <span class="n">expr</span>
        <span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="n">zend_ast_create</span><span class="p">(</span><span class="n">ZEND_AST_CONDITIONAL</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>PHP7 中语法分析之后都是写到 AST 的节点上。从上面可以看出，简化的 <code>?:</code> 和完整的三元表达式的区别就是节点中间的值为 NULL。</p>
<p>PHP7 添加了一个合并操作符（T_COALESCE），用于简化 <code>isset</code> 的条件判断：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">??</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>它相当于：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nx">isset</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="o">?</span> <span class="nv">$a</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>仅仅是 <code>isset</code> 判断，在 $a 为 0 等值时还是会返回 $b 的值还是为 0 。</p>
<p>这个操作符的语法分析语句是：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="o">|</span>   <span class="n">expr</span> <span class="n">T_COALESCE</span> <span class="n">expr</span>
        <span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="n">zend_ast_create</span><span class="p">(</span><span class="n">ZEND_AST_COALESCE</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>如果想将 <code>isset</code> 换成 <code>empty</code> 的效果，也就是说在变量不存在或转换成 boolean  后为 <code>false</code> 都赋予其他值，需要这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">??</span> <span class="mi">1</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>显然上面的表达式中中间一部分稍微有些多余，那么做些简化呢？</p>
<p>现在我想添加一个语法 <code>??:</code> ，它的作用是对变量做 <code>empty</code> 的判断。也就是说达到上面 <code>$a ?? 1 ?: 1</code> 的效果：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">??:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>改起来很简单，只需要将 <code>?:</code> 和 <code>??</code> 的分析合并一下（注意这里和上面所有的地方 <code>$1</code> <code>$2</code> 等符号的数字表示的都是变量或者常量出现的位置顺序）：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="o">|</span>   <span class="n">expr</span> <span class="n">T_COALESCE</span> <span class="sc">&#39;:&#39;</span> <span class="n">expr</span>
        <span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="n">zend_ast_create</span><span class="p">(</span><span class="n">ZEND_AST_CONDITIONAL</span><span class="p">,</span>
            <span class="n">zend_ast_create</span><span class="p">(</span><span class="n">ZEND_AST_COALESCE</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>仅仅只有两句，因为并没有在词法分析器中添加 Token，所以只能算是个语法糖。</p>
<p>重新编译一下之后就能看到效果啦。测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ /usr/local/php/bin/php -r <span class="s2">&#34;\$a = 0; echo \$a ?? 1, PHP_EOL;&#34;</span>
<span class="m">0</span>
$ /usr/local/php/bin/php -r <span class="s2">&#34;\$a = 0; echo \$a ??: 1, PHP_EOL;&#34;</span>
<span class="m">1</span>
</code></pre></div><p>Enjoy IT!</p>
]]></content>
        </item>
        
        <item>
            <title>max/min 函数（PHP）的一个小 BUG</title>
            <link>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</link>
            <pubDate>Sat, 07 Nov 2015 13:30:22 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-11-07-bug-of-php-function-max/</guid>
            <description>先直接来看一段展示：
# Psy Shell v0.3.3 (PHP 5.5.30 — cli) by Justin Hileman &amp;gt;&amp;gt;&amp;gt; ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max(-0.0, 0) =&amp;gt; 0.0 &amp;gt;&amp;gt;&amp;gt; max(ceil(-0.5), 0) =&amp;gt; -0.0 上面的演示中，ceil 函数返回的是 -0.0，max 在将 ceil 函数调用的结果作为参数传入的时候，返回的也是一个 -0.0。
如果给 ceil 的结果赋值给变量，还是能得到 -0.0 的结果：
&amp;gt;&amp;gt;&amp;gt; $a = ceil(-0.5) =&amp;gt; -0.0 &amp;gt;&amp;gt;&amp;gt; max($a, 0) =&amp;gt; -0.0 下面就来一一分析是哪些原因导致了这些结果的产生。
ceil 会返回 -0.0 首先我们来看一下为什么 ceil 函数会返回 -0.0。
ceil 函数的实现在 $PHP-SRC/ext/stardands/math.c （$PHP-SRC 指的是 PHP 解释器源码根目录）中，为了展示清楚我去掉了一些细节：
PHP_FUNCTION(ceil) { ... if (Z_TYPE_PP(value) == IS_DOUBLE) { RETURN_DOUBLE(ceil(Z_DVAL_PP(value))); } else if (Z_TYPE_PP(value) == IS_LONG) { convert_to_double_ex(value); RETURN_DOUBLE(Z_DVAL_PP(value)); } .</description>
            <content type="html"><![CDATA[<p>先直接来看一段展示：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Psy Shell v0.3.3 (PHP 5.5.30 — cli) by Justin Hileman</span>
&gt;&gt;&gt; ceil<span class="o">(</span>-0.5<span class="o">)</span>
<span class="o">=</span>&gt; -0.0
&gt;&gt;&gt; max<span class="o">(</span>-0.0, 0<span class="o">)</span>
<span class="o">=</span>&gt; 0.0
&gt;&gt;&gt; max<span class="o">(</span>ceil<span class="o">(</span>-0.5<span class="o">)</span>, 0<span class="o">)</span>
<span class="o">=</span>&gt; -0.0
</code></pre></div><p>上面的演示中，<code>ceil</code> 函数返回的是 <code>-0.0</code>，<code>max</code> 在将 <code>ceil</code> 函数调用的结果作为参数传入的时候，返回的也是一个 <code>-0.0</code>。</p>
<p>如果给 ceil 的结果赋值给变量，还是能得到 <code>-0.0</code> 的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">&gt;&gt;&gt; <span class="nv">$a</span> <span class="o">=</span> ceil<span class="o">(</span>-0.5<span class="o">)</span>
<span class="o">=</span>&gt; -0.0
&gt;&gt;&gt; max<span class="o">(</span><span class="nv">$a</span>, 0<span class="o">)</span>
<span class="o">=</span>&gt; -0.0
</code></pre></div><p>下面就来一一分析是哪些原因导致了这些结果的产生。</p>
<h2 id="ceil-会返回--00">ceil 会返回 -0.0</h2>
<p>首先我们来看一下为什么 <code>ceil</code> 函数会返回 <code>-0.0</code>。</p>
<p>ceil 函数的实现在 $PHP-SRC/ext/stardands/math.c （$PHP-SRC 指的是 PHP 解释器源码根目录）中，为了展示清楚我去掉了一些细节：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PHP_FUNCTION</span><span class="p">(</span><span class="n">ceil</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Z_TYPE_PP</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">IS_DOUBLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">RETURN_DOUBLE</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">Z_DVAL_PP</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Z_TYPE_PP</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">IS_LONG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">convert_to_double_ex</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
		<span class="n">RETURN_DOUBLE</span><span class="p">(</span><span class="n">Z_DVAL_PP</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div><p>从这里可以看出来 ceil 函数做了两个事情：</p>
<ol>
<li>如果参数类型是 double，则直接调用 C 语言的 ceil 函数并返回执行结果；</li>
<li>如果参数类型是 long，则转换成 double 然后直接返回。</li>
</ol>
<p>所以 ceil 返回 -0.0 这个本身的原因还在于 C。写个函数测试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ceil</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>以上代码在我机器上的执行结果是 <code>-0.000000</code>。至于为什么会是这个结果，这是 C 语言的问题，这里也不细说，有兴趣的可以看这里：<a href="http://www.wikiwand.com/zh/-0">http://www.wikiwand.com/zh/-0</a>。</p>
<h2 id="不能直接传入--00">不能直接传入 -0.0</h2>
<p>接下来讨论一下为什么执行 <code>max(-0.0, 0)</code> 却得不到相同的结果。</p>
<p>用 <a href="https://github.com/derickr/vld">vld</a> 扩展查看了一下只有以上一行代码的 php 文件看一下结果：</p>
<pre><code>line     #* E I O op                    fetch      ext  return  operands
--------------------------------------------------------------------------
   3     0  E &gt;   EXT_STMT
         1        EXT_FCALL_BEGIN
         2        SEND_VAL                                      0
         3        SEND_VAL                                      0
         4        DO_FCALL                           2          'max'
         5        EXT_FCALL_END
   5     6      &gt; RETURN                                        1
</code></pre><p>注意到需要为 2 的 <a href="http://php.net/manual/en/internals2.opcodes.send-val.php">SEND_VAL</a>  操作，送进去的值是 0。也就说在词法分析阶段之后 <code>-0.0</code> 就被转换成 0 了。如何转换的呢？下面我们简单的分析一下的过程。</p>
<p>PHP 的词法分析器由 <a href="http://re2c.org/">re2c</a> 生成，语法分析器则是由 <a href="https://www.gnu.org/software/bison/">Bison</a> 生成。在 zend_language_scanner.l （$PHP-SRC/Zend 目录下）中我们可以找到以下的语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">LNUM</span>	<span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>
<span class="n">DNUM</span>	<span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span><span class="s">&#34;.&#34;</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="p">)</span><span class="o">|</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span><span class="p">)</span>
<span class="n">EXPONENT_DNUM</span>	<span class="p">(({</span><span class="n">LNUM</span><span class="p">}</span><span class="o">|</span><span class="p">{</span><span class="n">DNUM</span><span class="p">})[</span><span class="n">eE</span><span class="p">][</span><span class="o">+-</span><span class="p">]</span><span class="o">?</span><span class="p">{</span><span class="n">LNUM</span><span class="p">})</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="o">&lt;</span><span class="n">ST_IN_SCRIPTING</span><span class="o">&gt;</span><span class="p">{</span><span class="n">DNUM</span><span class="p">}</span><span class="o">|</span><span class="p">{</span><span class="n">EXPONENT_DNUM</span><span class="p">}</span> <span class="p">{</span>
	<span class="n">zendlval</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">dval</span> <span class="o">=</span> <span class="n">zend_strtod</span><span class="p">(</span><span class="n">yytext</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">zendlval</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">IS_DOUBLE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">T_DNUMBER</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>LNUM</code> 和 <code>DNUM</code> 后面都是简单的正则表达式。虽然在词法扫描中 <code>0.0</code> 会被标记成 DNUM，并且位于 zend_strtod.c 的 <code>zend_strtod</code> 函数中的也有对于 加减号的处理，但是 <code>-</code> 符号并不和 DNUM 匹配（那既然这样为什么 <code>zend_strtod</code> 还要处理加减号呢？因为这个函数不只是在这里使用的）。这里最终返回一个 <code>T_DNUMBER</code> 的标记。</p>
<p>再看 zend_language_parser.y 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">common_scalar</span><span class="p">:</span>
		<span class="n">T_LNUMBER</span> 					<span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="n">T_DNUMBER</span> 					<span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
	<span class="p">...</span>
<span class="p">;</span>

<span class="nl">static_scalar</span><span class="p">:</span> <span class="cm">/* compile-time evaluated scalars */</span>
		<span class="n">common_scalar</span>		<span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
	<span class="p">...</span>
	<span class="o">|</span>	<span class="sc">&#39;+&#39;</span> <span class="n">static_scalar</span> <span class="p">{</span> <span class="n">ZVAL_LONG</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mf">1.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">add_function</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mf">2.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mf">1.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mf">2.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="sc">&#39;-&#39;</span> <span class="n">static_scalar</span> <span class="p">{</span> <span class="n">ZVAL_LONG</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mf">1.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">sub_function</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mf">2.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mf">1.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">,</span> <span class="o">&amp;</span><span class="err">$</span><span class="mf">2.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">...</span>
<span class="p">;</span>
</code></pre></div><p>同样我们去掉了一些细节，简单描述一下上面的语法分析的处理流程：</p>
<ol>
<li><code>T_DNUMBER</code> 是一个 common_scalar 语句；</li>
<li>common_scalar  是一个 static_scalar 语句；</li>
<li>static_scalar 语句前面存在减号时，将操作数 1 （op1）设定为 值为 0 的 <code>ZVAL_LONG</code> ，然后调用 <code>sub_function</code>  函数处理两个操作数。</li>
</ol>
<p><code>sub_function</code> 函数的实现位于 zend_operators.c 中，所做的操作很简单，就是用 op1 的值减去 op2 的值，所以就不会存在传入 <code>-0.0</code> 的情况。</p>
<h2 id="直接调用或赋值给变量">直接调用或赋值给变量</h2>
<p>既然如此，为什么直接使用函数调用做参数或者赋值给变量的方式又可以传入呢？闲来看一下 zend_language_parser.y 中对于函数参数的分析语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">function_call_parameter_list</span><span class="p">:</span>
		<span class="sc">&#39;(&#39;</span> <span class="sc">&#39;)&#39;</span>	<span class="p">{</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="sc">&#39;(&#39;</span> <span class="n">non_empty_function_call_parameter_list</span> <span class="sc">&#39;)&#39;</span>	<span class="p">{</span> <span class="err">$$</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="sc">&#39;(&#39;</span> <span class="n">yield_expr</span> <span class="sc">&#39;)&#39;</span>	<span class="p">{</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">zend_do_pass_param</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="n">ZEND_SEND_VAL</span><span class="p">,</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
<span class="p">;</span>

<span class="nl">non_empty_function_call_parameter_list</span><span class="p">:</span>
		<span class="n">expr_without_variable</span>	<span class="p">{</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">zend_do_pass_param</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="n">ZEND_SEND_VAL</span><span class="p">,</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="n">variable</span>				<span class="p">{</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">zend_do_pass_param</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="n">ZEND_SEND_VAR</span><span class="p">,</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
	<span class="o">|</span>	<span class="sc">&#39;&amp;&#39;</span> <span class="n">w_variable</span> 				<span class="p">{</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">zend_do_pass_param</span><span class="p">(</span><span class="o">&amp;</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="n">ZEND_SEND_REF</span><span class="p">,</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="err">$$</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">constant</span><span class="p">)</span> <span class="n">TSRMLS_CC</span><span class="p">);</span> <span class="p">}</span>
<span class="p">...</span>
<span class="p">;</span>
</code></pre></div><p>为了直观 <code>non_empty_function_call_parameter_list</code> 语句块后面我隐去了三行。后面三行的处理逻辑实际上是递归调用，并不影响我们分析。</p>
<p>通过 <code>function_call_parameter_list</code> 可以看出函数的参数基本情况包括三种：</p>
<ol>
<li>没有参数</li>
<li>有参数列表</li>
<li>有 yield 表达式</li>
</ol>
<p>这里我们只需要关注有参数列表的情况，参数列表中的每个参数也分三种情况：</p>
<ol>
<li>不包含变量的表达式</li>
<li>变量</li>
<li>引用变量</li>
</ol>
<p>上文中我们提到的直接传入 <code>-0.0</code> 时对应的是第一种情况，传入赋值后的 <code>$a</code> 对应的是第二种情况。参数最终都会交给 <code>zend_do_pass_param</code> 函数（zend_compile.c）去处理。</p>
<p>那么传入 <code>ceil(-0.5)</code> 作为参数呢？实际上也是对应第二种情况，这个问题单独分析起来也比较复杂，省事儿一点我们直接用 vld 看一下执行 <code>max(ceil(-0.5), 0)</code>过程：</p>
<pre><code>line     #* E I O op                   fetch       ext  return  operands
--------------------------------------------------------------------------
   5     0  E &gt;   EXT_STMT
         1        EXT_FCALL_BEGIN
         2        EXT_FCALL_BEGIN
         3        SEND_VAL                                      -0.5
         4        DO_FCALL                           1  $0      'ceil'
         5        EXT_FCALL_END
         6        SEND_VAR_NO_REF                    6          $0
         7        SEND_VAL                                      0
         8        DO_FCALL                           2          'max'
         9        EXT_FCALL_END
   6    10      &gt; RETURN                                        1
</code></pre><p>序号为 4 的语句中，ceil 的执行结果是赋值给一个 $0 的变量，而在序号为 6 的执行中，执行的是 <code>SEND_VAR_NO_REF</code> 的语句，调用的 $0。<code>SEND_VAR_NO_REF</code> 的 Opcode 是在何时被指定的呢？也是在 <code>zend_do_pass_param</code> 函数中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">ZEND_SEND_VAR</span> <span class="o">&amp;&amp;</span> <span class="n">zend_is_function_or_method_call</span><span class="p">(</span><span class="n">param</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* Method call */</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">ZEND_SEND_VAR_NO_REF</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><p>函数执行过程中使用 <code>zend_parse_parameters</code> 函数（zend_API.c）来获取参数。从参数的存储到获取中间还有很多处理过程，这里不再一一详解。但是需要知道一件事：函数在使用变量作为参数的时候是直接从已经存储的变量列表中读取的，没有经过过滤处理，所以变量 <code>$a</code> 或 <code>ceil(-0.5)</code> 才可以直接将 <code>-0.0</code> 传递给 <code>max</code> 函数使用。</p>
<h2 id="最后的原因">最后的原因</h2>
<p>既然以上都知道了，那还剩一个问题：为什么在 <code>-0.0</code> 和 <code>0</code> 中 <code>max</code> 函数会选择前者？</p>
<p>其实这个问题很简单，看一下 <code>max</code> 函数的实现（$PHP-SRC/ext/standard/array.c）就知道真的就是在两值相等时选择了前者：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">max</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">is_smaller_or_equal_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">max</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Z_LVAL</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>同样，<code>min</code> 函数也存在这个问题，区别就是 <code>min</code> 函数是调用的 <code>is_smaller_function</code> 来比较两个数值，两个值相等的时候返回前者。</p>
<p>所以要解决这个问题也很简单，只需要调换一下参数顺序即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Psy Shell v0.3.3 (PHP 5.5.30 — cli) by Justin Hileman</span>
&gt;&gt;&gt; max<span class="o">(</span>0, ceil<span class="o">(</span>-0.5<span class="o">))</span>
<span class="o">=</span>&gt; <span class="m">0</span>
</code></pre></div><h2 id="后话">后话</h2>
<p>本文仅仅是管中窥豹，从一个小 “bug” 入口简单的梳理一下各个环节的处理过程，如果想要更深入的理解 PHP 的执行过程，还需要大量的精力和知识储备。</p>
<p>分析 PHP 源码的执行过程不仅是为了对 PHP 有更深刻的理解，也能帮助我们了解一门语言从代码到执行结果中间的各个环节和实现。</p>
<p>关于词法分析器与语法分析器，这里讲的并不多，希望后面有机会的话能够再深入探讨。re2c 的规则比较简单，关于 Bison，则有很多相关的书籍。</p>
<p>文中有粗浅的疏解，也留下有问题，如有错误，欢迎指正。</p>
<p>Stay foolish,stay humble; Keep questioning,keep learning.</p>
]]></content>
        </item>
        
        <item>
            <title>如何编写一个独立的 PHP 扩展（译）</title>
            <link>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</link>
            <pubDate>Wed, 04 Nov 2015 23:43:58 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-11-04-how-to-create-a-php-extension/</guid>
            <description>本文翻译自 PHP 源码中的 README.SELF-CONTAINED-EXTENSIONS。文中标记了 注 的内容均为自己添加。内容有点老，也挺啰嗦，没讲什么深入的内容，但是可以作为入门学习参考。
独立的 PHP 扩展可以独立于 PHP 源码之外进行分发。要创建一个这样的扩展，需要准备好两样东西：
 配置文件 (config.m4) 你的模块源码  接下来我们来描述一下如果创建这些文件并组合起来。
准备好系统工具 想要扩展能够在系统上编译并成功运行，需要准备转以下工具：
 GNU autoconf GNU automake GNU libtool GNU m4  以上这些都可以从 ftp://ftp.gnu.org/pub/gnu/ 获取。
注：以上这些都是类 Unix 环境下才能使用的工具。
改装一个已经存在的扩展 为了显示出创建一个独立的扩展是很容易的事情，我们先将一个已经内嵌到 PHP 的扩展改成独立扩展。安装 PHP 并且执行以下命令：
$ mkdir /tmp/newext $ cd /tmp/newext 现在你已经有了一个空目录。我们将 mysql 扩展目录下的文件复制过来：
$ cp -rp php-4.0.X/ext/mysql/* . # 注：看来这篇 README 真的需要更新一下了 # PHP7 中已经移除了 mysql 扩展部分 到这里扩展就完成了，执行：
$ phpize 现在你可以独立存放这个目录下的文件到任何地方，这个扩展可以完全独立存在了。
用户在编译时需要使用以下命令：
$ .</description>
            <content type="html"><![CDATA[<p><em>本文翻译自 PHP 源码中的 README.SELF-CONTAINED-EXTENSIONS。文中标记了 <code>注</code> 的内容均为自己添加。内容有点老，也挺啰嗦，没讲什么深入的内容，但是可以作为入门学习参考。</em></p>
<p>独立的 PHP 扩展可以独立于 PHP 源码之外进行分发。要创建一个这样的扩展，需要准备好两样东西：</p>
<ul>
<li>配置文件 (config.m4)</li>
<li>你的模块源码</li>
</ul>
<p>接下来我们来描述一下如果创建这些文件并组合起来。</p>
<h2 id="准备好系统工具">准备好系统工具</h2>
<p>想要扩展能够在系统上编译并成功运行，需要准备转以下工具：</p>
<ul>
<li>GNU autoconf</li>
<li>GNU automake</li>
<li>GNU libtool</li>
<li>GNU m4</li>
</ul>
<p>以上这些都可以从 <a href="ftp://ftp.gnu.org/pub/gnu/">ftp://ftp.gnu.org/pub/gnu/</a> 获取。</p>
<p><em>注：以上这些都是类 Unix 环境下才能使用的工具。</em></p>
<h2 id="改装一个已经存在的扩展">改装一个已经存在的扩展</h2>
<p>为了显示出创建一个独立的扩展是很容易的事情，我们先将一个已经内嵌到 PHP 的扩展改成独立扩展。安装 PHP 并且执行以下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ mkdir /tmp/newext
$ <span class="nb">cd</span> /tmp/newext
</code></pre></div><p>现在你已经有了一个空目录。我们将 mysql 扩展目录下的文件复制过来：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ cp -rp php-4.0.X/ext/mysql/* .
<span class="c1"># 注：看来这篇 README 真的需要更新一下了</span>
<span class="c1"># PHP7 中已经移除了 mysql 扩展部分</span>
</code></pre></div><p>到这里扩展就完成了，执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ phpize
</code></pre></div><p>现在你可以独立存放这个目录下的文件到任何地方，这个扩展可以完全独立存在了。</p>
<p>用户在编译时需要使用以下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ./configure <span class="se">\
</span><span class="se"></span>       <span class="o">[</span>--with-php-config<span class="o">=</span>/path/to/php-config<span class="o">]</span> <span class="se">\
</span><span class="se"></span>       <span class="o">[</span>--with-mysql<span class="o">=</span>MYSQL-DIR<span class="o">]</span>
$ make install
</code></pre></div><p>这样 MySQL 模块就可以使用内嵌的 MySQL 客户端库或者已安装的位于 MySQL 目录中的 MySQL。</p>
<p><em>注：意思是说想要编写 PHP 扩展，你既需要已经安装了 PHP，也需要下载一份 PHP 源码。</em></p>
<h2 id="定义一个新扩展">定义一个新扩展</h2>
<p>我们给示例扩展命名为 “foobar”。</p>
<p>新扩展包含两个资源文件：foo.c 和 bar.c（还有一些头文件，但这些不只重要）。</p>
<p>示例扩展不引用任何外部的库（这点很重要，因为这样用户就不需要特别指定一些编译选项了）。</p>
<p><code>LTLIBRARY_SOURCES</code> 选项用于指定资源文件的名字，你可以有任意数量的资源文件。</p>
<p><em>注：上面说的是 Makefile.in 文件中的配置选项，可以参考 <a href="https://github.com/xdebug/xdebug/blob/master/Makefile.in">xdebug</a>。</em></p>
<h2 id="修改-m4-后缀的配置文件">修改 m4 后缀的配置文件</h2>
<p>m4 配置文件可以指定一些额外的检查。对于一个独立扩展来说，你只需要做一些宏调用即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">PHP_ARG_ENABLE<span class="o">(</span>foobar,whether to <span class="nb">enable</span> foobar,
<span class="o">[</span>  --enable-foobar            Enable foobar<span class="o">])</span>

<span class="k">if</span> <span class="nb">test</span> <span class="s2">&#34;</span><span class="nv">$PHP_FOOBAR</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;no&#34;</span><span class="p">;</span> <span class="k">then</span>
  PHP_NEW_EXTENSION<span class="o">(</span>foobar, foo.c bar.c, <span class="nv">$ext_shared</span><span class="o">)</span>
<span class="k">fi</span>
</code></pre></div><p><code>PHP_ARG_ENABLE</code> 会自动设置好正确的变量以保证扩展能够被 <code>PHP_NEW_EXTENSION</code> 以共享模式启动。</p>
<p><code>PHP_NEW_EXTENSION</code> 的第一个参数是扩展的名称，第二个参数是资源文件。第三个参数 <code>$ext_shared</code> 是由 <code>PHP_ARG_ENABLE/WITH</code> 为 <code>PHP_NEW_EXTENSION</code> 设定的。</p>
<p>请始终使用 <code>PHP_ARG_ENABLE</code> 或 <code>PHP_ARG_WITH</code> 进行设置。即使你不打算发布你的 PHP 模块，这些设置也可以保证让你的模块和 PHP 主模块的接口保持一体。</p>
<p><em>注：<code>PHP_ARG_ENABLE</code> 和 <code>PHP_ARG_WITH</code> 应该是用于定义模块是动态扩展还是静态编译进 PHP 中，就跟编译 PHP 时使用的 <code>--enable-xxx</code> 和 <code>--with-xxx</code> 一样。</em></p>
<h2 id="创建资源文件">创建资源文件</h2>
<p><code>ext_skel</code> 可以为你的 PHP 模块创建一些通用的代码，你也可以编写一些基本函数定义和 C 代码来处理函数的参数。具体信息可以查看 <a href="https://github.com/php/php-src/blob/master/README.EXT_SKEL">READNE.EXT_SKEL</a>。</p>
<p>不要担心没有范例，PHP 中有很多模块供你参考，选择一个简单的点开始，添加你自己的代码。</p>
<p><em>注：<code>ext_skel</code> 可以生成好基本模块需要的资源文件和配置文件，不需要自己创建。</em></p>
<h2 id="修改自定义模块">修改自定义模块</h2>
<p>将 config.m4 文件和资源文件放到同一个目录中，然后执行 <code>phpize</code> （PHP 4.0 以上的版本编译 PHP 的时候都安装了 phpize）。</p>
<p>如果你的 phpize 不在系统环境变量中，你需要指定绝对路径，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ /php/bin/phpize
</code></pre></div><p>这个命令会自动复制必需的构建文件到当前目录并根据 config.m4 创建配置文件。</p>
<p>通过以上的步骤，你已经有了一个独立的扩展了。</p>
<h2 id="安装扩展">安装扩展</h2>
<p>扩展可以通过以下命令编译安装：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ./configure <span class="se">\
</span><span class="se"></span>            <span class="o">[</span>--with-php-config<span class="o">=</span>/path/to/php-config<span class="o">]</span>
$ make install
</code></pre></div><h2 id="给模块添加共享支持">给模块添加共享支持</h2>
<p>有时候独立扩展需要是共享的已供其他模块加载。接下来我会解释如何给已经创建好的 foo 模块添加共享支持。</p>
<ol>
<li>
<p>在 config.m4 文件中，使用 <code>PHP_ARG_WITH/PHP_ARG_ENABLE</code> 来设定扩展，这样就可以自动使用 <code>--with-foo=shared[,..]</code> 或 <code>--enable-foo=shared[,..]</code> 这样的指令作为编译参数了。</p>
</li>
<li>
<p>在 config.m4 文件中，使用 <code>PHP_NEW_EXTENSION(foo,.., $ext_shared)</code> 使扩展可以被构建。</p>
</li>
<li>
<p>添加以下代码到你的 C 语言资源文件中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifdef COMPILE_DL_FOO
</span><span class="cp"></span><span class="n">ZEND_GET_MODULE</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="cp">#endif
</span></code></pre></div></li>
</ol>
<p><em>这一段讲的上面都提到过了，这里只是又强调了一下。</em></p>
<h2 id="pecl-网站约定">PECL 网站约定</h2>
<p>如果你打算发布你的扩展到 PECL 的网站，需要考虑以下几点：</p>
<ol>
<li>
<p>添加 LICENSE 或 COPYING 到 package.xml</p>
</li>
<li>
<p>需要在扩展头文件中定义好版本信息，这个宏会被 <code>foo_module_entry</code> 调用来声明扩展版本：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define PHP_FOO_VERSION &#34;1.2.3&#34;
</span></code></pre></div></li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>getimagesize 函数不是完全可靠的</title>
            <link>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</link>
            <pubDate>Mon, 26 Oct 2015 23:12:53 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-10-26-php-function-getimagesize/</guid>
            <description>getimagesize 函数并不属于 GD 扩展的部分，标准安装的 PHP 都可以使用这个函数。可以先看看这个函数的文档描述：http://php.net/manual/zh/function.getimagesize.php
如果指定的文件如果不是有效的图像，会返回 false，返回数据中也有表示文档类型的字段。如果不用来获取文件的大小而是使用它来判断上传文件是否是图片文件，看起来似乎是个很不错的方案，当然这需要屏蔽掉可能产生的警告，比如代码这样写：
&amp;lt;?php $filesize = @getimagesize(&amp;#39;/path/to/image.png&amp;#39;); if ($filesize) { do_upload(); } # 另外需要注意的是，你不可以像下面这样写： # if ($filesize[2] == 0) # 因为 $filesize[2] 可能是 1 到 16 之间的整数，但却绝对不对是0。 但是如果你仅仅是做了这样的验证，那么很不幸，你成功的在代码里种下了一个 webshell 的隐患。
要分析这个问题，我们先来看一下这个函数的原型：
static void php_getimagesize_from_stream(php_stream *stream, zval **info, INTERNAL_FUNCTION_PARAMETERS) { ... itype = php_getimagetype(stream, NULL TSRMLS_CC); switch( itype) { ... } ... } static void php_getimagesize_from_any(INTERNAL_FUNCTION_PARAMETERS, int mode) { ... php_getimagesize_from_stream(stream, info, INTERNAL_FUNCTION_PARAM_PASSTHRU); php_stream_close(stream); } PHP_FUNCTION(getimagesize) { php_getimagesize_from_any(INTERNAL_FUNCTION_PARAM_PASSTHRU, FROM_PATH); } 限于篇幅上面隐藏了一些细节，现在从上面的代码中我们知道两件事情就够了：</description>
            <content type="html"><![CDATA[<p><code>getimagesize</code> 函数并不属于 GD 扩展的部分，标准安装的 PHP 都可以使用这个函数。可以先看看这个函数的文档描述：<a href="http://php.net/manual/zh/function.getimagesize.php">http://php.net/manual/zh/function.getimagesize.php</a></p>
<p>如果指定的文件如果不是有效的图像，会返回 false，返回数据中也有表示文档类型的字段。如果不用来获取文件的大小而是使用它来判断上传文件是否是图片文件，看起来似乎是个很不错的方案，当然这需要屏蔽掉可能产生的警告，比如代码这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$filesize</span> <span class="o">=</span> <span class="o">@</span><span class="nx">getimagesize</span><span class="p">(</span><span class="s1">&#39;/path/to/image.png&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$filesize</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">do_upload</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1"># 另外需要注意的是，你不可以像下面这样写：
</span><span class="c1"># if ($filesize[2] == 0)
</span><span class="c1"># 因为 $filesize[2] 可能是 1 到 16 之间的整数，但却绝对不对是0。
</span></code></pre></div><p>但是如果你仅仅是做了这样的验证，那么很不幸，你成功的在代码里种下了一个 webshell 的隐患。</p>
<p>要分析这个问题，我们先来看一下这个函数的原型：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">php_getimagesize_from_stream</span><span class="p">(</span><span class="n">php_stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="n">zval</span> <span class="o">**</span><span class="n">info</span><span class="p">,</span> <span class="n">INTERNAL_FUNCTION_PARAMETERS</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">itype</span> <span class="o">=</span> <span class="n">php_getimagetype</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="nb">NULL</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">itype</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">...</span>
	<span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">php_getimagesize_from_any</span><span class="p">(</span><span class="n">INTERNAL_FUNCTION_PARAMETERS</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="n">php_getimagesize_from_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">INTERNAL_FUNCTION_PARAM_PASSTHRU</span><span class="p">);</span>
	<span class="n">php_stream_close</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PHP_FUNCTION</span><span class="p">(</span><span class="n">getimagesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">php_getimagesize_from_any</span><span class="p">(</span><span class="n">INTERNAL_FUNCTION_PARAM_PASSTHRU</span><span class="p">,</span> <span class="n">FROM_PATH</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>限于篇幅上面隐藏了一些细节，现在从上面的代码中我们知道两件事情就够了：</p>
<ol>
<li>最终处理的函数是 <code>php_getimagesize_from_stream</code></li>
<li>负责判断文件类型的函数是 <code>php_getimagetype</code></li>
</ol>
<p>接下来看一下 <code>php_getimagetype</code> 的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PHPAPI</span> <span class="kt">int</span> <span class="nf">php_getimagetype</span><span class="p">(</span><span class="n">php_stream</span> <span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filetype</span> <span class="n">TSRMLS_DC</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="n">php_sig_gif</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">IMAGE_FILETYPE_GIF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="n">php_sig_jpg</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">IMAGE_FILETYPE_JPEG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="n">php_sig_png</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="p">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>去掉了一些细节，<code>php_sig_gif</code> <code>php_sig_png</code> 等是在文件头部定义的：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PHPAPI</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">php_sig_gif</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="sc">&#39;F&#39;</span><span class="p">};</span>
<span class="p">...</span>
<span class="n">PHPAPI</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">php_sig_png</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x89</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x50</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x47</span><span class="p">,</span>
                                    <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x0d</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x1a</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="mh">0x0a</span><span class="p">};</span>
</code></pre></div><p>可以看出来 image type 是根据文件流的前几个字节（文件头）来判断的。那么既然如此，我们可不可以构造一个特殊的 PHP 文件来绕过这个判断呢？不如来尝试一下。</p>
<p>找一个十六进制编辑器来写一个的 PHP 语句，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span> <span class="nx">phpinfo</span><span class="p">();</span> <span class="cp">?&gt;</span>
</code></pre></div><p>这几个字符的十六进制编码（UTF-8）是这样的：</p>
<pre><code>3C3F 7068 7020 7068 7069 6E66 6F28 293B 203F 3E
</code></pre><p>我们构造一下，把 PNG 文件的头字节加在前面变成这样的：</p>
<pre><code>8950 4E47 0D0A 1A0A 3C3F 7068 7020 7068 7069 6E66 6F28 293B 203F 3E
</code></pre><p>最后保存成 <code>.php</code> 后缀的文件（注意上面是文件的十六进制值），比如 test.php。执行一下 <code>php test.php</code> 你会发现完全可以执行成功。那么能用 <code>getimagesize</code> 读取它的文件信息吗？新建一个文件写入代码试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nx">print_r</span><span class="p">(</span><span class="nx">getimagesize</span><span class="p">(</span><span class="s1">&#39;test.php&#39;</span><span class="p">));</span>
</code></pre></div><p>执行结果：</p>
<pre><code>Array
(
    [0] =&gt; 1885957734
    [1] =&gt; 1864902971
    [2] =&gt; 3
    [3] =&gt; width=&quot;1885957734&quot; height=&quot;1864902971&quot;
    [bits] =&gt; 32
    [mime] =&gt; image/png
)
</code></pre><p>成功读取出来，并且文件也被正常识别为 PNG 文件，虽然宽和高的值都大的有点离谱。</p>
<p>现在你应该明白为什么上文说这里留下了一个 webshell 的隐患的吧。如果这里只有这样的上传判断，而且上传之后的文件是可以访问的，就可以通过这个入口注入任意代码执行了。</p>
<p>那么为什么上面的文件可以 PHP 是可以正常执行的呢？用 <a href="http://php.net/manual/zh/function.token-get-all.php">token_get_all</a> 函数来看一下这个文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nx">print_r</span><span class="p">(</span><span class="nx">token_get_all</span><span class="p">(</span><span class="nx">file_get_contents</span><span class="p">(</span><span class="s1">&#39;test.php&#39;</span><span class="p">)));</span>
</code></pre></div><p>如果显示正常的话你能看到输出数组的第一个元素的解析器代号是 312，通过 <a href="http://php.net/manual/zh/function.token-name.php">token_name</a> 获取到的名称会是 T_INLINE_HTML，也就是说文件头部的信息被当成正常的内嵌的 HTML 代码被忽略掉了。</p>
<p>至于为什么会有一个大的离谱的宽和高，看一下 <code>php_handle_png</code> 函数的实现就能知道，这些信息也是通过读取特定的文件头的位来获取的。</p>
<p>所以，对于正常的图片文件，getimagesize 完全可以胜任，但是对于一些有心构造的文件结构却不行。</p>
<p>在处理用户上传的文件时，先简单粗暴的判断文件扩展名并对文件名做一下处理，保证在服务器上不是 php 文件都不能直接执行也是一种有效的方式。然后可以使用 getimagesize 做一些辅助处理。</p>
]]></content>
        </item>
        
        <item>
            <title>Laravel 模板引擎（Blade）原理简析</title>
            <link>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</link>
            <pubDate>Sun, 25 Oct 2015 23:50:33 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-10-25-laravel-blade-engine/</guid>
            <description>上次提到过，模板引擎一般是要做三件事情：
 变量值的输出（echo） 条件判断和循环（if &amp;hellip; else、for、foreach、while） 引入或继承其他文件  现在就来看看 Laravel 的模板引擎是如何来处理这三件事情的。我是在 Laravel 5.1 的实现上来写这篇文章的。
1. 视图解析流程 Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：.blade.php 后缀的认为是模板视图文件，其他的 .php 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。
在使用 View 组件输出时，不管是调用 helpers 中提供的 view 函数还是使用 Facades 提供静态接口 View::make()，实际上执行的都是 Illuminate\View\Factory 中的 make 方法。以此为入口，很容易就能知道视图解析输出的流程：
 查找视图文件； 根据文件名后缀从 Container 中取出响应的引擎； 加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。  Factory 中的一些方法完成了以上第一步的过程，文件查找是调用的 FileViewFinder,其中使用了一些 Illuminate\Filesystem\Filesystem 中的方法，这个类中还有一些方法是跟 events 相关的，这里就忽略不表了。
在以上步骤中，如果中获取到的视图文件是需要“编译”的，引擎会调用 “Blade 编译器”将原视图进行“编译”并保存在 cache 目录中然后加载输出。下次调用时如果发现源文件并没有被修改过就不再重新编译而是直接获取缓存文件并输出。
CompilerEngine 调用的编译器是 CompilerInterface 接口的实现，默认情况下也就只有 BladeCompiler（如果不知道解析器是如何注入的，你需要去了解 Laravel 的服务容器，这里就不细表）。</description>
            <content type="html"><![CDATA[<p>上次提到过，模板引擎一般是要做三件事情：</p>
<ol>
<li>变量值的输出（echo）</li>
<li>条件判断和循环（if &hellip; else、for、foreach、while）</li>
<li>引入或继承其他文件</li>
</ol>
<p>现在就来看看 Laravel 的模板引擎是如何来处理这三件事情的。我是在 Laravel 5.1 的实现上来写这篇文章的。</p>
<h2 id="1-视图解析流程">1. 视图解析流程</h2>
<p>Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：<code>.blade.php</code> 后缀的认为是模板视图文件，其他的 <code>.php</code> 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。</p>
<p>在使用 View 组件输出时，不管是调用 helpers 中提供的 <code>view</code> 函数还是使用 Facades 提供静态接口 <code>View::make()</code>，实际上执行的都是 <code>Illuminate\View\Factory</code> 中的 <code>make</code> 方法。以此为入口，很容易就能知道视图解析输出的流程：</p>
<ol>
<li>查找视图文件；</li>
<li>根据文件名后缀从 Container 中取出响应的引擎；</li>
<li>加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。</li>
</ol>
<p>Factory 中的一些方法完成了以上第一步的过程，文件查找是调用的 FileViewFinder,其中使用了一些 <code>Illuminate\Filesystem\Filesystem</code> 中的方法，这个类中还有一些方法是跟 <code>events</code> 相关的，这里就忽略不表了。</p>
<p>在以上步骤中，如果中获取到的视图文件是需要“编译”的，引擎会调用 “Blade 编译器”将原视图进行“编译”并保存在 cache 目录中然后加载输出。下次调用时如果发现源文件并没有被修改过就不再重新编译而是直接获取缓存文件并输出。</p>
<p><code>CompilerEngine</code> 调用的编译器是 <code>CompilerInterface</code> 接口的实现，默认情况下也就只有 <code>BladeCompiler</code>（如果不知道解析器是如何注入的，你需要去了解 Laravel 的服务容器，这里就不细表）。</p>
<h2 id="2-blade-引擎">2. Blade 引擎</h2>
<p>接下来就是本文的重点：Blade 是如何“编译”的。我一直给“编译”两个字加引号，因为这显然不是真正意义上的代码编译的过程，只是一些正则替换的过程。</p>
<p>我们知道 Laravel 的模板引擎是很简洁的，使用时并不需要掌握太多东西，基本上只需要知道以下两点：</p>
<ol>
<li>{{ 与 }} 之间是要输出的内容，也有扩展的两个方法 {{{ &hellip; }}} 和 {!! .. !!} 分别用于转义输出和不转义输出，5.0 以后的版本中 {{ &hellip; }} 之间的默认情况下也是转义输出的；</li>
<li><code>@</code> 符号开头的都是指令，包括 PHP 本身有的 <code>if</code> <code>else</code> <code>foreach</code> 以及扩展的 <code>include</code> <code>yield</code> <code>stop</code> 等等；</li>
</ol>
<p>而 Blade 对于解析的处理实际上是分了四种情况：</p>
<ol>
<li>Extensions  -&gt; 扩展部分</li>
<li>Statements -&gt; 语句块（就是 <code>@</code> 开头的指令）</li>
<li>Comments -&gt; 注释部分（{{&ndash; &hellip; &ndash;}} 的写法，解析之后是 PHP 的注释而不是 HTML的注释）</li>
<li>Echos -&gt; 输出</li>
</ol>
<p>在解析（解析是在 cache 不存在的情况下）过程中，Blade 会先使用 <code>token_get_all</code> 函数获取到视图文件中的被 PHP 解释器认为是 HTML（T_INLINE_HTML）的部分，然后依次进行以上四种情况的解析。</p>
<p>扩展部分是调用用户自定义的编译器解析字符串。BladeCompiler 中提供了的 <code>extend</code> 方法来添加可扩展。</p>
<p>注释部分也很简单，就是将 {{&ndash; &hellip; &ndash;}} 替换成 &lt;?php /* &hellip; */ ?php&gt;。</p>
<p>输出部分提供了三个方法，分别对应上文提到的三种情况：</p>
<ol>
<li>compileRawEchos -&gt; 输出未经转义的内容 （{!! &hellip; !!}）</li>
<li>compileEscapedEchos -&gt; 输出转义之后的内容 （{{{ &hellip; }}}）</li>
<li>compileRegularEchos -&gt; 正常输出 （{{ &hellip; }}）</li>
</ol>
<p>默认情况下经过字符替换之后 <code>compileEscapedEchos</code> 和 <code>compileRegularEchos</code> 的函数体其实是完全一样的，在输出的时候都是调用一个 <code>e()</code> 的辅助函数来输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="k">function</span> <span class="nf">e</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$value</span> <span class="nx">instanceof</span> <span class="nx">Htmlable</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nv">$value</span><span class="o">-&gt;</span><span class="na">toHtml</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">htmlentities</span><span class="p">(</span><span class="nv">$value</span><span class="p">,</span> <span class="nx">ENT_QUOTES</span><span class="p">,</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div><p>这貌似是 5.0 之后的版本才改的，之前的版本里 <code>compileRegularEchos</code> 执行的是 <code>compileRawEchos</code> 的行为。不过两个函数还是有一个区别：<code>compileRegularEchos</code> 的转义函数是可以通过 <code>setEchoFormat</code> 自定义的（只是默认是 <code>e()</code>），但是 <code>compileEscapedEchos</code> 不允许自定义。</p>
<p><code>echo</code> 后的内容也是经过正则替换的：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">compileEchoDefaults</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">preg_replace</span><span class="p">(</span><span class="s1">&#39;/^(?=\$)(.+?)(?:\s+or\s+)(.+?)$/s&#39;</span><span class="p">,</span> <span class="s1">&#39;isset($1) ? $1 : $2&#39;</span><span class="p">,</span> <span class="nv">$value</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div><p>从正则表达式中可以看出来输出提供了一个 <code>or</code> 的关键字，<code>$a or $b</code> 的写法会被替换成 <code>isset($a) ? $a : $b</code>。</p>
<p>语句块部分可以分成三种情况：</p>
<ol>
<li>和 PHP 本身一样的 <code>if</code> <code>else</code> <code>foreach</code> 以及扩展的 <code>unless</code> 等流程和循环控制的关键字；</li>
<li><code>include</code> <code>yield</code> 等模板文件引入、内容替换的部分；</li>
<li><code>lang</code> <code>choice</code> <code>can</code> 等涉及到 Laravel 其他组件的功能性关键字。</li>
</ol>
<p>第一种情况是很简单的替换过程，本身 PHP 为了在 HMTL 和 PHP 混合书写方便就提供了 <code>if</code> <code>foreach</code> 等几个关键字使用冒号和 <code>endif</code> 等关键字代替大括号来控制流程的方法。</p>
<p>第二种情况稍微复杂一点，比如下面的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">compileYield</span><span class="p">(</span><span class="nv">$expression</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&#34;&lt;?php echo </span><span class="se">\$</span><span class="s2">__env-&gt;yieldContent</span><span class="si">{</span>$expression<span class="si">}</span><span class="s2">; ?&gt;&#34;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><p>解析之后的语句是调用了一个名为 <code>$_env</code> 的实例中的方法。这个实例其实就是 <code>Illuminate\View\Factory</code> 的实例：</p>
<p>Factory 的构造函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">EngineResolver</span> <span class="nv">$engines</span><span class="p">,</span> <span class="nx">ViewFinderInterface</span> <span class="nv">$finder</span><span class="p">,</span> <span class="nx">Dispatcher</span> <span class="nv">$events</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">...</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">share</span><span class="p">(</span><span class="s1">&#39;__env&#39;</span><span class="p">,</span> <span class="nv">$this</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div><p><code>Illuminate\View\View</code> 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">getContents</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">engine</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">path</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">gatherData</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="sd">/**
</span><span class="sd">     * Get the data bound to the view instance.
</span><span class="sd">     *
</span><span class="sd">     * @return array
</span><span class="sd">     */</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">gatherData</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$data</span> <span class="o">=</span> <span class="nx">array_merge</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">factory</span><span class="o">-&gt;</span><span class="na">getShared</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">data</span><span class="p">);</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="nv">$data</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><p>由此也可以看出 <code>each</code> <code>yield</code> 等指令的实现也是在 Factory 中，分别对应的是 <code>renderEach</code> <code>yieldContent</code> 等。</p>
<p>所以文件引入等指令的实现方式就是：在主视图输出的时候，通过注入的 <code>$__env</code> 来重复调用 Factory 中的 <code>make</code> 方法来输出引入的文件。</p>
<p>至于 <code>lang</code> 等关键字，替换后就是使用 <code>app()</code> 函数来调用 Laravel 的其他组件。此外 Blade 还提供了 <code>inject</code> 关键字来调用任何你想使用的组件。</p>
<p>除了以上这些，你还可以通过 <code>directive</code> 方法来增加一些自定义指令。</p>
<p>compileStatements 方法中最后进行正则替换的正则表达式看起来比较复杂：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">/<span class="se">\B</span>@<span class="o">(</span><span class="se">\w</span>+<span class="o">)([</span> <span class="se">\t</span><span class="o">]</span>*<span class="o">)(</span><span class="se">\(</span> <span class="o">(</span> <span class="o">(</span>?&gt;<span class="o">[</span>^<span class="o">()]</span>+<span class="o">)</span> <span class="p">|</span> <span class="o">(</span>?3<span class="o">)</span> <span class="o">)</span>* <span class="se">\)</span><span class="o">)</span>?/x
</code></pre></div><p>这是因为正则后面的一部分实现了 <a href="http://php.net/manual/zh/regexp.reference.recursive.php">递归模式</a> 来匹配语句块中括号的数量。</p>
<h2 id="3-后话">3. 后话</h2>
<p>通过以上的分析可以看出来 Laravel 的视图组件还是十分简洁的，同时也不失灵活性和可扩展性。如果有兴趣的话，也可以实现一个自己的模板解析引擎。</p>
<p>如果你想在其他项目中使用 Blade 引擎，通过 Composer 安装下来之后会发现还有 Container、Events 等部分，这和 Laravel 本身有关。</p>
<p>为了能够在任何地方使用 Blade，我把它核心的部分提取了出来，去掉了其他组件的依赖，也不再依赖文件扩展名来选择引擎：</p>
<p>项目地址：<a href="https://github.com/XiaoLer/blade">https://github.com/XiaoLer/blade</a></p>
<p>此外也通过这个提取之后的版本做了一个 yii2 能够使用的版本：<a href="https://github.com/XiaoLer/yii2-blade">https://github.com/XiaoLer/yii2-blade</a>。在之前尝试的版本中直接使用 Laravel 的 View 组件并不灵活，现在感觉好多了。</p>
]]></content>
        </item>
        
        <item>
            <title>PHP 7 的几个新特性</title>
            <link>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</link>
            <pubDate>Sun, 18 Oct 2015 15:29:42 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-10-18-part-of-php7-new-features/</guid>
            <description>1. ?? 运算符（NULL 合并运算符） 把这个放在第一个说是因为我觉得它很有用。用法：
$a = $_GET[&amp;#39;a&amp;#39;] ?? 1; 它相当于：
&amp;lt;?php $a = isset($_GET[&amp;#39;a&amp;#39;]) ? $_GET[&amp;#39;a&amp;#39;] : 1; 我们知道三元运算符是可以这样用的：
$a ?: 1 但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。
2. 函数返回值类型声明 官方文档提供的例子（注意 ... 的边长参数语法在 PHP 5.6 以上的版本中才有）：
&amp;lt;?php function arraysSum(array ...$arrays): array { return array_map(function(array $array): int { return array_sum($array); }, $arrays); } print_r(arraysSum([1,2,3], [4,5,6], [7,8,9])); 从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。
这种声明的写法有些类似于 swift：
func sayHello(personName: String) -&amp;gt; String { let greeting = &amp;#34;Hello, &amp;#34; + personName + &amp;#34;!</description>
            <content type="html"><![CDATA[<h3 id="1--运算符null-合并运算符">1. ?? 运算符（NULL 合并运算符）</h3>
<p>把这个放在第一个说是因为我觉得它很有用。用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">$a = $_GET[&#39;a&#39;] ?? 1;
</code></pre></div><p>它相当于：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="nx">isset</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>我们知道三元运算符是可以这样用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">$a ?: 1
</code></pre></div><p>但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。</p>
<h3 id="2-函数返回值类型声明">2. 函数返回值类型声明</h3>
<p>官方文档提供的例子（注意 <code>...</code> 的边长参数语法在 PHP 5.6 以上的版本中才有）：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">arraysSum</span><span class="p">(</span><span class="k">array</span> <span class="o">...</span><span class="nv">$arrays</span><span class="p">)</span><span class="o">:</span> <span class="k">array</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nx">array_map</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="k">array</span> <span class="nv">$array</span><span class="p">)</span><span class="o">:</span> <span class="nx">int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">array_sum</span><span class="p">(</span><span class="nv">$array</span><span class="p">);</span>
    <span class="p">},</span> <span class="nv">$arrays</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">print_r</span><span class="p">(</span><span class="nx">arraysSum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]));</span>
</code></pre></div><p>从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。</p>
<p>这种声明的写法有些类似于 swift：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">personName</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">greeting</span> <span class="p">=</span> <span class="s">&#34;Hello, &#34;</span> <span class="o">+</span> <span class="n">personName</span> <span class="o">+</span> <span class="s">&#34;!&#34;</span>
    <span class="k">return</span> <span class="n">greeting</span>
<span class="p">}</span>
</code></pre></div><p>这个特性可以帮助我们避免一些 PHP 的隐式类型转换带来的问题。在定义一个函数之前就想好预期的结果可以避免一些不必要的错误。</p>
<p>不过这里也有一个特点需要注意。PHP 7 增加了一个 <em>declare</em> 指令：<code>strict_types</code>，既使用严格模式。</p>
<p>使用返回值类型声明时，如果没有声明为严格模式，如果返回值不是预期的类型，PHP 还是会对其进行强制类型转换。但是如果是严格模式， 则会出发一个 <code>TypeError</code> 的 Fatal error。</p>
<p>强制模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="o">:</span> <span class="nx">int</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</code></pre></div><p>以上代码可以正常执行，foo 函数返回 int 1，没有任何错误。</p>
<p>严格模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

<span class="k">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="o">:</span> <span class="nx">int</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="c1"># PHP Fatal error:  Uncaught TypeError: Return value of foo() must be of the type integer, float returned in test.php:6
</span></code></pre></div><p>在声明之后，就会触发致命错误。</p>
<p>是不是有点类似与 js 的 strict mode？</p>
<h3 id="3-标量类型声明">3. 标量类型声明</h3>
<p>PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、<code>array</code> 或者 <code>callable</code> (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 <code>string</code>、<code>int</code>、<code>float</code>和 <code>bool</code> 了。</p>
<p>官方示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="c1">// Coercive mode
</span><span class="c1"></span><span class="k">function</span> <span class="nf">sumOfInts</span><span class="p">(</span><span class="nx">int</span> <span class="o">...</span><span class="nv">$ints</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nx">array_sum</span><span class="p">(</span><span class="nv">$ints</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">var_dump</span><span class="p">(</span><span class="nx">sumOfInts</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">));</span>
</code></pre></div><p>需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 <code>TypeError</code> 的致命错误。</p>
<h3 id="4-use-批量声明">4. use 批量声明</h3>
<p>PHP 7 中 use 可以在一句话中声明多个类或函数或 const 了：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">use</span> <span class="nx">some\namespace\</span><span class="p">{</span><span class="nx">ClassA</span><span class="p">,</span> <span class="nx">ClassB</span><span class="p">,</span> <span class="nx">ClassC</span> <span class="k">as</span> <span class="nx">C</span><span class="p">};</span>
<span class="k">use</span> <span class="k">function</span> <span class="nf">some\namespace\</span><span class="p">{</span><span class="nx">fn_a</span><span class="p">,</span> <span class="nx">fn_b</span><span class="p">,</span> <span class="nx">fn_c</span><span class="p">};</span>
<span class="k">use</span> <span class="k">const</span> <span class="no">some\namespace\</span><span class="p">{</span><span class="nx">ConstA</span><span class="p">,</span> <span class="nx">ConstB</span><span class="p">,</span> <span class="nx">ConstC</span><span class="p">};</span>
</code></pre></div><p>但还是要写出每个类或函数或 const 的名称（并没有像 python 一样的 <code>from some import *</code> 的方法）。</p>
<p>需要留意的问题是：如果你使用的是基于 composer 和 PSR-4 的框架，这种写法是否能成功的加载类文件？其实是可以的，composer 注册的自动加载方法是在类被调用的时候根据类的命名空间去查找位置，这种写法对其没有影响。</p>
<h3 id="5-其他的特性">5. 其他的特性</h3>
<p>其他的一些特性我就不一一介绍了，有兴趣可以查看官方文档：</p>
<p><a href="http://php.net/manual/en/migration70.new-features.php">http://php.net/manual/en/migration70.new-features.php</a></p>
<p>简要说几个：</p>
<ul>
<li>PHP 5.3 开始有了匿名函数，现在又有了匿名类了；</li>
<li>define 现在可以定义常量数组；</li>
<li>闭包（ <a href="http://php.net/manual/en/closure.call.php">Closure</a>）增加了一个 call 方法；</li>
<li>生成器（或者叫迭代器更合适）可以有一个最终返回值（return），也可以通过 <code>yield from</code> 的新语法进入一个另外一个生成器中（生成器委托）。</li>
</ul>
<p>生成器的两个新特性（return 和 <code>yield from</code>）可以组合。具体的表象大家可以自行测试。PHP 7 现在已经到 RC5 了，最终的版本应该会很快到来。</p>
]]></content>
        </item>
        
        <item>
            <title>现在写 PHP，你应该知道这些</title>
            <link>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</link>
            <pubDate>Sun, 11 Oct 2015 22:50:43 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-10-11-php-now-you-shoud-know/</guid>
            <description>首先你应该是在用 PHP 5.3 以上的版本，如果 PHP 版本在这之下，是时候该升级了。我建议如果有条件，最好使用最新的版本。
你应该看过 PHP The Right Way，这篇文章包含了很多内容，而且还能再扩展开。大部分的名词和概念你都需要了解。
1. PSR  The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together.
 在之前的文章中以及跟同事交流的过程中我多次提到过 PSR（PHP Standard Recommendation）。很多人以为 PSR 只是做一些规范代码风格等无关痛痒的事情，但其实远不止此。
PSR 的一系列标准文档由 php-fig (PHP Framework Interop Group)起草和投票决议，投票成员中有一些主流框架和扩展的作者，包括 Laravel、Symfony、Yii等等。
按照其官网的说法，这个组织的目的并不是告诉你你应该怎么做，只是一些主流的框架之间相互协商和约定。但是我相信这些框架和扩展中总会有你用到的。
PSR 目前通过的共有 6 份文档：
 0：自动加载（主要是针对 PHP 5.3 以前没有命名空间的版本） 1：编码规范 2：编码风格推荐 3：Log 结果 4：自动加载更细（在出现命名空间后有很大的改变） 7：HTTP 消息接口  目前在起草（Draft）中的还有 PSR-5(PHPDoc Standard)、PSR-6(Cache)等。5 和 6 没有出现在以上的列表中，是因为还没有投票通过。</description>
            <content type="html"><![CDATA[<p>首先你应该是在用 PHP 5.3 以上的版本，如果 PHP 版本在这之下，是时候该升级了。我建议如果有条件，最好使用最新的版本。</p>
<p>你应该看过 <a href="http://wulijun.github.io/php-the-right-way/">PHP The Right Way</a>，这篇文章包含了很多内容，而且还能再扩展开。大部分的名词和概念你都需要了解。</p>
<h2 id="1-psr">1. PSR</h2>
<blockquote>
<p>The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together.</p>
</blockquote>
<p>在之前的文章中以及跟同事交流的过程中我多次提到过 PSR（PHP Standard Recommendation）。很多人以为 PSR 只是做一些规范代码风格等无关痛痒的事情，但其实远不止此。</p>
<p>PSR 的一系列标准文档由 <a href="http://www.php-fig.org/">php-fig</a> (PHP Framework Interop Group)起草和投票决议，投票成员中有一些主流框架和扩展的作者，包括 Laravel、Symfony、Yii等等。</p>
<p>按照其官网的说法，这个组织的目的并不是告诉你你应该怎么做，只是一些主流的框架之间相互协商和约定。但是我相信这些框架和扩展中总会有你用到的。</p>
<p>PSR 目前通过的共有 6 份文档：</p>
<ul>
<li>0：自动加载（主要是针对 PHP 5.3 以前没有命名空间的版本）</li>
<li>1：编码规范</li>
<li>2：编码风格推荐</li>
<li>3：Log 结果</li>
<li>4：自动加载更细（在出现命名空间后有很大的改变）</li>
<li>7：HTTP 消息接口</li>
</ul>
<p>目前在起草（Draft）中的还有 PSR-5(PHPDoc Standard)、PSR-6(Cache)等。5 和 6 没有出现在以上的列表中，是因为还没有投票通过。</p>
<p>我相信随着标准的不断更新，你会发现研究这些约定对你也是很有裨益的，虽然未必什么都要遵守。</p>
<blockquote>
<p>Nobody in the group wants to tell you, as a programmer, how to build your application.</p>
</blockquote>
<h2 id="2-composer">2. Composer</h2>
<blockquote>
<p>Composer is a tool for dependency management in PHP. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you.</p>
</blockquote>
<p>composer 和 Pear、Pecl 都不同，它不仅仅是用于安装扩展，更重要的是定义了一种现代 PHP 框架的实现和扩展管理的方法。类似 node.js 的 npm、Python 的 pip 但又比以上做的更多。</p>
<p>composer 的核心是实现扩展的标准安装和类的自动加载。通过 <a href="https://packagist.org">packagist.org</a> 这个平台，无数的扩展组件可以被很方便的引入，目前比较知名的 PHP 扩展都可以通过 composer 安装了。而调用仅仅只需要加载一个 autoload.php 的文件即可。</p>
<p>composer 是通过 <code>spl_autoload_register</code> 方法注册一个自动加载方法实现扩展类和文件的加载的，当然这中间 composer 也做了一个优化。</p>
<p>我们都知道 PHP 引入文件要通过 <code>include</code> 和 <code>require</code> 实现，这其实写起来并不好看。 PHP 5.3 提供了命名空间，这本来和文件引入也不相干。但是 composer 实现了 PSR-4（在老版本的 PHP 上是 PSR-0），使用 <code>use</code> 时通过调用 <code>spl_autoload_register</code> 实现的方法在调用时加载所需要的类，在写法上类似 Python 的 import，即美观也起到了按需加载、延迟加载的作用。</p>
<h2 id="3-php-cs-fixer">3. php-cs-fixer</h2>
<blockquote>
<p>The PHP Coding Standards Fixer tool fixes <em>most</em> issues in your code when you want to follow the PHP coding standards as defined in the PSR-1 and PSR-2 documents.</p>
</blockquote>
<p>这个工具的作用是按照 PSR-1 和 PSR-2 的规范格式化你的代码，还有一些可选的编码风格是 Symfony 的规范。</p>
<p>这个其实本来并没有那么值得一说，只是最近在几个开源框架中都看到了 <code>.php_cs</code> 的文件，一时好奇，深究下去才发现了这个项目。</p>
<p>项目地址：<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">https://github.com/FriendsOfPHP/PHP-CS-Fixer</a></p>
<p>具体的使用和配置方法在其项目主页上都有介绍。这个组织的名字也很有趣：<a href="https://github.com/FriendsOfPHP">FriendsOfPHP</a>。主要的成员大概是来自 Symfony 项目中。</p>
<p>可能有人觉得纠结代码风格的问题其实没有特别大的必要。要说好处我也说不上来，如果你觉得编程不仅仅是一份工作，那这就跟你收拾房间一样，邋遢的房间不影响你吃饭睡觉，但干净的看起来更舒服。如果要和别人合作，那这件事情就更重要了。</p>
<h2 id="4-psysh">4. PsySH</h2>
<blockquote>
<p>A runtime developer console, interactive debugger and REPL for PHP.</p>
</blockquote>
<p><a href="http://psysh.org/">PsySH</a> 类似 Python 的 IDLE 的一个 PHP 的交互运行环境。这个是我在 Laravel 中发现的，Laravel 5 的 <code>artisan tinker</code> 的功能是通过它来实现的。Laravel 4 中用的是另外一个项目：<a href="https://github.com/borisrepl/boris">boris</a>。</p>
<p>这个主要是在平时测试一些 php 的简单的函数和特性的时候可以方便使用。遇到一些不确定的事情、比如 <code>empty</code> 的使用等，可以用它来做些测试。</p>
<h2 id="5-一些框架和组件">5. 一些框架和组件</h2>
<h3 id="框架">框架</h3>
<p>我比较喜欢的是 Laravel，目前公司在用的是 Yii2，我关注的有 Symfony 以及 Phalcon （C语言实现）。用什么不用什么，主要是喜好，有时候也由不得自己选择，但研究一下，多一分了解也未尝不可。</p>
<p>提到 Laravel 很多人都会立马想到 Ruby on Rails。我想模仿或者抄袭这都不是主要的目的，主要的目的是提供给开发者一个更好的工具。Laravel 好在它有一个不一样的路由控制（不带 <code>Action</code> 后缀或前缀的），有一个好用的 ORM (Eloquent)，好用的模板引擎 (Blade) 亦或有一个颜值比较高的文档（社区看到的话）等等。</p>
<p>强大有时候也会被人诟病庞大，但这在于你需要了解自己项目的中长期规划，项目现在的大小以及未来的大小及承载。</p>
<p>Larval 的核心实现是一个容器（Container）以及 PHP 的反射类（<strong>ReflectionClass</strong>）（Yii 2 也是一样）。要理解这些，多看文章和文档的同时，也可以看看源码。</p>
<p>Symfony 2 提供了很多组件。<a href="https://github.com/symfony/http-kernel">http-kernel</a> 和 <a href="https://github.com/symfony/http-foundation">http-foundation</a> 在 Laravel 中也有被继承过来直接使用。它是值得了解和学习的。</p>
<p>CodeIgniter 是一个小巧而强大的框架。虽然 CI 并没有使用 Composer 组件的方式进行开发，但 3.0 以后的版本也加入了 Composer 的支持（这无非就是多一个 vendor 的目录，引入 <code>autoload.php</code>）的文件。</p>
<h3 id="orm">ORM</h3>
<p>ORM 亦或 Active Record 我觉得还是需要的。也许有人认为 PHP 就是一个模板引擎、就应该手写 SQL 。不要被这些话所困扰。</p>
<p>CodeIgniter 中 Active Record 的实现方式很轻巧，但对于 CI 本身的体量来说，已经是很好用的了。</p>
<p>Laravel 实现的 Eloquent 我是很喜欢的，也可以集成到别的项目中去。Symfony 2 使用的是 <a href="http://www.doctrine-project.org/">Doctrine</a> ,这个项目也值得关注。Yii 2 也有自己的一套实现方式。</p>
<h3 id="模板引擎">模板引擎</h3>
<p>模板引擎需要做三件事情：</p>
<ol>
<li>变量值的输出（echo）,</li>
<li>条件判断和循环（if &hellip; else、for、foreach、while）</li>
<li>引入或继承自其他文件</li>
</ol>
<p>Laravel 实现的 Blade 是一个比较轻量好用的模板引擎。不过目前并不是很好能够引入到其他框架中。十一的时候闲来无事试图将其引入到 Yii 2 中，现在还只是简单的实现，我希望后面能将 Blade 的解析部分单独抽取出来做一个轻量的实现。在 Github 上搜一下发现也有人在做同样的事情。</p>
<p>Yii 2 似乎更推荐就用原生的 PHP 去写，不过也提供了支持 Smarty 和 Twig 的扩展。Symfony 2 则采用了 Twig。<a href="http://twig.sensiolabs.org/">Twig</a> 和 Symfony 以及上文提到的 php-cs-fixer 都是 SensioLabs 的作品。</p>
<p>Smarty 是一个古老而顽强的模板引擎。说实话我并不是太喜欢，其语法过于复杂，变量赋值这些事情都有自己的一套做法。现在的版本中更是使用 Lexer 的方式来解析文件，感觉像是用 PHP 实现了另外一种语言。项目里面还有一些太长的正则表达式、太复杂的实现，我觉得这是一件很危险很容易出错的事情。</p>
]]></content>
        </item>
        
        <item>
            <title>说说 PHP 的 die 和 exit</title>
            <link>http://0x1.im/posts/2015-09-24-php-exit-die/</link>
            <pubDate>Thu, 24 Sep 2015 00:25:44 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-09-24-php-exit-die/</guid>
            <description>今天有小伙伴说 exit 和 die 有一点差别。我说 die 不就是 exit 的别名吗？为了证明我的观点，翻了翻 PHP 的源码，在 zend_language_scanner.l 中，很容易就能发现这关键字是同一个 token：
&amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;exit&amp;#34; { return T_EXIT; } &amp;lt;ST_IN_SCRIPTING&amp;gt;&amp;#34;die&amp;#34; { return T_EXIT; } 所以最终也是同一个 Opcode：ZEND_EXIT。所以这两个关键字没有任何差别，这其实也没什么好说的。
我顺便提醒了小伙伴们一句：不要用 exit 输出整数。原因也很简单，在 PHP 官网的文档里就能看到：
 void exit ([ string $status ] )
void exit ( int $status )
如果 status 是一个字符串，在退出之前该函数会打印 status 。
如果 status 是一个 integer，该值会作为退出状态码，并且不会被打印输出。 退出状态码应该在范围0至254，不应使用被PHP保留的退出状态码255。 状态码0用于成功中止程序。
 所以如果 status 是一个整数，会被当成状态码输出，而不是打印，所以如果想返回给前端是不可能的。
那么这个状态码有什么用呢？
大家都知道 shell 脚本执行可以返回一个状态码，PHP 的脚本的执行返回的状态码是一样的，可以在环境变量中被捕捉到：
Scholer: ~ $ php -r &amp;#39;exit(254);&amp;#39; Scholer: ~ $ echo $?</description>
            <content type="html"><![CDATA[<p>今天有小伙伴说 exit 和 die 有一点差别。我说 die 不就是 exit 的别名吗？为了证明我的观点，翻了翻 PHP 的源码，在 <code>zend_language_scanner.l</code> 中，很容易就能发现这关键字是同一个 token：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="o">&lt;</span><span class="n">ST_IN_SCRIPTING</span><span class="o">&gt;</span><span class="s">&#34;exit&#34;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">T_EXIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">&lt;</span><span class="n">ST_IN_SCRIPTING</span><span class="o">&gt;</span><span class="s">&#34;die&#34;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">T_EXIT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>所以最终也是同一个 Opcode：ZEND_EXIT。所以这两个关键字没有任何差别，这其实也没什么好说的。</p>
<p>我顺便提醒了小伙伴们一句：不要用 exit 输出整数。原因也很简单，在 PHP 官网的文档里就能看到：</p>
<blockquote>
<p>void <strong>exit</strong> ([ string <code>$status</code> ] )</p>
<p>void <strong>exit</strong> ( int <code>$status</code> )</p>
<p>如果 <code>status</code> 是一个字符串，在退出之前该函数会打印 <code>status</code> 。</p>
<p>如果 <code>status</code> 是一个 <a href="http://php.net/manual/zh/language.types.integer.php">integer</a>，该值会作为退出状态码，并且不会被打印输出。 退出状态码应该在范围0至254，不应使用被PHP保留的退出状态码255。 状态码0用于成功中止程序。</p>
</blockquote>
<p>所以如果 status 是一个整数，会被当成状态码输出，而不是打印，所以如果想返回给前端是不可能的。</p>
<p>那么这个状态码有什么用呢？</p>
<p>大家都知道 shell 脚本执行可以返回一个状态码，PHP 的脚本的执行返回的状态码是一样的，可以在环境变量中被捕捉到：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Scholer: ~ $ php -r <span class="s1">&#39;exit(254);&#39;</span>

Scholer: ~ $ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">254</span>
</code></pre></div><p>我的好奇心又被勾起来了：如果给的是不在 0 ~ 255 之间的状态码会怎么样呢？经过测试，发现如果是大于 255 的状态码，会返回 status 对 256 求余之后的结果。如果是小于 0 的，在 -1 ~ - 255 之间时返回的是 status 256 求和的结果，小于 -256 的则是绝对值和 256 求余。总之都在 0 ~ 255 之间。</p>
<p>接着探究下去。</p>
<p>exit 的实现在 zend_vm_def.h 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">ZEND_VM_HANDLER</span><span class="p">(</span><span class="mi">79</span><span class="p">,</span> <span class="n">ZEND_EXIT</span><span class="p">,</span> <span class="n">CONST</span><span class="o">|</span><span class="n">TMP</span><span class="o">|</span><span class="n">VAR</span><span class="o">|</span><span class="n">UNUSED</span><span class="o">|</span><span class="n">CV</span><span class="p">,</span> <span class="n">ANY</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if !defined(ZEND_VM_SPEC) || (OP1_TYPE != IS_UNUSED)
</span><span class="cp"></span>	<span class="n">USE_OPLINE</span>

	<span class="n">SAVE_OPLINE</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OP1_TYPE</span> <span class="o">!=</span> <span class="n">IS_UNUSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zend_free_op</span> <span class="n">free_op1</span><span class="p">;</span>
		<span class="n">zval</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">GET_OP1_ZVAL_PTR</span><span class="p">(</span><span class="n">BP_VAR_R</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">IS_LONG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">EG</span><span class="p">(</span><span class="n">exit_status</span><span class="p">)</span> <span class="o">=</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">zend_print_variable</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">FREE_OP1</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div><p>从代码中我们可以很明显的看出来通过 <code>Z_TYPE_P</code> 来检测状态码的类型，如果是 long 的话就赋值给全局变量 <code>exit_status</code>（EG 这个宏就是用来便捷的访问全局变量的），如果不是，就调用 <code>zend_print_variable</code> 打印出来。</p>
<p><code>Z_LVAL_P</code> 的声明在 zend_operators.h 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define Z_LVAL_P(zval_p)		Z_LVAL(*zval_p)
</span><span class="cp"></span><span class="p">...</span>
<span class="cp">#define Z_LVAL(zval)			(zval).value.lval
</span></code></pre></div><p>再进一步就是大家都知道的 PHP 解释器中的变量定义了（我这份源码还是 PHP 5.5 的版本，不是 PHP7），在 zend.h 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">union</span> <span class="n">_zvalue_value</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">lval</span><span class="p">;</span>					<span class="cm">/* long value */</span>
	<span class="kt">double</span> <span class="n">dval</span><span class="p">;</span>				<span class="cm">/* double value */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">str</span><span class="p">;</span>
	<span class="n">HashTable</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>				<span class="cm">/* hash table value */</span>
	<span class="n">zend_object_value</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zvalue_value</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_zval_struct</span> <span class="p">{</span>
	<span class="cm">/* Variable information */</span>
	<span class="n">zvalue_value</span> <span class="n">value</span><span class="p">;</span>		<span class="cm">/* value */</span>
	<span class="n">zend_uint</span> <span class="n">refcount__gc</span><span class="p">;</span>
	<span class="n">zend_uchar</span> <span class="n">type</span><span class="p">;</span>	<span class="cm">/* active type */</span>
	<span class="n">zend_uchar</span> <span class="n">is_ref__gc</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>所以这里 <code>exit_status</code> 的值到这里还是一个长整形。</p>
<p>那么问题就来了，为什么最终输出的是 0 ~ 255 之间的状态码呢？老实说这个问题我吃的也不是很透，这需要对 Linux 环境编程足够熟悉才行，这里只能简单的说一下。</p>
<p>通过 strace 跟踪一下执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ strace php -r <span class="s1">&#39;exit(258);&#39;</span> &gt;<span class="p">&amp;</span> strace.log
</code></pre></div><p>在结果的最后两行可以很清楚的看到：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">...
exit_group<span class="o">(</span>258<span class="o">)</span>                         <span class="o">=</span> ?
+++ exited with <span class="m">2</span> +++
</code></pre></div><p>exit_group 中还是原始值，但最终会变成 2 。PHP 本身并没有对这个值做特殊处理，但是 exit 或者 main 函数中的 return，只能使用 0 ~ 255 之间的值，其他值都会被处理。可以写一个简单的程序测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">258</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Scholer: ~ $ ./test

Scholer: ~ $ <span class="nb">echo</span> <span class="nv">$?</span>
<span class="m">2</span>
</code></pre></div><p>详情参见：<a href="http://www.laruence.com/2012/02/01/2503.html">http://www.laruence.com/2012/02/01/2503.html</a></p>
]]></content>
        </item>
        
        <item>
            <title>Python 版 APM 服务使用测试</title>
            <link>http://0x1.im/posts/2015-09-06-tingyun-probe-for-python/</link>
            <pubDate>Sun, 06 Sep 2015 11:40:24 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-09-06-tingyun-probe-for-python/</guid>
            <description>后端开发与云服务 云服务这个词，大概最早是从云盘开始的，那时候概念也特别简单，无非就是把一些数据存在别人的服务器上，在”云存储”这个名词火起来之前，QQ 也有提供网站的功能用来存一些小东西（05年06年的样子，那时候大概只有几十 M 的空间），其实刚听到这个概念的时候我就很不理解，光存存东西不至于吹得这么玄乎吧。毕业后入行，云服务器才慢慢真真的丰富起来，从最开始的 VPS 变成云服务器、存储变成资源服务器、远程数据库等等，现在甚至有帮你防 DDOS 的服务（去年和今年貌似 DDOS 变得越来越没有节操了）。确实节省了很多精力，也省钱。
除了云，最近几年还有另外一个比较火的词：&amp;ldquo;大数据”。我没接触过那么大的数据，作为一个半吊子运维，接触的最大的数据应该就是服务器 log 了。所以大数据的东西以后有机会接触再说，对我来说更重要的是 — 数据统计。
服务端的各种 log 不仅是分析服务器的状态的重要参数，也是从后台代码里抓 bug 抓异常检查 SQL 性能等各种工作的参考。log 数据一般都是单调而且重复的居多，要发现它的价值，往往需要大量的分析和统计工作。各种监控服务、分析工具也是层出不穷。不过到今年我才知道有个词叫 &amp;ldquo;APM&amp;rdquo;。
APM (Application Performance Management/Monitoring) 简单翻译过来就是&amp;quot;应用性能管理/监控”(也许说监控更准确一些)。大概就是服务器上部署的 awstats、nagios、zabbix 等一堆东西的集合。有服务器的地方就有云，既然这个事情这么麻烦，那就自然也可以交给别人来做了。
前几天找到了一个 Python 的小 web 框架：bottle，只有一个文件，简洁好用，觉得很不错，先是用它来做了一个简单的小应用（APP 下载，公司内部使用），准备这段时间尝试用它来自己写一个简单的博客系统，改造一下自己的博客，所以业务时间花在搞 Python 上的比较多一点。恰好看到了在测 Python 版本的探针，于是部署来测试一下。部署之前先在本地做了一些测试，不过听云目前仅支持基于 django 开发的程序（文档上写的目标是支持所有以 wsgi 协议部署的 Python Web 服务，包括 flask、tornado 等等，不过这个应该还要等后续开发支持了），所以我就先在本地用 django 测了一下。
听云探针(Python版)的使用 探针部署过程十分简单，在听云后台复制自己账户的 license key，生成配置文件，将配置文件地址加载到环境变量中，就可以启动程序开始使用了。以下是测试环境部署步骤的介绍。
先用 virtualenv 开辟一个环境并 active 之：
virtualenv tingyun cd tingyun source bin/active 听云探针在 pypi 的仓库里有，所以可以直接安装了，同时也安装 django , 探针支持 MySQL 的 log 记录，所以我也安装了 MySQL 的组件并将 django 的数据库从 sqlite 改成 MySQL：</description>
            <content type="html"><![CDATA[<h2 id="后端开发与云服务">后端开发与云服务</h2>
<p>云服务这个词，大概最早是从云盘开始的，那时候概念也特别简单，无非就是把一些数据存在别人的服务器上，在”云存储”这个名词火起来之前，QQ 也有提供网站的功能用来存一些小东西（05年06年的样子，那时候大概只有几十 M 的空间），其实刚听到这个概念的时候我就很不理解，光存存东西不至于吹得这么玄乎吧。毕业后入行，云服务器才慢慢真真的丰富起来，从最开始的 VPS 变成云服务器、存储变成资源服务器、远程数据库等等，现在甚至有帮你防 DDOS 的服务（去年和今年貌似 DDOS 变得越来越没有节操了）。确实节省了很多精力，也省钱。</p>
<p>除了云，最近几年还有另外一个比较火的词：&ldquo;大数据”。我没接触过那么大的数据，作为一个半吊子运维，接触的最大的数据应该就是服务器 log 了。所以大数据的东西以后有机会接触再说，对我来说更重要的是 — <strong>数据统计</strong>。</p>
<p>服务端的各种 log 不仅是分析服务器的状态的重要参数，也是从后台代码里抓 bug 抓异常检查 SQL 性能等各种工作的参考。log 数据一般都是单调而且重复的居多，要发现它的价值，往往需要大量的分析和统计工作。各种监控服务、分析工具也是层出不穷。不过到今年我才知道有个词叫 &ldquo;APM&rdquo;。</p>
<p>APM (Application Performance Management/Monitoring) 简单翻译过来就是&quot;应用性能管理/监控”(也许说监控更准确一些)。大概就是服务器上部署的 awstats、nagios、zabbix 等一堆东西的集合。有服务器的地方就有云，既然这个事情这么麻烦，那就自然也可以交给别人来做了。</p>
<p>前几天找到了一个 Python 的小 web 框架：<a href="http://bottlepy.org/">bottle</a>，只有一个文件，简洁好用，觉得很不错，先是用它来做了一个简单的小应用（APP 下载，公司内部使用），准备这段时间尝试用它来自己写一个简单的博客系统，改造一下自己的博客，所以业务时间花在搞 Python 上的比较多一点。恰好看到了在测 Python 版本的探针，于是部署来测试一下。部署之前先在本地做了一些测试，不过听云目前仅支持基于 django 开发的程序（文档上写的目标是支持所有以 wsgi 协议部署的 Python Web 服务，包括 flask、tornado 等等，不过这个应该还要等后续开发支持了），所以我就先在本地用 django 测了一下。</p>
<h2 id="听云探针python版的使用">听云探针(Python版)的使用</h2>
<p>探针部署过程十分简单，在听云后台复制自己账户的 license key，生成配置文件，将配置文件地址加载到环境变量中，就可以启动程序开始使用了。以下是测试环境部署步骤的介绍。</p>
<p>先用 virtualenv 开辟一个环境并 active 之：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">virtualenv tingyun
<span class="nb">cd</span> tingyun
<span class="nb">source</span> bin/active
</code></pre></div><p>听云探针在 pypi 的仓库里有，所以可以直接安装了，同时也安装 django , 探针支持 MySQL 的 log 记录，所以我也安装了 MySQL 的组件并将 django 的数据库从 sqlite 改成 MySQL：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 安装组件</span>
pip install tingyun django MySQL-python
<span class="c1"># 创建一个 django 工程</span>
django-admin startproject www
</code></pre></div><p>接着需要修改一下 django 的数据库选项，进入到 www/www 目录，打开 settings.py，找到 DATABASE 的字典，注释掉原有的 sqlite 选项并改为 MySQL：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># &#39;default&#39;: {</span>
<span class="c1">#     &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,</span>
<span class="c1">#     &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),</span>
<span class="c1"># }</span>
<span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s1">&#39;ENGINE&#39;</span><span class="p">:</span> <span class="s1">&#39;django.db.backends.mysql&#39;</span><span class="p">,</span>
    <span class="s1">&#39;NAME&#39;</span><span class="p">:</span> <span class="s1">&#39;django&#39;</span><span class="p">,</span>
    <span class="s1">&#39;USER&#39;</span><span class="p">:</span> <span class="s1">&#39;root&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PASSWORD&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;HOST&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PORT&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>在 MySQL 中创建 django 的库，然后安装 django 的 admin 后台需要的数据表（注意回到 manage.py 所在的目录）：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">python manage.py syncdb
</code></pre></div><p>接下来设置听云的服务，按照听云后台的提示和文档说明进行就可以了：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># YourLicenseKey 是你的听云后台里显示的 key</span>
<span class="c1"># 听云后台里将 tingyun.ini 放置在 tmp 目录，我建议你放在当前工作目录，免得丢失</span>
<span class="c1"># 一些配置参数可以打开 tingyun.ini 进行修改</span>
tingyun-admin generate-config YourLicenseKey tingyun.ini
#
<span class="c1"># 这里的 TING_YUN_CONFIG_FILE 写绝对路径比较保险，以下是我本地的目录</span>
<span class="c1"># 如果是在服务器上，可以写入到 .bashrc 或者 .bash_profile 中去，需要重启服务时不用重新设置</span>
<span class="nb">export</span> <span class="nv">TING_YUN_CONFIG_FILE</span><span class="o">=</span>/Users/Scholer/Work/Personal/tingyun/tingyun.ini
#
<span class="c1"># 听云的服务会读取当前环境变量的参数 TING_YUN_CONFIG_FILE 来获取配置文件</span>
<span class="c1"># 我们可以先检查一下，如果看到 success 字样就 OK</span>
tingyun-admin check-config
</code></pre></div><p>万事具备，可以启动服务了：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">tingyun-admin run-program python www/manage.py runserver
</code></pre></div><p>接下来我们就可以浏览一下页面，登录一下后台等等生成一些访问记录来看看效果了（或者可以比较残暴一点用测试工具，我用 <a href="http://httpd.apache.org/docs/2.0/programs/ab.html">ab</a> 发了一些的测试请求）。</p>
<p>一切顺利的话，过一会儿刷新一下听云的后台，就能看到一些数据了。</p>
<p>有一些事情需要注意一下：</p>
<ol>
<li>听云的多个应用是同一个 key，通过应用名称来区分应用；</li>
<li>不同于一些其他服务、听云没有新建一个 应用的过程，有部署、上报的数据就能看到数据了；</li>
<li>如果使用 uwsgi 的方式不是，需要开启 <code>enable-threads</code> 和 <code>single-interpreter</code> 的选项。</li>
</ol>
<h2 id="上报数据观察">上报数据观察</h2>
<p>登录到听云的后台管理面板就能查看到一些监控日志分析了（图表是用 highcharts 做的，体验相当不错）。</p>
<p><img src="/assets/tingyun-pic/14.png" alt="预览"></p>
<p>图中可以看到一些基本的数据图表，包括应用的响应时间、Apdex（应用程序性能指数），应用响应耗时和吞吐率等等。</p>
<p>此外面板上也会有硬件的基本信息，包括 CPU 的占用时间、内存占用等参数。</p>
<p>各项参数指标的统计最终目的都是为了分析服务器本身的承载能力和性能。当以上参数出现异常情况，比如响应时间过长、CPU负载过高或者内存剩余不多时，就要考虑升级硬件资源或者对程序进行优化了。</p>
<p><img src="/assets/tingyun-pic/4.png" alt="4"></p>
<p>Apdex (Application Performance Index) ，应用性能指数。这是一个近几年成立的联盟组织，大概是在 2010 年发起的，12 年之后沉寂了两年，去年又开始活跃了。这个联盟意在通过一个统一的标准来计算和衡量应用程序的的性能，在它的 <a href="http://www.apdex.org">官网</a> 中有一些专门的文章来介绍自己。</p>
<p>&ldquo;Apdex is a way to study measurements of any experience that can be interpreted on a scale ranging from excellent to unacceptable. &quot;
（Apdex 用以学习解释从好到坏的评级标准的相关经验。）</p>
<p>Apdex 的计算在下面这篇文章用也有介绍：</p>
<pre><code>Apdex = (正常样本 + 0.5 x 低质样本 + 0 x 高质样本) / 样本总量
</code></pre>
<p>我们可以这样把正常样本理解成正常的时间，低质和高质就分别表示响应的慢和快。显然计算结果从 1 到 0 就表示从好到坏。</p>
<p>详细介绍：<a href="http://www.apdex.org/index.php/2014/05/apdex-is-not-just-for-application-performance/">http://www.apdex.org/index.php/2014/05/apdex-is-not-just-for-application-performance/</a></p>
<p><img src="/assets/tingyun-pic/2.png" alt="2"></p>
<p><img src="/assets/tingyun-pic/3.png" alt="3"></p>
<p>以上两张统计图分别展示了应用层的处理时间与数据库调用时间。这两个参数是对程序和 SQL 语句进行优化的重要参考。这里应该是计算的平均时间。</p>
<p>在实际的分析过程中，我们也同样需要对于所有耗时过长的处理或者 SQL 慢查询进行分析和优化。听云也提供了对于耗时应用和 SQL 的统计。</p>
<p><img src="/assets/tingyun-pic/9.png" alt="9"></p>
<p><img src="/assets/tingyun-pic/11.png" alt="11"></p>
<p>在上面的&quot;最耗时的应用过程&quot;中，有一个<strong>墙钟时间比</strong>的概念。墙钟时间（Wall-clock time / wall time）指的是程序从开始执行到结束的过程中人的时间感知（这个时间是大于 CPU 时间的，由系统提供）。墙钟时间比就表示当前时间点下某个程序占总墙钟时间的百分比。</p>
<p>除了常见关系型数据库的监控，听云也提供了对 memcached、Redis、MongoDB 等非关系型数据库的监控和统计。</p>
<p><img src="/assets/tingyun-pic/10.png" alt="10"></p>
<p>响应率和吞吐率参数参数。吞吐率指的是单位时间内响应的数量。这两个参数是对网站总体的响应速度和承载能力的评估。</p>
<p><img src="/assets/tingyun-pic/8.png" alt="8"></p>
<p>吞吐量、响应时间、Apdex和错误率的概览。</p>
<p>听云后台的参数记录十分全面，从硬件基础到程序响应到数据库执行耗时都有完整的分析和记录。不过遗憾的是在后台没有看到 HTTP 状态码的记录，类似 awstats 提供的记录和统计功能。不过相对于一个需要自己做复杂的配置的开源组件，优势还是十分明显的。我也相信随着时间的推移，服务会越来越丰富，这些信息都会被记录并分析出来。</p>
<h2 id="简析">简析</h2>
<p>部署和数据分析都说了，现在也可以简单的来分析下听云是如何运作的。我无意去弄清楚探针工作的每一个步骤，但却可以了解一下大致的流程。</p>
<p>Python 作为一门胶水语言，已经积淀了丰富的优秀模块，历来都是被公认为作为服务端运维最强力的脚本语言，对于这类问题的处理上，具有天然的优势。听云在语言上也做了处理，能够同时支持 Python 2 和 Python 3。</p>
<p>在听云的配置文件 tingyun.ini 中，除了有 <code>license_key</code> 以外，还有 <code>app_name</code>、 <code>log_file</code> 、 <code>log_level</code> 等参数配置。其中 <code>action_tracer.log_sql</code> 可以选择是否将 SQL 日志只保存在本地文件中（这应该是出于安全考虑，毕竟把所有的 SQL 日志都暴漏给服务平台，有些人可能会有些顾虑。但是考虑到现在服务器一般都是云服务器，所以这其实问题也并不大，选择了服务，就应该相信服务），这点听云考虑的很周到。</p>
<p>log 文件中记录了一些 trace 的log，包括程序耗时等。</p>
<p>回到程序本身中去，在启动探针的时，我们执行的是 <code>tingyun run-program</code>，最终执行的是听云的 package 中 admin 目录下的  <code>run_program</code> 的函数，<code>check_config</code>、<code>generate_config</code> 也位于 admin 目录下。整个程序目录还包括 bootstrap 、hook 和 api 目录。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">root_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">root_directory</span><span class="p">)</span>
<span class="n">boot_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">)</span>
<span class="n">python_path</span> <span class="o">=</span> <span class="n">boot_directory</span>
</code></pre></div><p><code>run_program</code> 将 bootstrap 目录加入系统 path 中。通过 Python 提供的两个 hook（sitecustomize 和 usercustomize 之中的 sitecustomize，听云探针正式被加载到运行环境中：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">config_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># When installed as an egg with buildout, the root directory for</span>
    <span class="c1"># packages is not listed in sys.path and scripts instead set it</span>
    <span class="c1"># after Python has started up. This will cause importing of</span>
    <span class="c1"># &#39;tingyun&#39; module to fail.</span>

    <span class="k">if</span> <span class="n">root_directory</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root_directory</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">tingyun.agent</span>

    <span class="c1"># Finally initialize the agent.</span>
    <span class="n">tingyun</span><span class="o">.</span><span class="n">agent</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">config_file</span><span class="o">=</span><span class="n">config_file</span><span class="p">)</span>
</code></pre></div><p>在 <code>tingyun.api.initial.config</code> 中，<code>initialize</code> 函数被执行，调用 <code>_process_module_builtin</code> 函数，探针开始工作 ：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">_load_configuration</span><span class="p">(</span><span class="n">config_file</span><span class="o">=</span><span class="n">config_file</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">_detect_done</span><span class="p">:</span>
    <span class="n">_detect_done</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">_process_module_builtin</span><span class="p">()</span>
</code></pre></div><p>MySQL、Redis 等监控模块都位于 hook 目录下，通过 <code>_process_module_definition_wrapper</code> 函数将进程与监控模块进行绑定，包括 django 的主要模块以及常用的数据库等。在核心模块执行的时候触发监控，将数据回传到 <code>api.tracert</code> 模块进行处理。</p>
<p>而对于硬件信息的检测则由 <code>api.platform.system_info</code> 进行。</p>
<p>应用监控数据最终会由 <code>api.tracert.uploader</code> 上传到听云的服务器（host 的设置位于 <code>api.settings</code> 中，host 地址是 <a href="http://redirect.networkbench.com">redirect.networkbench.com</a>，所以看到你的服务器往这个域名发送请求时，不要觉得奇怪），通过听云的处理，我们就能看到应用程序的各种监控数据了。</p>
<p>对听云探针的简单分析就到这里，有兴趣的读者可以进一步深入研究。其实对于这类云服务，程序的本身都是透明的，不用有太大的安全顾虑，对于服务提供方而言，更重要的是数据的分析工作。</p>
<p>听云本身提供的服务器是非常优秀的，虽然目前还并非完美。我也期待服务能更加完善，提供更完善的数据分析。另外一方面，通过 <code>tingyun-admin run-program</code> 的方式启动程序，对开发者和服务器管理员来说可能有些侵入感。如果能用模块加载的方式调用，或许更符合某些开发者的习惯。</p>
]]></content>
        </item>
        
        <item>
            <title>2015年5月 ~ 6月离职求职历程</title>
            <link>http://0x1.im/posts/2015-06-15-find-a-new-job/</link>
            <pubDate>Mon, 15 Jun 2015 18:26:32 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-06-15-find-a-new-job/</guid>
            <description>起因 其实有离职的想法是去年十一月的事情，但是有点舍不得，四月份的时候我还说再看一看，再呆一年，但是后来实在忍不住了。
历程   5.17（周日） 找了房子，但是感觉不是特别喜欢，给房东交了200块钱押金，晚上请两个朋友吃饭，喝了点酒，回来之后决定离职。
  5.18（周一）跟以前在腾讯的师兄聊了一下，他说可以换个环境试试看。发了一份之前整理的技能表给他，他表示可以。下午下班之后跟老板聊了下，表达了离职的意愿，他说让我再考虑下，六月份我们再聊一次。跟师兄说已经提出了口头离职，师兄说要不要让他们负责人跟我联系一下，我说行。晚上回来之后整理一份简单的简历，就是最初的技能列表加上简单的项目经理，在拉勾上分别投了腾讯和杭州的某街。
  5.19（周二）腾讯接收简历，一个大哥提醒我再修改下，项目经历丰富下。某街拒了我的简历，女朋友看了下说你看别人是要数据挖掘的，你肯定不懂这个（哈哈，我说好像是，她可有成就感了，因为她根本不懂我们这个行业）。晚上腾讯的另外一个大哥联系我进行了第一次远程面试，从十一点半到一点钟。一些基本的问题，然后问了三个比较浅的技术问题，我基本上都在一分钟之内给出了答案。最后问了下git的使用、了不了解node之类的（他告诉我他们是一个前端团队，招人是进去和运营那边沟通，是这边的人，做那边的工作），然后说没什么问题，让我等待下一轮技术面试。三个问题是：
 举例说明多对多的应用场景（我说了用户和标签的例子） 在这种应用场景下，获取某标签的全部用户，写出SQL语句 说明MVC的流程和关系，Router的作用    5.21（周四）腾讯这边的人跟我说这两天电话保持畅通，应该这两天会有电话面试。
  5.22（周五）我问师兄需不需要再发一份完整的简历给他，他说不用，他已经把我发给他的md格式的文档转成pdf了，负责人会电话我的，这两天可能比较忙。同天我跟室友商量了下我们再租一个月（室友硕士毕业，要离开武汉了），跟现在的房东说了下，房东阿姨表示同意（住了近两年，好说话）。然后告诉新房子的房东，说不租了，押金不要了。
  5.23 （周六）焦急的等待着两个电话。白天看了下node.js的express框架，晚上又优化了下简历上技能列表的格式，取名简历2.0，直接把markdown格式的文档上传到了jobdeer。我之所以没有继续在拉勾上投简历，是因为我想等师兄这边和腾讯这两个电话结束之后再进行下一轮，时间上我并不是特别着急，因为理论上只要在6月底之前找到新工作就好了。
  5.24（周日）等待中，开始整理这一份求职历程文档，同时继续看express的文档。。。
  5.25（周一）jobdeer审核简历通过，排期在29号。但是下午四点多接到jobdeer这边的电话，核对了下资料，说明天上午就可以开始竞拍了。晚上问了腾讯这边的大哥，说他已经催了，再等两天，技术面那边的人比较忙。
  5.26（周二）十点半简历在jobdeer上上线，到十一点半收到了七个查看简历的请求，其中居然蘑菇街有两个（不过为什么发来的介绍里面写的是招java？私信问了下说PHP也招），其他的还有房多多、贝贝网。腾讯这边的大哥联系我问我有没有漏接电话，我说没有。重新确认了一下联系方式，过一会儿腾讯来电话，约在晚上七点电话面试。莫名其妙的接了一个分期乐的电话，说是在论坛上看到的我的电话，我只在两个地方留过联系方式，一个是拉勾，一个是jobdeer，所以肯定有一家有信息泄露。jobdeer这边贝贝网是第一个发起面试邀约的。定在后天晚上七点之后电话聊一下。晚上下班回来，对面小区施工有点吵，我关上窗户给手机充电，静静的等待电话。电话准时打来，听声音是个中年大叔。问题很多，涉及的层面也很宽泛从304的含义到MyISAM和InnoDB的区别、Apache与Nginx，fastcgi，jQuery选择器等等。放下电话之后我有些释然了，虽然不是那么好，但至少也说明这两年时间我也不算是虚度了。以下三个问题没答好：
 闭包（我当时把闭包和匿名函数搞混了） MySQL联合索引（这个是真正说错了，我居然说成了跨表……） 集合模式（他把继承和集合放在一起说的，我没反应过来集合是什么，不就是一个类里面套多个其他类的实例么……）    5.27（周三）师兄这边公司在十一点打来电话。问了一些PHP和Linux方面的问题，偏底层，有些我没有答上来。最后我也征求了一些建议。说有空的话可能还是需要到深圳见面聊聊，我说可以。
  5.28（周四）贝贝网面试电话，果然技术深度还是不一样，问了php数组排序有哪些函数、Linux常用的有那些命令，以及对CI了不了解。
  5.31（周日）蘑菇街又来电话，说再考察下技能。可是总感觉蘑菇街问的问题都不在点子上。
  6.1（周一）贝贝网又电话来问什么时候能去面谈。
  6.2（周二）师兄的公司约周六面谈，订了到深圳的机票。
  6.3（周三）腾讯通知：第一轮过了，等第二轮。晚上腾讯打来电话，问了一些比较宽泛的问题，我说的不是很好，一个是为什么用redis比mysql快（这个大概是因为一个是kv数据库是hash存储，查询快，类似PHP的HashTable，再一个redis自己实现的事件事件分离器，非阻塞式的异步IO），一个是nginx为什么比apache更快（大概是因为事件驱动（epoll）、异步IO，事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务）。说还是想面谈一下，我说周六到深圳，那就约在周一吧。
  6.6（周六）早晨五点四十起床，地铁到长岗路然后坐用去哪儿叫的专车，110块到了机场。十点半到深圳，十一点坐上机场8线，十一点半到科兴科学园，先去吃了个午饭，到了公司，显示负责人聊一下，然后技术总监，然后HR。然后我到酒店，在路上offer邮件就来了，还比较顺利。
  6.7（周日）在酒店，查了些可能会问到的知识点。快到中午的时候出去了一趟，去企鹅大厦楼下和深圳大学看了看，天气太热，回来了。想了想自己上学、工作之类的事情。
  6.8（周一）早晨深圳的公交上的人简直太多了，等了一会儿决定步行，差不多八点二十开始走，九点十分左右到科兴，在C栋楼下喝了一杯鲜榨橙汁。九点半准时给联系人打电话，告诉我可以上去。上去之后他告诉我今天上午是总监面试，然后我们先聊了一会儿。具体也没有什么细节上的技术问题，都是问个人的基本情况，这些年收获了些什么之类了。过了一会儿总监来了，也是问了些类似的问题，甚至包括运不运动，一周运动几次。大概前后一个小时的时间就结束了，然后我下楼等了一会儿，吃了个饭，就坐上公交去了深圳北站。火车站人真的好多。
  6.</description>
            <content type="html"><![CDATA[<h2 id="起因">起因</h2>
<p>其实有离职的想法是去年十一月的事情，但是有点舍不得，四月份的时候我还说再看一看，再呆一年，但是后来实在忍不住了。</p>
<h2 id="历程">历程</h2>
<ul>
<li>
<p>5.17（周日） 找了房子，但是感觉不是特别喜欢，给房东交了200块钱押金，晚上请两个朋友吃饭，喝了点酒，回来之后决定离职。</p>
</li>
<li>
<p>5.18（周一）跟以前在腾讯的师兄聊了一下，他说可以换个环境试试看。发了一份之前整理的技能表给他，他表示可以。下午下班之后跟老板聊了下，表达了离职的意愿，他说让我再考虑下，六月份我们再聊一次。跟师兄说已经提出了口头离职，师兄说要不要让他们负责人跟我联系一下，我说行。晚上回来之后整理一份简单的简历，就是最初的技能列表加上简单的项目经理，在拉勾上分别投了腾讯和杭州的某街。</p>
</li>
<li>
<p>5.19（周二）腾讯接收简历，一个大哥提醒我再修改下，项目经历丰富下。某街拒了我的简历，女朋友看了下说你看别人是要数据挖掘的，你肯定不懂这个（哈哈，我说好像是，她可有成就感了，因为她根本不懂我们这个行业）。晚上腾讯的另外一个大哥联系我进行了第一次远程面试，从十一点半到一点钟。一些基本的问题，然后问了三个比较浅的技术问题，我基本上都在一分钟之内给出了答案。最后问了下git的使用、了不了解node之类的（他告诉我他们是一个前端团队，招人是进去和运营那边沟通，是这边的人，做那边的工作），然后说没什么问题，让我等待下一轮技术面试。三个问题是：</p>
<ol>
<li>举例说明多对多的应用场景（我说了用户和标签的例子）</li>
<li>在这种应用场景下，获取某标签的全部用户，写出SQL语句</li>
<li>说明MVC的流程和关系，Router的作用</li>
</ol>
</li>
<li>
<p>5.21（周四）腾讯这边的人跟我说这两天电话保持畅通，应该这两天会有电话面试。</p>
</li>
<li>
<p>5.22（周五）我问师兄需不需要再发一份完整的简历给他，他说不用，他已经把我发给他的md格式的文档转成pdf了，负责人会电话我的，这两天可能比较忙。同天我跟室友商量了下我们再租一个月（室友硕士毕业，要离开武汉了），跟现在的房东说了下，房东阿姨表示同意（住了近两年，好说话）。然后告诉新房子的房东，说不租了，押金不要了。</p>
</li>
<li>
<p>5.23 （周六）焦急的等待着两个电话。白天看了下node.js的express框架，晚上又优化了下简历上技能列表的格式，取名简历2.0，直接把markdown格式的文档上传到了jobdeer。我之所以没有继续在拉勾上投简历，是因为我想等师兄这边和腾讯这两个电话结束之后再进行下一轮，时间上我并不是特别着急，因为理论上只要在6月底之前找到新工作就好了。</p>
</li>
<li>
<p>5.24（周日）等待中，开始整理这一份求职历程文档，同时继续看express的文档。。。</p>
</li>
<li>
<p>5.25（周一）jobdeer审核简历通过，排期在29号。但是下午四点多接到jobdeer这边的电话，核对了下资料，说明天上午就可以开始竞拍了。晚上问了腾讯这边的大哥，说他已经催了，再等两天，技术面那边的人比较忙。</p>
</li>
<li>
<p>5.26（周二）十点半简历在jobdeer上上线，到十一点半收到了七个查看简历的请求，其中居然蘑菇街有两个（不过为什么发来的介绍里面写的是招java？私信问了下说PHP也招），其他的还有房多多、贝贝网。腾讯这边的大哥联系我问我有没有漏接电话，我说没有。重新确认了一下联系方式，过一会儿腾讯来电话，约在晚上七点电话面试。莫名其妙的接了一个分期乐的电话，说是在论坛上看到的我的电话，我只在两个地方留过联系方式，一个是拉勾，一个是jobdeer，所以肯定有一家有信息泄露。jobdeer这边贝贝网是第一个发起面试邀约的。定在后天晚上七点之后电话聊一下。晚上下班回来，对面小区施工有点吵，我关上窗户给手机充电，静静的等待电话。电话准时打来，听声音是个中年大叔。问题很多，涉及的层面也很宽泛从304的含义到MyISAM和InnoDB的区别、Apache与Nginx，fastcgi，jQuery选择器等等。放下电话之后我有些释然了，虽然不是那么好，但至少也说明这两年时间我也不算是虚度了。以下三个问题没答好：</p>
<ul>
<li>闭包（我当时把闭包和匿名函数搞混了）</li>
<li>MySQL联合索引（这个是真正说错了，我居然说成了跨表……）</li>
<li>集合模式（他把继承和集合放在一起说的，我没反应过来集合是什么，不就是一个类里面套多个其他类的实例么……）</li>
</ul>
</li>
<li>
<p>5.27（周三）师兄这边公司在十一点打来电话。问了一些PHP和Linux方面的问题，偏底层，有些我没有答上来。最后我也征求了一些建议。说有空的话可能还是需要到深圳见面聊聊，我说可以。</p>
</li>
<li>
<p>5.28（周四）贝贝网面试电话，果然技术深度还是不一样，问了php数组排序有哪些函数、Linux常用的有那些命令，以及对CI了不了解。</p>
</li>
<li>
<p>5.31（周日）蘑菇街又来电话，说再考察下技能。可是总感觉蘑菇街问的问题都不在点子上。</p>
</li>
<li>
<p>6.1（周一）贝贝网又电话来问什么时候能去面谈。</p>
</li>
<li>
<p>6.2（周二）师兄的公司约周六面谈，订了到深圳的机票。</p>
</li>
<li>
<p>6.3（周三）腾讯通知：第一轮过了，等第二轮。晚上腾讯打来电话，问了一些比较宽泛的问题，我说的不是很好，一个是为什么用redis比mysql快（这个大概是因为一个是kv数据库是hash存储，查询快，类似PHP的HashTable，再一个redis自己实现的事件事件分离器，非阻塞式的异步IO），一个是nginx为什么比apache更快（大概是因为事件驱动（epoll）、异步IO，事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务）。说还是想面谈一下，我说周六到深圳，那就约在周一吧。</p>
</li>
<li>
<p>6.6（周六）早晨五点四十起床，地铁到长岗路然后坐用去哪儿叫的专车，110块到了机场。十点半到深圳，十一点坐上机场8线，十一点半到科兴科学园，先去吃了个午饭，到了公司，显示负责人聊一下，然后技术总监，然后HR。然后我到酒店，在路上offer邮件就来了，还比较顺利。</p>
</li>
<li>
<p>6.7（周日）在酒店，查了些可能会问到的知识点。快到中午的时候出去了一趟，去企鹅大厦楼下和深圳大学看了看，天气太热，回来了。想了想自己上学、工作之类的事情。</p>
</li>
<li>
<p>6.8（周一）早晨深圳的公交上的人简直太多了，等了一会儿决定步行，差不多八点二十开始走，九点十分左右到科兴，在C栋楼下喝了一杯鲜榨橙汁。九点半准时给联系人打电话，告诉我可以上去。上去之后他告诉我今天上午是总监面试，然后我们先聊了一会儿。具体也没有什么细节上的技术问题，都是问个人的基本情况，这些年收获了些什么之类了。过了一会儿总监来了，也是问了些类似的问题，甚至包括运不运动，一周运动几次。大概前后一个小时的时间就结束了，然后我下楼等了一会儿，吃了个饭，就坐上公交去了深圳北站。火车站人真的好多。</p>
</li>
<li>
<p>6.11（周四）蘑菇街来电话希望我去面试，我告诉她我打算入职深圳的公司。</p>
</li>
<li>
<p>6.15（周一）问了下腾讯的人，说没过，原因是对项目流程和规范这块经验不是太足。有点遗憾，但是这也是实情，之前在和别的公司沟通的时候我也说过希望公司有完善的开发和管理流程，只是没想到这是我挂的理由。告诉富途的负责人和HR，会准时报到。</p>
</li>
</ul>
<h2 id="结语">结语</h2>
<p>从酝酿这件事情到花上句号，刚好一个月。</p>
<p>也许职场也是座围城。</p>
<p>也许会有遗憾，也许会遇到很多挑战，但我无怨无悔。</p>
]]></content>
        </item>
        
        <item>
            <title>使用Nginx 的 image filter 模块裁剪图片</title>
            <link>http://0x1.im/posts/2015-04-09-use-nginx-image-filter-module/</link>
            <pubDate>Thu, 09 Apr 2015 15:36:35 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-04-09-use-nginx-image-filter-module/</guid>
            <description>背景 项目中有个地方需要根据客户端的要求缩放图片。最开始想用PHP来实现这个功能。设想中如果已经存在图片a.jpg，则可以通过类似a_400x400.jpg的方式来获取图片特定尺寸的缩略图。
要实现此功能可以在图片上传的时候就事先裁好指定尺寸的图片，或者在获取的时候拦截请求来实现。
如果使用第一种方法，则只能实现裁剪好预设尺寸的图片，而且会影响到上传图片的效率，如果裁剪失败，也无法后续处理。
使用第二种方式的问题是图片资源存储在一个静态资源的目录，需要在没有图片的情况下将请求转发给PHP去处理。
于是我设想能否在Nginx这一层去做这件事情，恰好Nginx有一个image filter的模块，只不过在编译的时候默认没有编译进去。
手动添加参数编译此模块，开始修改nginx的配置文件。
配置 第一个版本的配置如下：
# 我使用16进制数的方式给图片重命名 location ~* /(.*)\/([0-9a-f]+)_(\d+)x(\d+)\.(jpg|png|jpeg|gif)$ { # 如果存在文件就终止规则 if (-f $request_filename) { break; } # 设定一些参数 set $filepath $1; set $filename &amp;#34;$2.$5&amp;#34;; set $thumb &amp;#34;$2_$3x$4.$5&amp;#34;; set $width $3; set $height $4; # 如果原文件不存在可以直接返回404 if (!-f $document_root/$filepath/$filename) { return 404; } # 重写URL rewrite /(.*)\/([0-9a-f]+)_([0-9x]+)\.(jpg|png|jpeg|gif) /$1/$2.$4 break; # 执行图片缩放 image_filter test; image_filter resize $width $height; image_filter_jpeg_quality 75; } 但是在这个版本的配置中，如果配置原文件不存在，实际上没法正确返回404，而是返回415。过滤还是执行了。
还有一个问题就是在每次访问缩略图的时候都会重新生成，如果访问量比较大的情况下，效率并不高。
进过一系列的实践后，我又改好了一个版本：</description>
            <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>项目中有个地方需要根据客户端的要求缩放图片。最开始想用PHP来实现这个功能。设想中如果已经存在图片<code>a.jpg</code>，则可以通过类似<code>a_400x400.jpg</code>的方式来获取图片特定尺寸的缩略图。</p>
<p>要实现此功能可以在图片上传的时候就事先裁好指定尺寸的图片，或者在获取的时候拦截请求来实现。</p>
<p>如果使用第一种方法，则只能实现裁剪好预设尺寸的图片，而且会影响到上传图片的效率，如果裁剪失败，也无法后续处理。</p>
<p>使用第二种方式的问题是图片资源存储在一个静态资源的目录，需要在没有图片的情况下将请求转发给PHP去处理。</p>
<p>于是我设想能否在Nginx这一层去做这件事情，恰好Nginx有一个image filter的模块，只不过在编译的时候默认没有编译进去。</p>
<p>手动添加参数编译此模块，开始修改nginx的配置文件。</p>
<h2 id="配置">配置</h2>
<p>第一个版本的配置如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 我使用16进制数的方式给图片重命名</span>
location ~* /<span class="o">(</span>.*<span class="o">)</span><span class="se">\/</span><span class="o">([</span>0-9a-f<span class="o">]</span>+<span class="o">)</span>_<span class="o">(</span><span class="se">\d</span>+<span class="o">)</span>x<span class="o">(</span><span class="se">\d</span>+<span class="o">)</span><span class="se">\.</span><span class="o">(</span>jpg<span class="p">|</span>png<span class="p">|</span>jpeg<span class="p">|</span>gif<span class="o">)</span>$ <span class="o">{</span>
    <span class="c1"># 如果存在文件就终止规则</span>
    <span class="k">if</span> <span class="o">(</span>-f <span class="nv">$request_filename</span><span class="o">)</span> <span class="o">{</span>
        break<span class="p">;</span>
    <span class="o">}</span>
    
    <span class="c1"># 设定一些参数</span>
    <span class="nb">set</span> <span class="nv">$filepath</span> <span class="nv">$1</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$filename</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">.</span><span class="nv">$5</span><span class="s2">&#34;</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$thumb</span>    <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">_</span><span class="nv">$3</span><span class="s2">x</span><span class="nv">$4</span><span class="s2">.</span><span class="nv">$5</span><span class="s2">&#34;</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$width</span>    <span class="nv">$3</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$height</span>   <span class="nv">$4</span><span class="p">;</span>
    
    <span class="c1"># 如果原文件不存在可以直接返回404</span>
    <span class="k">if</span> <span class="o">(</span>!-f <span class="nv">$document_root</span>/<span class="nv">$filepath</span>/<span class="nv">$filename</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> 404<span class="p">;</span>
    <span class="o">}</span>

    <span class="c1"># 重写URL</span>
    rewrite /<span class="o">(</span>.*<span class="o">)</span><span class="se">\/</span><span class="o">([</span>0-9a-f<span class="o">]</span>+<span class="o">)</span>_<span class="o">([</span>0-9x<span class="o">]</span>+<span class="o">)</span><span class="se">\.</span><span class="o">(</span>jpg<span class="p">|</span>png<span class="p">|</span>jpeg<span class="p">|</span>gif<span class="o">)</span> /<span class="nv">$1</span>/<span class="nv">$2</span>.<span class="nv">$4</span> break<span class="p">;</span>
    <span class="c1"># 执行图片缩放</span>
    image_filter test<span class="p">;</span>
    image_filter resize <span class="nv">$width</span> <span class="nv">$height</span><span class="p">;</span>
    image_filter_jpeg_quality 75<span class="p">;</span>
<span class="o">}</span>
</code></pre></div><p>但是在这个版本的配置中，如果配置原文件不存在，实际上没法正确返回404，而是返回415。过滤还是执行了。</p>
<p>还有一个问题就是在每次访问缩略图的时候都会重新生成，如果访问量比较大的情况下，效率并不高。</p>
<p>进过一系列的实践后，我又改好了一个版本：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">location ~* /<span class="o">(</span>.*<span class="o">)</span><span class="se">\/</span><span class="o">([</span>0-9a-f<span class="o">]</span>+<span class="o">)</span>_<span class="o">(</span><span class="se">\d</span>+<span class="o">)</span>x<span class="o">(</span><span class="se">\d</span>+<span class="o">)</span><span class="se">\.</span><span class="o">(</span>jpg<span class="p">|</span>png<span class="p">|</span>jpeg<span class="p">|</span>gif<span class="o">)</span>$ <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>-f <span class="nv">$request_filename</span><span class="o">)</span> <span class="o">{</span>
        break<span class="p">;</span>
    <span class="o">}</span>

    <span class="nb">set</span> <span class="nv">$filepath</span> <span class="nv">$1</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$filename</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">.</span><span class="nv">$5</span><span class="s2">&#34;</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$thumb</span>    <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">_</span><span class="nv">$3</span><span class="s2">x</span><span class="nv">$4</span><span class="s2">.</span><span class="nv">$5</span><span class="s2">&#34;</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$width</span>    <span class="nv">$3</span><span class="p">;</span>
    <span class="nb">set</span> <span class="nv">$height</span>   <span class="nv">$4</span><span class="p">;</span>

    <span class="k">if</span> <span class="o">(</span>!-f <span class="nv">$document_root</span>/<span class="nv">$filepath</span>/<span class="nv">$filename</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> 404<span class="p">;</span>
    <span class="o">}</span>

    rewrite /<span class="o">(</span>.*<span class="o">)</span><span class="se">\/</span><span class="o">([</span>0-9a-fx_<span class="o">]</span>+<span class="o">)</span><span class="se">\.</span><span class="o">(</span>.*<span class="o">)</span> /imgcache/<span class="nv">$2</span>.<span class="nv">$3</span><span class="p">;</span>

    <span class="k">if</span> <span class="o">(</span>!-f <span class="nv">$request_filename</span><span class="o">)</span> <span class="o">{</span>
        proxy_pass http://127.0.0.1:<span class="nv">$server_port</span>/image-resize/<span class="nv">$filepath</span>/<span class="nv">$filename</span>?width<span class="o">=</span><span class="nv">$width</span><span class="p">&amp;</span><span class="nv">height</span><span class="o">=</span><span class="nv">$height</span><span class="p">;</span>
        break<span class="p">;</span>
    <span class="o">}</span>

    proxy_store          <span class="nv">$document_root</span>/imgcache/<span class="nv">$thumb</span><span class="p">;</span>
    proxy_store_access   user:rw  group:rw  all:r<span class="p">;</span>
    proxy_set_header     Host <span class="nv">$host</span><span class="p">;</span>
<span class="o">}</span>

location /image-resize <span class="o">{</span>
    rewrite /<span class="o">(</span>image-resize<span class="o">)</span>/<span class="o">(</span>.*<span class="o">)</span> /<span class="nv">$2</span> break<span class="p">;</span>

    image_filter resize <span class="nv">$arg_width</span> <span class="nv">$arg_height</span><span class="p">;</span>
    image_filter_jpeg_quality 75<span class="p">;</span>

    allow 127.0.0.0/8<span class="p">;</span>
    deny all<span class="p">;</span>
<span class="o">}</span>
</code></pre></div><p>通过<code>proxy_pass</code>的方式解决415的问题，并通过<code>proxy_store</code>的方式将图片存到指定的目录（imgcache），在每次访问之前先进行判断。</p>
]]></content>
        </item>
        
        <item>
            <title>2014 年总结 &amp; 展望 2015</title>
            <link>http://0x1.im/posts/2015-01-17-summary-2014/</link>
            <pubDate>Sat, 17 Jan 2015 21:50:38 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2015-01-17-summary-2014/</guid>
            <description>2014 2014 年已经结束了；一个完整的工作年，也该对工作和生活做一些简单的总结了。
上半年基本上还是处于一种刚毕业找不到状态的感觉中，加上玩儿游戏时间过长的关系，在Coding 的道路上没什么长进。无非就是多了解下PHP，看看Python等。
新的电脑拿回来之后，稍微了解了一下WP的应用的结构，也算是对客户端APP的一个基础了解。对于后端开发有些促进作用。（现在又搞了本swift 的书看看iOS的。）
下半年的时间里游戏时间要少一些，可以总结的要多一些：
 在Linux 的道路上越走越远，使用越来越熟练，解决问题比较轻松； 去年是安全问题爆发的一年，也促使我安全方面的知识增加了了解，系统了解了Web 安全方面的问题； 在PHP 上，上手了Laravel，这是一个不错的框架，适合学习； 开始尝试看一些PHP 解释器的源码，尝试从C语言的角度理解PHP； 花了些时间多看了一些基础和底层的知识，偶尔了解一些其他的语言，通过比较增加见识；  这一年看过的一些书：
 C与指针 Linux程序设计 高可用MySQL：构建健壮的数据中心 深入浅出Windows Phone8应用开发 Swift语言实战入门  这里面没有一本PHP的书，但其实收获最多的还是PHP。（因为现在对我来说PHP重要的知识不是通过看书来的~）
过去的一年在技术上面对我来说最重要的两部分：PHP, Linux。
我对自己的对位：一个兼职运维的PHP程序员。
2015 2015 年，我希望自己能完成或者学习以下的技能：
 通过阅读Laravel的源码来理解它以及它的思想； 多阅读PHP解释器的代码； 写面向对象的代码，多理解一些设计模式； 我希望能做一个用swift的iOS应用； 我希望能在Github上发布一个有意义、写的不错的项目； 我希望在Linux上更精进一些；  Happy New Year!</description>
            <content type="html"><![CDATA[<h2 id="2014">2014</h2>
<p>2014 年已经结束了；一个完整的工作年，也该对工作和生活做一些简单的总结了。</p>
<p>上半年基本上还是处于一种刚毕业找不到状态的感觉中，加上玩儿游戏时间过长的关系，在Coding 的道路上没什么长进。无非就是多了解下PHP，看看Python等。</p>
<p>新的电脑拿回来之后，稍微了解了一下WP的应用的结构，也算是对客户端APP的一个基础了解。对于后端开发有些促进作用。（现在又搞了本swift 的书看看iOS的。）</p>
<p>下半年的时间里游戏时间要少一些，可以总结的要多一些：</p>
<ol>
<li>在Linux 的道路上越走越远，使用越来越熟练，解决问题比较轻松；</li>
<li>去年是安全问题爆发的一年，也促使我安全方面的知识增加了了解，系统了解了Web 安全方面的问题；</li>
<li>在PHP 上，上手了Laravel，这是一个不错的框架，适合学习；</li>
<li>开始尝试看一些PHP 解释器的源码，尝试从C语言的角度理解PHP；</li>
<li>花了些时间多看了一些基础和底层的知识，偶尔了解一些其他的语言，通过比较增加见识；</li>
</ol>
<p>这一年看过的一些书：</p>
<ol>
<li>C与指针</li>
<li>Linux程序设计</li>
<li>高可用MySQL：构建健壮的数据中心</li>
<li>深入浅出Windows Phone8应用开发</li>
<li>Swift语言实战入门</li>
</ol>
<p>这里面没有一本PHP的书，但其实收获最多的还是PHP。（因为现在对我来说PHP重要的知识不是通过看书来的~）</p>
<p>过去的一年在技术上面对我来说最重要的两部分：<strong>PHP</strong>, <strong>Linux</strong>。</p>
<p>我对自己的对位：一个兼职运维的PHP程序员。</p>
<h2 id="2015">2015</h2>
<p>2015 年，我希望自己能完成或者学习以下的技能：</p>
<ol>
<li>通过阅读Laravel的源码来理解它以及它的思想；</li>
<li>多阅读PHP解释器的代码；</li>
<li>写面向对象的代码，多理解一些设计模式；</li>
<li>我希望能做一个用swift的iOS应用；</li>
<li>我希望能在Github上发布一个有意义、写的不错的项目；</li>
<li>我希望在Linux上更精进一些；</li>
</ol>
<p>Happy New Year!</p>
]]></content>
        </item>
        
        <item>
            <title>开始学习和使用Laravel</title>
            <link>http://0x1.im/posts/2014-12-14-start-to-learn-laravel/</link>
            <pubDate>Sun, 14 Dec 2014 18:36:44 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-12-14-start-to-learn-laravel/</guid>
            <description>About Laravel Laravel是一个最近两年兴起的框架，在去年的PHP框架流行程度统计中居首，占据25.87%的份额。 Laravel是一个面向对象的PHP框架，大量运用了PHP5的特性。Laravel 4.0的版本需要在PHP 5.3.7 以上的环境中运行，而最新的4.2 版本则需要PHP 5.4以上的环境。 Laravel是一个重量级的框架，依赖于PHP社区中的现有标准、框架来实现。所以学习Laravel要先从以下几个项目和概念开始。
PSR PSR的全称是PHP Standard Recommendation (PHP标准推荐)，是由PHP-FIG (PHP Framework Interop Group) 创导并规定的，到目前一共发不过5个标准 (PSR-0 ~ PSR-4)。
PSR项目的github地址：https://github.com/php-fig/fig-standards 关于PSR的具体介绍可以参考：http://segmentfault.com/a/1190000000380008
PSR:
 PSR-0 自动加载 PSR-1 基本代码规范 PSR-2 代码样式 PSR-3 日志接口 PSR-4 autoloader, PSR-4可以替代PSR-0, 也可以和包括PSR-0在内的其他自动加载机制共同使用  Laravel 中并不直接使用到PSR，而是因为Laravel 使用了另外一个项目：Composer。
Composer Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。类似于Node.js的npm 和 Ruby的 bundler。
Packagist 是Composer 的主要资源库，默认的，Composer 只使用Packagist 仓库。通过指定仓库地址，你可以从任何地方获取包。
Composer支持PSR-0,PSR-4,classmap及files包含以支持文件自动加载。
Laravel 使用Composer 安装。安装完成后vendor 目录下得composer 目录下有autolad 文件，会根据项目需要加载的类生成classmap。在项目中只需要：
 require &amp;lsquo;vendor/autoload.php&amp;rsquo;;
 即可自动加载所有需要的类。
Composer 中文文档：http://docs.</description>
            <content type="html"><![CDATA[<h2 id="about-laravel">About Laravel</h2>
<p>Laravel是一个最近两年兴起的框架，在去年的PHP框架流行程度统计中居首，占据25.87%的份额。
<!-- raw HTML omitted -->
Laravel是一个面向对象的PHP框架，大量运用了PHP5的特性。Laravel 4.0的版本需要在PHP 5.3.7 以上的环境中运行，而最新的4.2 版本则需要PHP 5.4以上的环境。
<!-- raw HTML omitted -->
Laravel是一个重量级的框架，依赖于PHP社区中的现有标准、框架来实现。所以学习Laravel要先从以下几个项目和概念开始。</p>
<h2 id="psr">PSR</h2>
<p>PSR的全称是PHP Standard Recommendation (PHP标准推荐)，是由PHP-FIG (PHP Framework Interop Group) 创导并规定的，到目前一共发不过5个标准 (PSR-0 ~ PSR-4)。</p>
<p>PSR项目的github地址：<a href="https://github.com/php-fig/fig-standards">https://github.com/php-fig/fig-standards</a>
<!-- raw HTML omitted -->
关于PSR的具体介绍可以参考：<a href="http://segmentfault.com/a/1190000000380008">http://segmentfault.com/a/1190000000380008</a></p>
<p><strong>PSR:</strong></p>
<ul>
<li>PSR-0 自动加载</li>
<li>PSR-1 基本代码规范</li>
<li>PSR-2 代码样式</li>
<li>PSR-3 日志接口</li>
<li>PSR-4 autoloader, PSR-4可以替代PSR-0, 也可以和包括PSR-0在内的其他自动加载机制共同使用</li>
</ul>
<p>Laravel 中并不直接使用到PSR，而是因为Laravel 使用了另外一个项目：Composer。</p>
<h2 id="composer">Composer</h2>
<p>Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。类似于Node.js的npm 和 Ruby的 bundler。</p>
<p><a href="https://packagist.org/">Packagist</a> 是Composer 的主要资源库，默认的，Composer 只使用Packagist 仓库。通过指定仓库地址，你可以从任何地方获取包。</p>
<p>Composer支持PSR-0,PSR-4,classmap及files包含以支持文件自动加载。</p>
<p>Laravel 使用Composer 安装。安装完成后vendor 目录下得composer 目录下有autolad 文件，会根据项目需要加载的类生成classmap。在项目中只需要：</p>
<blockquote>
<p>require &lsquo;vendor/autoload.php&rsquo;;</p>
</blockquote>
<p>即可自动加载所有需要的类。</p>
<p>Composer 中文文档：<a href="http://docs.phpcomposer.com/">http://docs.phpcomposer.com/</a>
<!-- raw HTML omitted -->
项目Github 地址：<a href="https://github.com/composer/composer">https://github.com/composer/composer</a></p>
<h2 id="symfony2">Symfony2</h2>
<p>Symfony是一个基于MVC模式的面向对象的PHP5框架。Symfony允许在一个web应用中分离事务控制，服务逻辑和表示层。</p>
<p>Symfony2是一个由20多个独立的开发库组成的工具集，你可以在任何PHP项目里使用这些代码。这些开发库，被称作Symfony2组件，功能涵盖了绝大部分的开发需求。</p>
<p>没错，Symfony是另外一个完整功能的PHP框架。Laravel中使用了部分Symfony2的组件，包括HttpFoundation 和 Routing 等。</p>
<h2 id="ioc--di">IOC &amp;&amp; DI</h2>
<p>Laravel使用IoC（Inversion of Control，控制反转，这是一个设计模式）容器管理类依赖。简单说来，就是一个类把自己的的控制权交给另外一个对象，类间的依赖由这个对象去解决。</p>
<p>实现控制反转的方式主要由依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup），依赖注入属于依赖的显示申明，而依赖查找则是通过查找来解决依赖。前者应用比较广泛。</p>
<p>DI 是不用编写固定代码来处理类之间依赖的方法，相反的，这些依赖是在运行时注入的，这样允许处理依赖时具有更大的灵活性。（控制反转和依赖注入这两个概念最常见的例子大多都是java的）。</p>
<p>Laravel 的每个核心包中都包含一个服务提供器（ServiceProvider）的类，它将依赖聚集一起统一申明和管理，让依赖变得更加容易维护。</p>
<h2 id="facades">Facades</h2>
<p>Facades（一种设计模式，通常翻译为外观模式或者门面模式）提供了一个static 接口去访问注册到IoC 容器中的类 。</p>
<p>在 Laravel 应用程序中， Facade 是提供从容器中访问对象的类。Facade 类只需要实现一个方法： <code>getFacadeAccesor</code>。getFacadeAccessor 方法的工作是定义如何从容器中取得对象。Facades 基类调用PHP的魔术方法 <code>__callStatic()</code>从Facade 中延迟访问取得对象。</p>
<p>因此，当你使用Facade调用，类似Cache::get，Laravel会从IoC容器取得Cache管理类并调用get方法。在技术层上说，Laravel Facades是一种便捷的语法使用Laravel IoC容器作为服务定位器。</p>
<h2 id="附录">附录</h2>
<ul>
<li>Laravel 中文文档地址：<a href="http://v4.golaravel.com/docs/4.2">http://v4.golaravel.com/docs/4.2</a></li>
<li>Symfony2 中文文档地址：<a href="http://symfony.cn/docs/index.html">http://symfony.cn/docs/index.html</a></li>
<li>PHP-FIG：<a href="http://www.php-fig.org/">http://www.php-fig.org/</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>一个XSS带来的一些收获和警示&amp;常见安全问题总结</title>
            <link>http://0x1.im/posts/2014-09-22-one-month-begin-with-a-xss/</link>
            <pubDate>Mon, 22 Sep 2014 21:55:59 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-09-22-one-month-begin-with-a-xss/</guid>
            <description>一个月前我们遭遇了一次XSS，原因很简单：输入内容没有做检查。说起来也很蠢：前端没有检查、写数据库没有检查、Cookie也不是Httponly的，所有可以做的防御措施，我们全部都轻松的避过去了。这样别人轻松的就拿到cookie登录到后台了。
而最近又先后爆出SSL心脏滴血、Bash破壳漏洞等重大的安全问题，所以这一个月我就恶补了一些关于安全的知识，在代码和网站中去是不是以前忽略过的坑坑洼洼。有些东西可以总结一些。很基础但也很容易忽略。
一、常见的攻击方式及防御 1. XSS注入 XSS注入是最常见的、最容易的，但危害性缺不小。对于需要登录的网站，拿到cookie就意味着可以登入后台。如果后台是管理员用的，那意味着网站的大部分信息都暴漏了。如果是用户的后台，一次注入可能就意味着很多用户的私人信息暴漏在了别人面前。
XSS原理简单、手法说起来也不复杂。只要有输入框，没有做过滤，就留给了有心人一个注入代码的可能。通过注入代码调用远程的js文件，可以轻松获取到cookie等信息。
XSS的的基本防御是对用户输入的内容做好过滤，对于一些特殊字符的进行必要的处理。特别是需要写入到数据库里的数据。
2. CSRF攻击 别人诱导你点了一个链接、向后端发了一个请求，这个请求下转走了你支付宝里的钱，这就是CSRF。我登录了A站，A站有扣款的服务。我又登陆了B站，B站有个按钮实际上是A站的扣款链接，我并不知情，基本上就是这样的。
防御CSRF的关键在于后端要判断出请求是不是来自于自己呈现给用户的网页。在客户端的输入框隐藏一个输入框，框里留一个随机数，后端校验这个随机数，就能有效防御绝大部分的CSRF攻击。因为其它的网页和你的网页同时在浏览器存在的时候，从他的网页里请求你的连接时，虽然能带上cookie等信息，但是他的网页却没办法从你的网页里获取到这个随机数。
3. SQL注入 SQL注入与XSS类似，也是从输入入手。但不同于XSS，SQL注入的内容可能并不是在输入框里进行的。一个请求需要根据用户请求的内容查询数据库，就意味着可能会有SQL注入的风险。通过与预期不同的字符串进行查询，构造SQL语句来获取数据库的信息，哪怕是有一个SQL注入的漏洞不小心暴漏给了有心的人，可能整个数据库就要沦陷了。
SQL注入的防御工作也是要对从前端获取到的查询信息进行严格的过滤。对于不在预期之内的字符串进行完善的处理。
4. 被上传webshell 所谓webshell，就是能通过浏览器直接在服务器上操作命令，甚至读取到结果。webshell是由上传而已。比如PHP可以通过system命令或者exec命令执行系统命令。如果有心的人上传一个脚本到你的服务器，脚本中带上了一句：echo system($_GET[&#39;cmd&#39;]);，很不幸，他能执行任何web服务器和PHP解释器有权限执行的命令。
预防webshell需要对上传文件做严格的限制，严格控制上传文件的格式，检查上传的内容。如果是有特殊必要，也要对上传文件的访问做好严格的限制。
同时也要关注服务器、web服务器和脚本解释器的动态，比如Bash的破壳漏洞、IIS6的解析漏洞，及时防御才能规避风险。
二、开发和管理系统过程中的注意事项 许多事情需要在平时开发和维护的过程中注意，处理好一些上的问题，往往能有效的规避大部分的风险。
1. 特殊文件和特殊路径的问题 不要让不该显示的信息显示出去，不要让不该让人访问的东西让别人看到。
刚搭好环境，有时候习惯随手写个phpinfo.php放那里检查一下，事后忘记了处理，别人正好看到了，猜解路径、或者恰好又拿到了别的把柄，一整个网站基本上也就去了。
一些框架特定的版本爆出来大的漏洞，而你恰好留了version或license文件在网站跟目录，替别人省了很多事情。比如thinkphp曾经有过任意代码执行漏洞。
直接通过svn更新代码，svn早期有些版本会在所有目录下都有.svn目录，有特定的文件命名文件里直接就是代码，而你的web服务器恰好没有解析，整个网站的代码就到了别人手里。即使在新的版本里，根目录下也有个wc.db的文件，而你恰好又没有不允许.svn目录的访问。
管理后台就是一个简单的网站的路径，比如phpmyadmin就是/phpmyadmin，phpmyadmin有几个版本有万能用户名的漏洞，轻轻松松拿到数据库。
项目开发过程中，随手把数据库导出一个sql文件保存在web根目录下面，放到服务器上的时候也没有删除，有人随手去试一试，就把它下载下来了。这是很危险的。
2. 不要使用弱口令 任何时候、任何地方都不要使用弱口令。
像上面所说，即使你的phpmyadmin的版本恰好规避了以上的漏洞，而你安装的时候随手敲了个123456当密码。那基本上等于没有设防。
还有网站后台的admin如果，使用一些简单的网站名称、域名或者常见的数字字母组合当密码，很容易猜解出来。
服务器端的脚本访问数据库也不要用root账户完全权限的账号密码，如果网站被上传webshell，拿到配置文件，而数据库又恰好是超级权限的账户，不近代码暴漏在别人面前，网站也被拖库了。
3. 服务端安全策略与权限分配 如果服务器沦陷了，那基本上任何信息都暴漏在了他人面前，所以做好服务器端的管理尤为重要。登录限制、防暴力猜解、防sqlmap、防端口扫描、监控异常流量和IP能够抵御部分极大的隐患。比如破壳漏洞出现时，有些恶意注入会执行一个ping，如果ping回对方的服务器，你的服务器很快就沦陷到他手里了。如果你恰好禁止了icmp包的output，就能度过一段缓冲期。
在Linux上，每个应用程序都有一个执行的用户，web服务器和脚本解释器的用户权限做好限制、web文件目录做好分配可限制也能防止一些异常命令的执行。
4. 经常检查服务器、数据库等log信息 有时候事情已经发生了，能及时发现及时处理也能把损失降到最低。可怕的时候服务器已经沦陷在别人手里了，你还不知道。
很多时候漏洞和隐患也不是单独存在的，找到一个突破口，往往就能攻陷其它地方。比如在数据库里写入一个webshell语句，然后通过构造查询拿到服务器上的东西。
5. 经常关注安全信息 一个安全问题爆出来之后，不要想当然的认为我这里应该没事，及时检查一下才能有效预防。经常浏览一下乌云和freebuf也能及时获取到相关的资讯。
安全问题是个长期的工作，没有铁打的系统，不是一蹴而就的事情，时时留心最重要。</description>
            <content type="html"><![CDATA[<p>一个月前我们遭遇了一次XSS，原因很简单：输入内容没有做检查。说起来也很蠢：前端没有检查、写数据库没有检查、Cookie也不是Httponly的，所有可以做的防御措施，我们全部都轻松的避过去了。这样别人轻松的就拿到cookie登录到后台了。</p>
<p>而最近又先后爆出SSL心脏滴血、Bash破壳漏洞等重大的安全问题，所以这一个月我就恶补了一些关于安全的知识，在代码和网站中去是不是以前忽略过的坑坑洼洼。有些东西可以总结一些。很基础但也很容易忽略。</p>
<h2 id="一常见的攻击方式及防御">一、常见的攻击方式及防御</h2>
<h3 id="1-xss注入">1. XSS注入</h3>
<p>XSS注入是最常见的、最容易的，但危害性缺不小。对于需要登录的网站，拿到cookie就意味着可以登入后台。如果后台是管理员用的，那意味着网站的大部分信息都暴漏了。如果是用户的后台，一次注入可能就意味着很多用户的私人信息暴漏在了别人面前。</p>
<p>XSS原理简单、手法说起来也不复杂。只要有输入框，没有做过滤，就留给了有心人一个注入代码的可能。通过注入代码调用远程的js文件，可以轻松获取到cookie等信息。</p>
<p>XSS的的基本防御是对用户输入的内容做好过滤，对于一些特殊字符的进行必要的处理。特别是需要写入到数据库里的数据。</p>
<h3 id="2-csrf攻击">2. CSRF攻击</h3>
<p>别人诱导你点了一个链接、向后端发了一个请求，这个请求下转走了你支付宝里的钱，这就是CSRF。我登录了A站，A站有扣款的服务。我又登陆了B站，B站有个按钮实际上是A站的扣款链接，我并不知情，基本上就是这样的。</p>
<p>防御CSRF的关键在于后端要判断出请求是不是来自于自己呈现给用户的网页。在客户端的输入框隐藏一个输入框，框里留一个随机数，后端校验这个随机数，就能有效防御绝大部分的CSRF攻击。因为其它的网页和你的网页同时在浏览器存在的时候，从他的网页里请求你的连接时，虽然能带上cookie等信息，但是他的网页却没办法从你的网页里获取到这个随机数。</p>
<h3 id="3-sql注入">3. SQL注入</h3>
<p>SQL注入与XSS类似，也是从输入入手。但不同于XSS，SQL注入的内容可能并不是在输入框里进行的。一个请求需要根据用户请求的内容查询数据库，就意味着可能会有SQL注入的风险。通过与预期不同的字符串进行查询，构造SQL语句来获取数据库的信息，哪怕是有一个SQL注入的漏洞不小心暴漏给了有心的人，可能整个数据库就要沦陷了。</p>
<p>SQL注入的防御工作也是要对从前端获取到的查询信息进行严格的过滤。对于不在预期之内的字符串进行完善的处理。</p>
<h3 id="4-被上传webshell">4. 被上传webshell</h3>
<p>所谓webshell，就是能通过浏览器直接在服务器上操作命令，甚至读取到结果。webshell是由上传而已。比如PHP可以通过system命令或者exec命令执行系统命令。如果有心的人上传一个脚本到你的服务器，脚本中带上了一句：<code>echo system($_GET['cmd']);</code>，很不幸，他能执行任何web服务器和PHP解释器有权限执行的命令。</p>
<p>预防webshell需要对上传文件做严格的限制，严格控制上传文件的格式，检查上传的内容。如果是有特殊必要，也要对上传文件的访问做好严格的限制。</p>
<p>同时也要关注服务器、web服务器和脚本解释器的动态，比如Bash的破壳漏洞、IIS6的解析漏洞，及时防御才能规避风险。</p>
<h2 id="二开发和管理系统过程中的注意事项">二、开发和管理系统过程中的注意事项</h2>
<p>许多事情需要在平时开发和维护的过程中注意，处理好一些上的问题，往往能有效的规避大部分的风险。</p>
<h3 id="1-特殊文件和特殊路径的问题">1. 特殊文件和特殊路径的问题</h3>
<p><strong>不要让不该显示的信息显示出去，不要让不该让人访问的东西让别人看到。</strong></p>
<p>刚搭好环境，有时候习惯随手写个phpinfo.php放那里检查一下，事后忘记了处理，别人正好看到了，猜解路径、或者恰好又拿到了别的把柄，一整个网站基本上也就去了。</p>
<p>一些框架特定的版本爆出来大的漏洞，而你恰好留了version或license文件在网站跟目录，替别人省了很多事情。比如thinkphp曾经有过任意代码执行漏洞。</p>
<p>直接通过svn更新代码，svn早期有些版本会在所有目录下都有.svn目录，有特定的文件命名文件里直接就是代码，而你的web服务器恰好没有解析，整个网站的代码就到了别人手里。即使在新的版本里，根目录下也有个wc.db的文件，而你恰好又没有不允许.svn目录的访问。</p>
<p>管理后台就是一个简单的网站的路径，比如phpmyadmin就是/phpmyadmin，phpmyadmin有几个版本有万能用户名的漏洞，轻轻松松拿到数据库。</p>
<p>项目开发过程中，随手把数据库导出一个sql文件保存在web根目录下面，放到服务器上的时候也没有删除，有人随手去试一试，就把它下载下来了。这是很危险的。</p>
<h3 id="2-不要使用弱口令">2. 不要使用弱口令</h3>
<p><strong>任何时候、任何地方都不要使用弱口令。</strong></p>
<p>像上面所说，即使你的phpmyadmin的版本恰好规避了以上的漏洞，而你安装的时候随手敲了个123456当密码。那基本上等于没有设防。</p>
<p>还有网站后台的admin如果，使用一些简单的网站名称、域名或者常见的数字字母组合当密码，很容易猜解出来。</p>
<p>服务器端的脚本访问数据库也不要用root账户完全权限的账号密码，如果网站被上传webshell，拿到配置文件，而数据库又恰好是超级权限的账户，不近代码暴漏在别人面前，网站也被拖库了。</p>
<h3 id="3-服务端安全策略与权限分配">3. 服务端安全策略与权限分配</h3>
<p>如果服务器沦陷了，那基本上任何信息都暴漏在了他人面前，所以做好服务器端的管理尤为重要。登录限制、防暴力猜解、防sqlmap、防端口扫描、监控异常流量和IP能够抵御部分极大的隐患。比如破壳漏洞出现时，有些恶意注入会执行一个ping，如果ping回对方的服务器，你的服务器很快就沦陷到他手里了。如果你恰好禁止了icmp包的output，就能度过一段缓冲期。</p>
<p>在Linux上，每个应用程序都有一个执行的用户，web服务器和脚本解释器的用户权限做好限制、web文件目录做好分配可限制也能防止一些异常命令的执行。</p>
<h3 id="4-经常检查服务器数据库等log信息">4. 经常检查服务器、数据库等log信息</h3>
<p>有时候事情已经发生了，能及时发现及时处理也能把损失降到最低。可怕的时候服务器已经沦陷在别人手里了，你还不知道。</p>
<p>很多时候漏洞和隐患也不是单独存在的，找到一个突破口，往往就能攻陷其它地方。比如在数据库里写入一个webshell语句，然后通过构造查询拿到服务器上的东西。</p>
<h3 id="5-经常关注安全信息">5. 经常关注安全信息</h3>
<p>一个安全问题爆出来之后，不要想当然的认为我这里应该没事，及时检查一下才能有效预防。经常浏览一下乌云和freebuf也能及时获取到相关的资讯。</p>
<p>安全问题是个长期的工作，没有铁打的系统，不是一蹴而就的事情，时时留心最重要。</p>
]]></content>
        </item>
        
        <item>
            <title>Linux(Ubuntu) iptables使用小记</title>
            <link>http://0x1.im/posts/2014-09-20-use-linux-ubuntu-iptables/</link>
            <pubDate>Sat, 20 Sep 2014 14:32:55 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-09-20-use-linux-ubuntu-iptables/</guid>
            <description>1. 基础介绍 netfilter/iptables 是与2.4版本之后Linux内核集成的IP信息包过滤系统。iptables不是防火墙，只是定义过滤规则的工具，读取规则并发挥作用的是netfilter。 netfilter/iptables是内核集成的，不存在start/stop或者禁用的说法。可以用iptables命令创建过滤规则。（现在较新的内核中已经默认集成，无需单独安装）
项目主页：http://www.netfilter.org/projects/iptables/
常用命令：
 查看帮助：iptables -h 查看过滤规则：iptables -L [-n] [-v] 子命令：  -n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名 -v：显示详细信息    另外，在实际建立规则的过程中，iptables还需要和以下两个命令配合使用：
 保存创建好的规则到文件：iptables-save 从文件中回复规则：iptables-restore  2. 规则参数 iptables创建规则的命令和参数相当繁杂，基本的规则形式如下：
iptables [-t table] command chain [match] [-j target] 以下是各段命令主要参数的解释。
  -t table，table有四个选项，默认为filter：
 filter：一般的过滤功能，默认的table nat：用于NAT功能（端口映射，地址映射等） mangle：用于对特定数据包的修改 raw：主要用于配合NOTRACK的响应 security：用户强制访问控制(MAC)网络规则    command，定义规则写入方式：
 -P：定义链的默认规则（所有其它规则都没有匹配到的数据包，将按照默认规则来执行） -A：追加，在当前链的最后新增一个规则 -I num：插入，把当前规则插入为第几条 -R num：Replays替换/修改第几条规则 -D num：删除，明确指定删除第几条规则    chain，netfilter可以在五个位置进行过滤：
 PREROUTING (路由前) INPUT (数据包流入口) FORWARD (转发管卡) OUTPUT(数据包出口) POSTROUTING（路由后）    match：匹配规则，常用的规则有以下几种：</description>
            <content type="html"><![CDATA[<h3 id="1-基础介绍">1. 基础介绍</h3>
<p><strong>netfilter/iptables</strong> 是与2.4版本之后Linux内核集成的IP信息包过滤系统。iptables不是防火墙，只是定义过滤规则的工具，读取规则并发挥作用的是netfilter。
netfilter/iptables是内核集成的，不存在start/stop或者禁用的说法。可以用<code>iptables</code>命令创建过滤规则。（现在较新的内核中已经默认集成，无需单独安装）</p>
<p>项目主页：<a href="http://www.netfilter.org/projects/iptables/" title="netfilter/iptables">http://www.netfilter.org/projects/iptables/</a></p>
<p>常用命令：</p>
<ul>
<li>查看帮助：iptables -h</li>
<li>查看过滤规则：iptables -L [-n] [-v]
<!-- raw HTML omitted -->
子命令：
<ul>
<li>-n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名</li>
<li>-v：显示详细信息</li>
</ul>
</li>
</ul>
<p>另外，在实际建立规则的过程中，iptables还需要和以下两个命令配合使用：</p>
<ul>
<li>保存创建好的规则到文件：iptables-save</li>
<li>从文件中回复规则：iptables-restore</li>
</ul>
<h3 id="2-规则参数">2. 规则参数</h3>
<p>iptables创建规则的命令和参数相当繁杂，基本的规则形式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables <span class="o">[</span>-t table<span class="o">]</span> <span class="nb">command</span> chain <span class="o">[</span>match<span class="o">]</span> <span class="o">[</span>-j target<span class="o">]</span>
</code></pre></div><p>以下是各段命令主要参数的解释。</p>
<ul>
<li>
<p><strong>-t table，table有四个选项，默认为filter：</strong></p>
<ul>
<li>filter：一般的过滤功能，默认的table</li>
<li>nat：用于NAT功能（端口映射，地址映射等）</li>
<li>mangle：用于对特定数据包的修改</li>
<li>raw：主要用于配合NOTRACK的响应</li>
<li>security：用户强制访问控制(MAC)网络规则</li>
</ul>
</li>
<li>
<p><strong>command，定义规则写入方式：</strong></p>
<ul>
<li>-P：定义链的默认规则（所有其它规则都没有匹配到的数据包，将按照默认规则来执行）</li>
<li>-A：追加，在当前链的最后新增一个规则</li>
<li>-I num：插入，把当前规则插入为第几条</li>
<li>-R num：Replays替换/修改第几条规则</li>
<li>-D num：删除，明确指定删除第几条规则</li>
</ul>
</li>
<li>
<p><strong>chain，netfilter可以在五个位置进行过滤：</strong></p>
<ul>
<li>PREROUTING (路由前)</li>
<li>INPUT (数据包流入口)</li>
<li>FORWARD (转发管卡)</li>
<li>OUTPUT(数据包出口)</li>
<li>POSTROUTING（路由后）</li>
</ul>
</li>
<li>
<p><strong>match：匹配规则，常用的规则有以下几种：</strong></p>
<ul>
<li>-p：用于匹配协议的（这里的协议通常有3种，TCP/UDP/ICMP，逗号分隔多个协议，ALL是确实设置，<code>!</code>表示反向匹配）</li>
<li>-s：匹配源地址ip或ip段（IP或IP/MASK，<code>!</code>表示反向匹配）</li>
<li>-d：匹配信息包的目的地IP地址（<code>!</code>表示反向匹配）</li>
<li>-i：流入网卡</li>
<li>-o：流出网卡</li>
<li>&ndash;dport：目标端口</li>
<li>&ndash;sport：源端口</li>
<li>&ndash;state：连接状态</li>
<li>-m：显式扩展以上的规则（即可以匹配多个状态、端口等）</li>
</ul>
</li>
<li>
<p><strong>target：进行的操作/响应，常见的有以下几种：</strong></p>
<ul>
<li>DROP（悄悄丢弃）</li>
<li>REJECT（明示拒绝）</li>
<li>ACCEPT（接受）</li>
<li>MASQUERADE（源地址伪装）</li>
<li>REDIRECT（重定向）</li>
<li>MARK（打防火墙标记的）</li>
<li>RETURN（返回）</li>
</ul>
</li>
</ul>
<h3 id="3-实际运用">3. 实际运用</h3>
<p>在生产环境的配置中，可以先通过<code>netstat -tunlp</code>命令查看一下当前服务器上有哪些端口是正在监听或使用的已经使用的是tcp还是udp的协议，然后根据使用情况来进行配置。</p>
<ol>
<li>允许已经建立的连接接收数据（状态为ESTABLISHED或RELATED的连接）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre></div><ol>
<li>eth0开放端口22（SSH的默认端口）：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables -A INPUT -p tcp -i eth0 --dport <span class="m">22</span> -j ACCEPT
<span class="c1"># 如果有多个网卡，可以选择开放，比如只开放局域网网卡允许ssh登录</span>
</code></pre></div><ol>
<li>开放其它需要的服务端口，比如80端口：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># 或者是开放多个端口：</span>
iptables -A INPUT -p tcp -m multiport --source-port 8081,8082,8083 -j ACCEPT

<span class="c1">#或者开放一个端口段：</span>
iptables -A INPUT -p tcp --dport 8084:8090 -j ACCEPT
</code></pre></div><ol>
<li>如果需要接受ping</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># echo-request</span>
iptables -A INPUT -p icmp -m icmp --icmp-type <span class="m">8</span> -j ACCEPT

<span class="c1"># echo-reply</span>
iptables -A INPUT -p icmp -m icmp --icmp-type <span class="m">0</span> -j ACCEPT
</code></pre></div><ol>
<li>最后执行全局策略：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP
</code></pre></div><h3 id="4-保存和恢复规则">4. 保存和恢复规则</h3>
<p>通过命令设定的规则只会在当前系统运行的情况下生效，需要通过一定的配置达到在每次开机时自动启动规则。</p>
<p>保存当前iptables的规则到文件中：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables-save &gt; /etc/iptables.up.rules

<span class="c1"># 以下语句添加到/etc/rc.local，在系统重启时恢复规则：</span>
/sbin/iptables-restore &lt; /etc/iptables.up.rules
</code></pre></div><h3 id="5-如果需要清除所有规则">5. 如果需要清除所有规则</h3>
<p><strong>当Chain INPUT (policy DROP)时执行/sbin/iptables -F后，你将和服务器断开连接，
所以在清空所有规则前把policy DROP该为INPUT，防止悲剧发生。</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">iptables -P INPUT ACCEPT

<span class="c1"># 清空所有规则</span>
iptables -F
iptables -X

<span class="c1"># 计数器置0</span>
iptables -Z
</code></pre></div><h3 id="6-ubuntu集成的工具ufw">6. Ubuntu集成的工具：ufw</h3>
<p>ufw为了使Ubuntu的netfilter更易于使用和管理而发行的，是由Canonical公司开发的，采用python编写。</p>
<p>ufw的实质也是通过创建iptables规则的方式实现的，只是简化了参数的格式。如果需要对服务器做一些过滤规则，我建议还是直接使用iptables来创建过滤。</p>
<p>ufw使用文档：<a href="http://wiki.ubuntu.org.cn/Ufw%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">http://wiki.ubuntu.org.cn/Ufw使用指南</a></p>
]]></content>
        </item>
        
        <item>
            <title>什么时候需要使用urlencode和urldecode函数</title>
            <link>http://0x1.im/posts/2014-09-17-when-to-use-urlencode-and-urldecode/</link>
            <pubDate>Wed, 17 Sep 2014 19:07:27 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-09-17-when-to-use-urlencode-and-urldecode/</guid>
            <description>本文默认的语言为PHP
今天在使用fscokopen的时候需要在输入中带上get参数，测试的时候发现参数传过去有问题，于是简单的把参数urlencode了一下再传，问题解决。
后来检查了一下，原来是在参数中有空格，被拼接在需要通过fputs往scoket里字符串里再写进去就出现问题了。
于是整理了一下关于urlencode和urldecode的小问题：
  除了-._三个字符、大小写字母、数字，其它字符串都会被urlencode处理（虽然encode编码之后的字符串都是数字和大写字母，但是小写字母是不会被编码的）
  通过浏览器在URL后面带GET参数的时候都是经过encode处理的（所以才叫urlencode的嘛）
  PHP在后台接收参数的时候无需经过urldecode的处理了：
 Warning: 超全局变量 $_GET 和 $_REQUEST 已经被解码了。对 $_GET 或 $_REQUEST 里的元素使用 urldecode() 将会导致不可预计和危险的结果
   POST传递和接受参数都不需要经过encode和decode处理，$_POST接收的参数也不会进行解码操作
  在使用fsockopen等函数，通过凭借header信息字符串的方式添加进去的参数，如果经过eneode，需要自己调用urldecode方法
  encode之后的字符串还会可以再次被encode，%会被编码为%25，但是如果在浏览器上带上encode之后的字符串，字符串不会被再次编码
  PHP的urlencode函数被把空格替换成+,rawurlencode函数会空格编码成20%
  </description>
            <content type="html"><![CDATA[<p>本文默认的语言为PHP</p>
<p>今天在使用fscokopen的时候需要在输入中带上get参数，测试的时候发现参数传过去有问题，于是简单的把参数urlencode了一下再传，问题解决。</p>
<p>后来检查了一下，原来是在参数中有空格，被拼接在需要通过fputs往scoket里字符串里再写进去就出现问题了。</p>
<p>于是整理了一下关于urlencode和urldecode的小问题：</p>
<ol>
<li>
<p>除了<code>-._</code>三个字符、大小写字母、数字，其它字符串都会被urlencode处理（虽然encode编码之后的字符串都是数字和大写字母，但是小写字母是不会被编码的）</p>
</li>
<li>
<p>通过浏览器在URL后面带GET参数的时候都是经过encode处理的（所以才叫urlencode的嘛）</p>
</li>
<li>
<p>PHP在后台接收参数的时候无需经过urldecode的处理了：</p>
<blockquote>
<p><strong>Warning: 超全局变量 $_GET 和 $_REQUEST 已经被解码了。对 $_GET 或 $_REQUEST 里的元素使用 urldecode() 将会导致不可预计和危险的结果</strong></p>
</blockquote>
</li>
<li>
<p>POST传递和接受参数都不需要经过encode和decode处理，$_POST接收的参数也不会进行解码操作</p>
</li>
<li>
<p>在使用fsockopen等函数，通过凭借header信息字符串的方式添加进去的参数，如果经过eneode，需要自己调用urldecode方法</p>
</li>
<li>
<p>encode之后的字符串还会可以再次被encode，<code>%</code>会被编码为<code>%25</code>，但是如果在浏览器上带上encode之后的字符串，字符串不会被再次编码</p>
</li>
<li>
<p>PHP的urlencode函数被把空格替换成<code>+</code>,rawurlencode函数会空格编码成<code>20%</code></p>
</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>PHP的session与cookie &amp; CodeIgniter的session修改</title>
            <link>http://0x1.im/posts/2014-09-16-php-session-cookie/</link>
            <pubDate>Tue, 16 Sep 2014 21:01:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-09-16-php-session-cookie/</guid>
            <description>设定cookie的读取为httponly 最近网站被XSS了，还被报到乌云上去了。感谢仁慈的好事者没有做什么破坏，也给我提了醒。郁闷之与，做好防范才是关键。 做好防范，除了做好设置过滤以外，同事提到一个环节是设定cookie的读取模式为httponly。
于是我找了一下什么是httponly。在php.ini中有一个设置参数：
session.cookie_httponly =  试试用ini_set把这个参数置为1，清理cookie刷新一下，结果显示不行。从php.ini文件中改也不行。
于是放弃了这种方法，在CodeIgniter中的源文件中改了几个地方，通过setcookie的参数设定httponly。
但是还有点不死心，想看一下这个参数到底是做什么的。在网上找了一下，也没有专门去讲这个事情的，甚至有些提到这个参数和setcookie混用的。
在PHP的源码中搜了一下，，在ext/session/session.c找到了以下的地方：
if (PS(cookie_httponly)) { smart_str_appends(&amp;amp;ncookie, COOKIE_HTTPONLY); } smart_str_0(&amp;amp;ncookie); php_session_remove_cookie(TSRMLS_C); /* remove already sent session ID cookie */ /* &amp;#39;replace&amp;#39; must be 0 here, else a previous Set-Cookie header, probably sent with setcookie() will be replaced! */ sapi_add_header_ex(estrndup(ncookie.s-&amp;gt;val, ncookie.s-&amp;gt;len), ncookie.s-&amp;gt;len, 0, 0 TSRMLS_CC); 从这段代码中可以看出httponly这个参数是被写在客户端存储session的cookie头上的，所以作用的范围仅限于session，而且只有使用了PHP自己的session的时候才会起作用（这个参数对其它的cookie更是没有任何作用的），在使用session_start()之后，客户端会保存一个cookie记录当前会话的session数据（默认名称是PHPSESSID，通过sesssion.name修改），这里配置的所有关于cookie的参数，都是针对这一条数据的。CI的session是自己实现的。所以使用这个参数当然是没有用的。
于是我梳理了一下cookie和session的知识并记录下来。很多信息从网络上可以获取到。
cookie与session 1.session与session机制
session与session机制是两个的概念。
session，顾名思义，指的是会话的过程，而session机制指的是创建会话过程并维护的方式。 我们说的PHP的session指的是PHP实现并维护的session机制（可以使用session_start()函数开启并使用$_SESSION保存和获取参数），但是我们也可以自己实现或者使用框架里的session实现方式。
2.session机制
一个完善的session机制如下：
  服务器生成一个id作为会话的id，同时可以已这个id为基础存储一些数据，整个session的id和数据可以存在文件里，也可以存在数据库里（PHP的session机制默认是存储文件）。
  服务器把session的id和数据经过整理、加密等一系类过程作为一个数据（字符串）发送给客户端（浏览器），客户端将这个session存储下来。存储的方式可能有多种，最常用的是cookie（也可以是别的方式，只要保证在自己的web程序中可以取到，比如存在一个form标签里也是可以的）。
  客户端（浏览器）发送请求时，带上session数据（大多时候是cookie）一起送给服务器，服务器通过解析这段数据来判断请求来自哪里，已经在这次会话的过程中存储的一些数据（后端）。</description>
            <content type="html"><![CDATA[<h3 id="设定cookie的读取为httponly">设定cookie的读取为httponly</h3>
<p>最近网站被XSS了，还被报到乌云上去了。感谢仁慈的好事者没有做什么破坏，也给我提了醒。郁闷之与，做好防范才是关键。
做好防范，除了做好设置过滤以外，同事提到一个环节是设定cookie的读取模式为<code>httponly</code>。</p>
<p>于是我找了一下什么是httponly。在php.ini中有一个设置参数：</p>
<pre><code>session.cookie_httponly =
</code></pre>
<p>试试用<code>ini_set</code>把这个参数置为1，清理cookie刷新一下，结果显示不行。从php.ini文件中改也不行。</p>
<p>于是放弃了这种方法，在CodeIgniter中的源文件中改了几个地方，通过setcookie的参数设定httponly。</p>
<p>但是还有点不死心，想看一下这个参数到底是做什么的。在网上找了一下，也没有专门去讲这个事情的，甚至有些提到这个参数和setcookie混用的。</p>
<p>在PHP的源码中搜了一下，，在<code>ext/session/session.c</code>找到了以下的地方：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">PS</span><span class="p">(</span><span class="n">cookie_httponly</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">smart_str_appends</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncookie</span><span class="p">,</span> <span class="n">COOKIE_HTTPONLY</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">smart_str_0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ncookie</span><span class="p">);</span>

<span class="n">php_session_remove_cookie</span><span class="p">(</span><span class="n">TSRMLS_C</span><span class="p">);</span> <span class="cm">/* remove already sent session ID cookie */</span>
<span class="cm">/*  &#39;replace&#39; must be 0 here, else a previous Set-Cookie
</span><span class="cm">    header, probably sent with setcookie() will be replaced! */</span>
<span class="n">sapi_add_header_ex</span><span class="p">(</span><span class="n">estrndup</span><span class="p">(</span><span class="n">ncookie</span><span class="p">.</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">ncookie</span><span class="p">.</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span> <span class="n">ncookie</span><span class="p">.</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>
</code></pre></div><p>从这段代码中可以看出httponly这个参数是被写在客户端存储session的cookie头上的，所以作用的范围仅限于session，而且只有使用了PHP自己的session的时候才会起作用（这个参数对其它的cookie更是没有任何作用的），在使用<code>session_start()</code>之后，客户端会保存一个cookie记录当前会话的session数据（默认名称是<code>PHPSESSID</code>，通过sesssion.name修改），这里配置的所有关于cookie的参数，都是针对这一条数据的。CI的session是自己实现的。所以使用这个参数当然是没有用的。</p>
<p>于是我梳理了一下cookie和session的知识并记录下来。很多信息从网络上可以获取到。</p>
<h3 id="cookie与session">cookie与session</h3>
<p>1.<strong>session与session机制</strong></p>
<p>session与session机制是两个的概念。</p>
<p><strong>session，顾名思义，指的是会话的过程，而session机制指的是创建会话过程并维护的方式。</strong>
我们说的PHP的session指的是PHP实现并维护的session机制（可以使用<code>session_start()</code>函数开启并使用<code>$_SESSION</code>保存和获取参数），但是我们也可以自己实现或者使用框架里的session实现方式。</p>
<p>2.<strong>session机制</strong></p>
<p>一个完善的session机制如下：</p>
<ol>
<li>
<p>服务器生成一个id作为会话的id，同时可以已这个id为基础存储一些数据，整个session的id和数据可以存在文件里，也可以存在数据库里（PHP的session机制默认是存储文件）。</p>
</li>
<li>
<p>服务器把session的id和数据经过整理、加密等一系类过程作为一个数据（字符串）发送给客户端（浏览器），客户端将这个session存储下来。存储的方式可能有多种，最常用的是cookie（也可以是别的方式，只要保证在自己的web程序中可以取到，比如存在一个form标签里也是可以的）。</p>
</li>
<li>
<p>客户端（浏览器）发送请求时，带上session数据（大多时候是cookie）一起送给服务器，服务器通过解析这段数据来判断请求来自哪里，已经在这次会话的过程中存储的一些数据（后端）。</p>
</li>
</ol>
<p>3.<strong>session和cookie的关系</strong></p>
<p>cookie是一种存储机制，指的是web服务可以在客户端存储一小段数据。当某个web服务在客户端存储有cookie数据的时候，客户端可以在之后的每次请求中都带上这段数据（浏览器是会自动带上这段数据的）。当然客户端也完全可以选择不带上这段数据，浏览器也可以禁用cookie。</p>
<p>session与cookie的关系在于：在绝大多数的情况下，我们会默认使用cookie来存储session会话的数据，而且现在浏览器都实现了带cookie请求的方式，再加上PHP的session机制，我们不需要考虑怎么去设计并维护一个简单的session会话。</p>
<p>一些网站也会在cookie被禁用的情况下通过其它方式维护session。</p>
<h3 id="给ci的cookie类加上httponly">给CI的cookie类加上httponly</h3>
<p><strong>说明：在2.1.3之后版本，CodeIgniter 已经修改了 Input 类的 cookie 方法和 cookie helper 的set_cookie 函数。并且扩展了 session 类，在 session_cookie 中，以下提到的改动已经加入，并且添加了 session_native 类，封装了 PHP 提供的 session 机制。</strong></p>
<p>CI也是通过cookie来存session的，这点没有什么特别之处。不过CI的session机制并不是通过PHP原生的方法来调用的，是自己实现的。</p>
<p>使用CI的session类的好处在于可以很方便的使用数据库来存储和维护session数据。这是你可以在服务端里保存一些session相关的关键数据，比如用户的id。</p>
<p><strong>如果你不使用数据库存储session数据，那就不要使用CI的session类，因为它会直接把你的数据写到cookie里去，虽然数据是加密的：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="c1">// Are we saving custom data to the DB?  If not, all we do is update the cookie
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">sess_use_database</span> <span class="o">===</span> <span class="k">FALSE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_set_cookie</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div><p>修改CI的cookie使其可以支持可以设定为httponly:</p>
<ul>
<li>修改systerm/libraries/Session.php：添加一个属性 $cookie_httponly ，在构造函数的循环获取变量设置的数组里添加上这个属性；在 _set_cookie 方法末尾setcookie的地方添加上 $this-&gt;cookie_httponly;</li>
<li>修改systerm/core/Input.php： set_cookie 方法中添加参数 $http_only ,并在末尾setcookie函数里添加这个参数;</li>
<li>修改systerm/helper/cookie_helper.php： set_cookie 方法方法中也添加这个参数，并在末尾 $CI-&gt;input-&gt;set_cookie 的调用里加上。</li>
</ul>
<p>如果在项目中不会使用到 $this-&gt;input-&gt;cookie() 的方法，可以不修改Input类，如果不使用cookie helper中的 set_cookie 方法，也可以不修改这个方法。</p>
<p>如果在项目用有使用登录的类库并调用了以上这些方法时，需要带上 http_only 的参数。</p>
<p>config文件中可以通过<code>$config['cookie_httponly'] = TRUE</code>来设置，或者在调用 session 类时传入。</p>
<h3 id="小工具">小工具</h3>
<p>Chrome有个插件<a href="http://www.editthiscookie.com/" title="">EditThisCookie</a>可以很方便的修改和删除 cookie。</p>
]]></content>
        </item>
        
        <item>
            <title>修改CodeIgniter的Pagination类使其支持Ajax分页</title>
            <link>http://0x1.im/posts/2014-09-14-modify-codeigniter-pagination-class/</link>
            <pubDate>Sun, 14 Sep 2014 23:37:54 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-09-14-modify-codeigniter-pagination-class/</guid>
            <description>本文中针对CodeIgniter的问题都是基于2.1.3的版本。
 在使用CodeIgniter做项目的过程中，需要用到ajax来分页，但是CI集成的分页类只支持在URL后面跟分页参数的方式。如果想实现ajax的分页，通过一定的方法也可以实现。
###使用原有实现示例
&amp;lt;?php $config[&amp;#39;base_url&amp;#39;] = &amp;#39;javascript:pageAnchor(\&amp;#39;&amp;#39;; $config[&amp;#39;suffix&amp;#39;] = &amp;#39;\&amp;#39;);&amp;#39;; $config[&amp;#39;first_url&amp;#39;] = &amp;#39;javascript:pageAnchor(\&amp;#39;/0\&amp;#39;)&amp;#39;; $config[&amp;#39;anchor_class&amp;#39;] = &amp;#34;&amp;#34;; //添加你的样式  $config[&amp;#39;cur_tag_open&amp;#39;] = &amp;#39;&amp;lt;a href=&amp;#34;javascript:void(0);&amp;#34; class=&amp;#34;&amp;#34;&amp;gt;&amp;#39;; $config[&amp;#39;cur_tag_close&amp;#39;] = &amp;#39;&amp;lt;/a&amp;gt;&amp;#39;; $config[&amp;#39;prev_link&amp;#39;] = &amp;#39;&amp;amp;lt;&amp;#39;; $config[&amp;#39;next_link&amp;#39;] = &amp;#39;&amp;amp;gt;&amp;#39;; $config[&amp;#39;first_link&amp;#39;] = &amp;#39;&amp;amp;laquo;&amp;#39;; $config[&amp;#39;last_link&amp;#39;] = &amp;#39;&amp;amp;raquo;&amp;#39;; $config[&amp;#39;first_tag_close&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;last_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;next_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;next_tag_close&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;prev_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;num_tag_open&amp;#39;] = &amp;#39;&amp;#39;; $config[&amp;#39;total_rows&amp;#39;] = 100; //数据总条数  $config[&amp;#39;per_page&amp;#39;] = 10; // 这里原来是要配置$config[&amp;#39;uri_segment&amp;#39;] 默认为3  // 分页类中有一个地方  // $CI-&amp;gt;uri-&amp;gt;segment($this-&amp;gt;uri_segment) !</description>
            <content type="html"><![CDATA[<blockquote>
<p>本文中针对CodeIgniter的问题都是基于<code>2.1.3</code>的版本。</p>
</blockquote>
<p>在使用CodeIgniter做项目的过程中，需要用到ajax来分页，但是CI集成的分页类只支持在URL后面跟分页参数的方式。如果想实现ajax的分页，通过一定的方法也可以实现。</p>
<p>###使用原有实现示例</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;base_url&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="s1">&#39;javascript:pageAnchor(\&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;suffix&#39;</span><span class="p">]</span>           <span class="o">=</span> <span class="s1">&#39;\&#39;);&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;first_url&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="s1">&#39;javascript:pageAnchor(\&#39;/0\&#39;)&#39;</span><span class="p">;</span>

    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;anchor_class&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span> <span class="c1">//添加你的样式
</span><span class="c1"></span>    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_tag_open&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="s1">&#39;&lt;a href=&#34;javascript:void(0);&#34; class=&#34;&#34;&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_tag_close&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="s1">&#39;&lt;/a&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;prev_link&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="s1">&#39;&amp;lt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;next_link&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="s1">&#39;&amp;gt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;first_link&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="s1">&#39;&amp;laquo;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;last_link&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="s1">&#39;&amp;raquo;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;first_tag_close&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;last_tag_open&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;next_tag_open&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;next_tag_close&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;prev_tag_open&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;num_tag_open&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;total_rows&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//数据总条数
</span><span class="c1"></span>    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;per_page&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// 这里原来是要配置$config[&#39;uri_segment&#39;] 默认为3
</span><span class="c1"></span>    <span class="c1">// 分页类中有一个地方
</span><span class="c1"></span>    <span class="c1">// $CI-&gt;uri-&gt;segment($this-&gt;uri_segment) != $base_page
</span><span class="c1"></span>    <span class="c1">// 通过这个方法去判断当前页码
</span><span class="c1"></span>    <span class="c1">// 我们的uri里第三段全为字母,刚好可以绕过这个判断
</span><span class="c1"></span>    <span class="c1">// 所以cur_page 这个参数才能够传入进去
</span><span class="c1"></span>    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_page&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//当前页
</span><span class="c1"></span><span class="cp">?&gt;</span>
</code></pre></div><p>只要你的URL的第三段全为字母，就可以绕过判断，这实际上是一个bug。</p>
<p>通过以上的配置，在js中增加一个<code>pageAnchor</code>的方法，就可以实现ajax的分页了。</p>
<p>另外，在CdoeIgniter <code>2.1.3</code>之前的版本中，通过<code>$this-&gt;load-&gt;library('pagination',$config)</code>的方式来初始化时添加<code>anchor_class</code>参数无法生效，这是因为代码中把这个参数的操作放到了构造函数中，这个BUG在<code>2.1.4</code>的版本中已经修复了。</p>
<p>###修改后的实现</p>
<p>通过这种方法来实现毕竟也不太恰当，可以提取出这个类来单独使用，这样在别的框架中也可以使用这个分页类。</p>
<p>主要改动如下：</p>
<ol>
<li>添加了一个<code>is_ajax</code>的参数，并修改了默认的跟tag有关的参数，便于直接写入css</li>
<li>移除了跟CI的其它类有关的取URL参数的部分，这样就是一个纯净的分页类了</li>
<li><code>num_links</code>小于1时跳到第一页，而不是报错</li>
<li>移除了<code>query_string_segment</code>参数，增加<code>query_string_key</code>参数，仍然支持通过参数的形式获取分页。</li>
</ol>
<p>改动后的使用配置方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;is_ajax&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;base_url&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="s1">&#39;pageAnchor&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;first_url&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="s1">&#39;javascript:pageAnchor(\&#39;/0\&#39;)&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;anchor_class&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_tag_open&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="s1">&#39;&lt;a href=&#34;javascript:void(0);&#34; class=&#34;&#34;&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_tag_close&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="s1">&#39;&lt;/a&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;total_rows&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 数据总条数
</span><span class="c1"></span>    <span class="nv">$config</span><span class="p">[</span><span class="s1">&#39;cur_page&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 当前页码
</span><span class="c1"></span><span class="cp">?&gt;</span>
</code></pre></div><p>###下载
<a href="/files/code/Page.php" title="">Page.php</a></p>
]]></content>
        </item>
        
        <item>
            <title>iOS推送（Apple Push Notification Service）部署总结</title>
            <link>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</link>
            <pubDate>Sat, 09 Aug 2014 15:50:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-08-09-ios-push-apns-php-zendframework/</guid>
            <description>1. 基础部署  后端：PHP 依赖：zendframework/zendservice-apple-apns 本文中使用的PHP框架：laravel  2. 实现目标  实现中等规模批量设备的推送（1w设备以上），并且有可扩展的余地（十万到百万级） 推送的整体发送时间可控（半小时内，最好数分钟内） 保证推送的到达率能够达到**90%**以上 可以从设备列表中及时剔除无效的设备，并能够从APNs的服务器中及时获取反馈 可以获取到已经卸载的设备信息  3. 基础知识 关于APNs，我们首选需要知道：
 iOS的推送是通过socket链接将详细发送到苹果的服务器，然后由苹果像设备推送来实现的； 在服务的我们需要自己维护一个token的列表用于记录要向哪些设备发送推送； token是由系统提供的，但是有可能会失效，用户也可能会已经卸载应用； 苹果提供有获取feedback的服务器接口用于获取已经卸载应用的的设备token；  在实际操作中发现关于推送的部分：
 向一个已经打开的socket连接写入token和推送消息时，如果有一个token是无效的，socket会断开； 已经卸载应用的设备token不算是无效的token（不会导致连接断开），但是像它发送消息是没有意义的且会增加负担； socket断开之前会向连接中写入一个错误信息，可以捕捉错误的方式知道socket是在什么时候断开的，但是这个消息会有延时，无法保证100%接收到； 错误信息不会直接返回是哪个token，而是返回发送时设定的identifier； socket也会存在其它异常断开的情况； iOS6以下的设备无法通过feedback的接口获取到已卸载的token（测试结果，没有在文档中验证）； feedback的接口取到的是上次推送的过程中出现的已卸载应用的设备token，而且获取一次之后就会清空； 如果想获得卸载应用的feedback，该应用不能是卸载的设备上的仅有的推送应用（如果是最后一个，设备和苹果的推送服务连接会断开）；  4. 实际部署 实际部署中，需要对使用的库做出一些改动。
1.在ZendService\Apple\Apns\Client\Message中增加一个方法用于每次推送结束之后获取反馈：
&amp;lt;?php /** * Get Response * * @return ZendService\Apple\Apns\Response\Message */ public function getResponse(){ if (!$this-&amp;gt;isConnected()) { throw new Exception\RuntimeException(&amp;#39;You must first open the connection by calling open()&amp;#39;); } return new MessageResponse($this-&amp;gt;read()); } ?</description>
            <content type="html"><![CDATA[<h3 id="1-基础部署">1. 基础部署</h3>
<ul>
<li>后端：PHP</li>
<li>依赖：<a href="https://github.com/zendframework/ZendService_Apple_Apns">zendframework/zendservice-apple-apns</a></li>
<li>本文中使用的PHP框架：<a href="http://http://laravel.com/">laravel</a></li>
</ul>
<h3 id="2-实现目标">2. 实现目标</h3>
<ol>
<li>实现中等规模批量设备的推送（1w设备以上），并且有可扩展的余地（十万到百万级）</li>
<li>推送的整体发送时间可控（半小时内，最好<strong>数分钟</strong>内）</li>
<li>保证推送的到达率能够达到**90%**以上</li>
<li>可以从设备列表中及时剔除无效的设备，并能够从APNs的服务器中及时获取反馈</li>
<li>可以获取到已经卸载的设备信息</li>
</ol>
<h3 id="3-基础知识">3. 基础知识</h3>
<p><strong>关于APNs，我们首选需要知道：</strong></p>
<ol>
<li>iOS的推送是通过socket链接将详细发送到苹果的服务器，然后由苹果像设备推送来实现的；</li>
<li>在服务的我们需要自己维护一个token的列表用于记录要向哪些设备发送推送；</li>
<li>token是由系统提供的，但是有可能会失效，用户也可能会已经卸载应用；</li>
<li>苹果提供有获取feedback的服务器接口用于获取已经卸载应用的的设备token；</li>
</ol>
<p><strong>在实际操作中发现关于推送的部分：</strong></p>
<ol>
<li>向一个已经打开的socket连接写入token和推送消息时，如果有一个token是无效的，socket会断开；</li>
<li>已经卸载应用的设备token不算是无效的token（不会导致连接断开），但是像它发送消息是没有意义的且会增加负担；</li>
<li>socket断开之前会向连接中写入一个错误信息，可以捕捉错误的方式知道socket是在什么时候断开的，但是这个消息会有延时，无法保证100%接收到；</li>
<li>错误信息不会直接返回是哪个token，而是返回发送时设定的<strong>identifier</strong>；</li>
<li>socket也会存在其它异常断开的情况；</li>
<li>iOS6以下的设备无法通过feedback的接口获取到已卸载的token（测试结果，没有在文档中验证）；</li>
<li>feedback的接口取到的是上次推送的过程中出现的已卸载应用的设备token，而且获取一次之后就会清空；</li>
<li>如果想获得卸载应用的feedback，该应用不能是卸载的设备上的仅有的推送应用（如果是最后一个，设备和苹果的推送服务连接会断开）；</li>
</ol>
<h3 id="4-实际部署">4. 实际部署</h3>
<p>实际部署中，需要对使用的库做出一些改动。</p>
<p>1.<strong>在ZendService\Apple\Apns\Client\Message中增加一个方法用于每次推送结束之后获取反馈：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="sd">/**
</span><span class="sd"> * Get Response
</span><span class="sd"> *
</span><span class="sd"> * @return ZendService\Apple\Apns\Response\Message
</span><span class="sd"> */</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">getResponse</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">isConnected</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">Exception\RuntimeException</span><span class="p">(</span><span class="s1">&#39;You must first open the connection by calling open()&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MessageResponse</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">read</span><span class="p">());</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div><p>2.<strong>修改ZendService\Apple\Apns\Client\Feedback中的feedback方法，增加一个判断：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">strlen</span><span class="p">(</span><span class="nv">$token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">38</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$tokens</span><span class="p">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FeedbackResponse</span><span class="p">(</span><span class="nv">$token</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div><p>这是因为在实际测试中发现，从feedback中读取到的信息除了38位的反馈，末尾还有一个1位的字符会导致产生异常。</p>
<p>3.<strong>具体的实现见附录中的代码</strong></p>
<h3 id="5-参考文档">5. 参考文档</h3>
<ol>
<li><a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW1">Local and Push Notification Programming Guide</a>
<a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/RemoteNotificationsPG.pdf">PDF版本</a></li>
<li><a href="http://framework.zend.com/manual/2.1/en/modules/zendservice.apple.apns.html">ZendService\AppleApns</a>
这个示例代码中有两个小错误，在附录的实现中已经修正</li>
<li>推送库安装<a href="https://github.com/zendframework/ZendService_Apple_Apns">ZendService_Apple_Apns</a></li>
<li><a href="http://redth.codes/the-problem-with-apples-push-notification-ser/">The Problem With Apples Push Notification Service</a></li>
</ol>
<h3 id="附录">附录</h3>
<p>推送类实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">require_once</span> <span class="no">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../../vendor/autoload.php&#39;</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Client\Message</span> <span class="k">as</span> <span class="nx">Client</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Message</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Message\Alert</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Response\Message</span> <span class="k">as</span> <span class="nx">Response</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Client\Feedback</span> <span class="k">as</span> <span class="nx">Feedback</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">ZendService\Apple\Apns\Exception\RuntimeException</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ApnsController</span> <span class="k">extends</span> <span class="nx">BaseController</span> <span class="p">{</span>
    <span class="c1">//保存设备信息集合
</span><span class="c1"></span>    <span class="k">private</span> <span class="nv">$deviceCollection</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="c1">//不可用的设备id集合
</span><span class="c1"></span>    <span class="k">private</span> <span class="nv">$invalidCollection</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="c1">//推送消息
</span><span class="c1"></span>    <span class="k">private</span> <span class="nv">$messageAlert</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">private</span> <span class="nv">$messageBadge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">private</span> <span class="nv">$messageSound</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">push</span><span class="p">(){</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">messageAlert</span> <span class="o">=</span> <span class="nx">date</span><span class="p">(</span><span class="s1">&#39;Y-m-d H:i:s&#39;</span><span class="p">);</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;4191747e d62960e8 62afd700 bba42d23 cd0203be 6389688d 307ac833 7db66c34&#39;</span><span class="p">,</span>
            <span class="s1">&#39;1b0b80f4 beed1d2a e2b3f45a cce243e7 74d95455 17402870 e925edc4 dcedbfbe&#39;</span><span class="p">,</span>
            <span class="p">);</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_sendMessage</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//获取卸载token
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_getFeedback</span><span class="p">(){</span>
        <span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Feedback</span><span class="p">();</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">open</span><span class="p">(</span><span class="nx">Client</span><span class="o">::</span><span class="na">PRODUCTION_URI</span><span class="p">,</span> <span class="s1">&#39;/path/to/cer.pem&#39;</span><span class="p">);</span>
        <span class="nv">$responses</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">feedback</span><span class="p">();</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">close</span><span class="p">();</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$responses</span> <span class="k">as</span> <span class="nv">$response</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//处理已经卸载的设备token
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//使用zendservice-apple-apns做推送的接口
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_sendMessage</span><span class="p">(){</span>
        <span class="c1">//新建连接
</span><span class="c1"></span>        <span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">();</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">open</span><span class="p">(</span><span class="nx">Client</span><span class="o">::</span><span class="na">PRODUCTION_URI</span><span class="p">,</span> <span class="s1">&#39;/path/to/cer.pem&#39;</span><span class="p">);</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span> <span class="k">as</span> <span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$deviceToken</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//实测等待2ms秒左右基本上可以获得稳定的反馈信息 数据量大的时候可以不等待
</span><span class="c1"></span>            <span class="nx">usleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
            <span class="nv">$message</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_packMessage</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span><span class="nx">str_replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="nv">$deviceToken</span><span class="p">));</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="nv">$message</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getCode</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_OK</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">RuntimeException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">close</span><span class="p">();</span>
                <span class="c1">//推送断开之后获取上次推送的feedback
</span><span class="c1"></span>                <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_getFeedback</span><span class="p">();</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_invalidCollectionHandle</span><span class="p">();</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span> <span class="o">=</span> <span class="nx">array_slice</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span><span class="p">,</span><span class="nv">$key</span><span class="p">);</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_sendMessage</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果没有捕捉错误,0.5s之后再捕捉一次
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getCode</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span>
            <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">getResponse</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">close</span><span class="p">();</span>
        <span class="c1">//推送断开之后获取上次推送的feedback
</span><span class="c1"></span>        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_getFeedback</span><span class="p">();</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_responseHandle</span><span class="p">(</span><span class="nv">$response</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//消息和token打包
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_packMessage</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span><span class="nv">$deviceToken</span><span class="p">){</span>
        <span class="nv">$message</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Message</span><span class="p">();</span>
        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setId</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setExpire</span><span class="p">(</span><span class="mi">86400</span><span class="p">);</span>
        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setToken</span><span class="p">(</span><span class="nv">$deviceToken</span><span class="p">);</span>
        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setBadge</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">messageBadge</span><span class="p">);</span>
        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setSound</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">messageSound</span><span class="p">);</span>
        <span class="c1">// simple alert:
</span><span class="c1"></span>        <span class="nv">$message</span><span class="o">-&gt;</span><span class="na">setAlert</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">messageAlert</span><span class="p">);</span>
        <span class="k">return</span> <span class="nv">$message</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//处理异常
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_responseHandle</span><span class="p">(</span><span class="nv">$response</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getCode</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//先记录完整的错误log再处理
</span><span class="c1"></span>            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_errorLog</span><span class="p">(</span><span class="nv">$response</span><span class="p">);</span>

            <span class="k">switch</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getCode</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_PROCESSING_ERROR</span><span class="o">:</span>
                    <span class="c1">// you may want to retry
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_MISSING_TOKEN</span><span class="o">:</span>
                    <span class="c1">// you were missing a token
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_MISSING_TOPIC</span><span class="o">:</span>
                    <span class="c1">// you are missing a message id
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_MISSING_PAYLOAD</span><span class="o">:</span>
                    <span class="c1">// you need to send a payload
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_INVALID_TOKEN_SIZE</span><span class="o">:</span>
                    <span class="c1">// the token provided was not of the proper size
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_INVALID_TOPIC_SIZE</span><span class="o">:</span>
                    <span class="c1">// the topic was too long
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_INVALID_PAYLOAD_SIZE</span><span class="o">:</span>
                    <span class="c1">// the payload was too large
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_INVALID_TOKEN</span><span class="o">:</span>
                    <span class="c1">// the token was invalid; remove it from your system
</span><span class="c1"></span>                    <span class="nx">array_push</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">invalidCollection</span><span class="p">,</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span><span class="p">[</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">()]);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nx">Response</span><span class="o">::</span><span class="na">RESULT_UNKNOWN_ERROR</span><span class="o">:</span>
                    <span class="c1">// apple didn&#39;t tell us what happened
</span><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//截取错误之后的token数组
</span><span class="c1"></span>            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span> <span class="o">=</span> <span class="nx">array_slice</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span><span class="p">,</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="c1">//重发 数组为空表示全部设备已经推送完毕
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">empty</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">deviceCollection</span><span class="p">))</span> <span class="p">{</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_sendMessage</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_invalidCollectionHandle</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_invalidCollectionHandle</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//推送完成 处理不可用的设备id
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_invalidCollectionHandle</span><span class="p">(){</span>

    <span class="p">}</span>

    <span class="c1">//记录推送过程中的错误
</span><span class="c1"></span>    <span class="k">private</span> <span class="k">function</span> <span class="nf">_errorLog</span><span class="p">(</span><span class="nv">$response</span><span class="p">){</span>

    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>MQTT(使用mosquitto做broker)做Android推送总结</title>
            <link>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</link>
            <pubDate>Mon, 04 Aug 2014 18:00:00 +0000</pubDate>
            
            <guid>http://0x1.im/posts/2014-08-04-android-push-mqtt-mosquitto/</guid>
            <description>“读万卷书，行万里路”。我觉得这句话用在程序员的工作中就是：在网络中找一万篇资料，在实践中做一万种尝试。
 由于Android的开放性，Android的推送解决方案有很多。这其中最便于使用的，应该是google提供的GCM的方案，但是GCM是基于GMS服务的。由于国内的ROM大多干掉了GMS，或者是由于某些众所周知的原因，我们无法使用这个方案获得稳定的推送服务（这个Apple的APNS不同，APNS是IOS的设备上唯一可用的推送解决方案，也是稳定的方案）。基于这些原因，我们选择了自建推送服务的方式。
###1. 基础建设： 纸上得来终觉浅 绝知此事要躬行
 理论支撑 ：使用MQTT作为Android实现方案的原因源于一篇四年前的文章：How to Implement Push Notifications for Android； 与Web管理的对接 ： 文章的作者同时也提供了PHP端的Client方案：PhpMQTTClient。 服务端 ： 当然，这只是Web端的实现方案，至于后端需要使用的Broker，我们找到了mosquitto。 客户端 ： 在客户端中，我们使用的是来自IBM的wmqtt.jar的包：wmqtt  以上四个基本条件是我们具备了部署基于MQTT协议的Android的推送服务的基本条件。在最初的测试中，也没有遇到过太大的问题，测试顺利，于是我们在我们的应用和服务器之间部署了这套解决方案。
###2. 从0到1的变化： 千里之行，始于足下
由于事先并没有做推送的经验，在实际实施的过程中我们明白的几个基础的概念：
 MQTT协议是一个即时通讯协议，推送实际上用到的只是它可以publish内容给topic的功能。topic是一个广播，所有订阅了这个topic的客户端都可以收到消息，为了实现针对设备的点对点推送，我们使用一个prefix+Client ID的方式给每个设备一个topic（如果没有这个需求，可以采取其它灵活的方式）。 为了保证客户端能够实时的收到推送消息，即使是程序退出，客户端用于接收消息的service也需要处于保持状态。 客户端与Broker、Broker和Web端的都是socket通信，推送的过程是用于Web端的client发布一个消息到Broker，Broker再将消息发送给当前其它连接到Broker的Client。所以能及时收到消息的只是现在和Broker保持连接状态的设备。 服务端需要维护一个设备id列表，这个列表中的id必须都是唯一的（在前期，我们选择使用Android ID，这也带来了很多麻烦）。  基于以上几点，我们也可以发现以下的问题：
 不是所有的设备都能够及时的获取到推送的内容。 客户端的service随时会有被各种安全软件干掉的风险。  通过前期的调研我们也发现，这些问题也是其它的第三方推送服务也都会遇到的问题。只要迈出第一步，让服务先work起来，其它的问题后续来优化。
###3. 从1到1万： 不积硅步，无以致千里
这个阶段主要是丰富推送的功能，解决一些前表面上的问题，我们做了以下的调整：
  在设备量到10000的时候，遇到了一个问题：推送10000个设备时间过长。这个问题很快得到了解决：这是由于没发送一个设备，都新建了一个从Web端到Broker的socket连接，这实际上是没有必要的，只要socket不断开所有Publish的工作都可以通过一个socket进行（这和APNS有些不一样的地方，在苹果的推送服务中，如果有一个设备id是无效的，整个推送都会断开），在前文提到过的Web端的库中，是有指定重连的操作的。
  丰富推送的内容。虽然推送的内容都是文本，但是文本的解析却是客户端维持的service来进行的，所以通过推送json的方式，实现了分别推送新闻、天气等富文本信息，并可以通过点击跳转到不同的页面。
  分地区推送的需求，这个实现方式经过一些迭代，最早是通过用户注册地来实现的，后来改为了用户安装应用时上报的地区的方式。
  ###4. 从1万到10万，必须做出的改变： 行百里者半于九十
数据量到达10万的时候，一些问题也逐渐凸显。
  Android ID重复的问题 ： 从网上查询来的资料，大部分都是使用Android的系统参数ANDROID_ID来做推送的。然而实践表明，这个参数并不是可靠的。生产环境中使用这个参数有极大的几率重复。由于一个相同的设备id连接到Broker的时候，之前的连接就会断开，这就会导致相同设备ID的设备只有一个会收到推送的消息。 在续的改造过程中，我们将设备ID换成了自己生成的一套唯一随机的ID。</description>
            <content type="html"><![CDATA[<blockquote>
<p>“读万卷书，行万里路”。我觉得这句话用在程序员的工作中就是：在网络中找一万篇资料，在实践中做一万种尝试。</p>
</blockquote>
<!-- raw HTML omitted -->
<p>由于Android的开放性，Android的推送解决方案有很多。这其中最便于使用的，应该是google提供的GCM的方案，但是GCM是基于GMS服务的。由于国内的ROM大多干掉了GMS，或者是由于某些众所周知的原因，我们无法使用这个方案获得稳定的推送服务（这个Apple的APNS不同，APNS是IOS的设备上唯一可用的推送解决方案，也是稳定的方案）。基于这些原因，我们选择了自建推送服务的方式。</p>
<p>###1. 基础建设：
<code>纸上得来终觉浅 绝知此事要躬行</code></p>
<ol>
<li><strong>理论支撑</strong> ：使用MQTT作为Android实现方案的原因源于一篇四年前的文章：<a href="http://tokudu.com/post/50024574938/how-to-implement-push-notifications-for-android" title="">How to Implement Push Notifications for Android</a>；</li>
<li><strong>与Web管理的对接</strong> ： 文章的作者同时也提供了PHP端的Client方案：<a href="https://github.com/tokudu/PhpMQTTClient" title="">PhpMQTTClient</a>。</li>
<li><strong>服务端</strong> ： 当然，这只是Web端的实现方案，至于后端需要使用的Broker，我们找到了<a href="http://mosquitto.org/" title="">mosquitto</a>。</li>
<li><strong>客户端</strong> ： 在客户端中，我们使用的是来自IBM的wmqtt.jar的包：<a href="http://mqtt.org/wiki/doku.php/ia92#wmqtt_ia92_java_utility" title="">wmqtt</a></li>
</ol>
<p>以上四个基本条件是我们具备了部署基于MQTT协议的Android的推送服务的基本条件。在最初的测试中，也没有遇到过太大的问题，测试顺利，于是我们在我们的应用和服务器之间部署了这套解决方案。</p>
<p>###2. 从0到1的变化：
<code>千里之行，始于足下</code></p>
<p>由于事先并没有做推送的经验，在实际实施的过程中我们明白的几个基础的概念：</p>
<ol>
<li>MQTT协议是一个即时通讯协议，推送实际上用到的只是它可以publish内容给topic的功能。topic是一个广播，所有订阅了这个topic的客户端都可以收到消息，为了实现针对设备的点对点推送，我们使用一个<code>prefix+Client ID</code>的方式给每个设备一个topic（如果没有这个需求，可以采取其它灵活的方式）。</li>
<li>为了保证客户端能够实时的收到推送消息，即使是程序退出，客户端用于接收消息的service也需要处于保持状态。</li>
<li>客户端与Broker、Broker和Web端的都是socket通信，推送的过程是用于Web端的client发布一个消息到Broker，Broker再将消息发送给当前其它连接到Broker的Client。所以能及时收到消息的只是现在和Broker保持连接状态的设备。</li>
<li>服务端需要维护一个设备id列表，这个列表中的id必须都是唯一的（在前期，我们选择使用Android ID，这也带来了很多麻烦）。</li>
</ol>
<p>基于以上几点，我们也可以发现以下的问题：</p>
<ol>
<li>不是所有的设备都能够及时的获取到推送的内容。</li>
<li>客户端的service随时会有被各种安全软件干掉的风险。</li>
</ol>
<p>通过前期的调研我们也发现，这些问题也是其它的第三方推送服务也都会遇到的问题。只要迈出第一步，让服务先work起来，其它的问题后续来优化。</p>
<p>###3. 从1到1万：
<code>不积硅步，无以致千里</code></p>
<p>这个阶段主要是丰富推送的功能，解决一些前表面上的问题，我们做了以下的调整：</p>
<ol>
<li>
<p>在设备量到10000的时候，遇到了一个问题：推送10000个设备时间过长。这个问题很快得到了解决：这是由于没发送一个设备，都新建了一个从Web端到Broker的socket连接，这实际上是没有必要的，只要socket不断开所有Publish的工作都可以通过一个socket进行（这和APNS有些不一样的地方，在苹果的推送服务中，如果有一个设备id是无效的，整个推送都会断开），在前文提到过的Web端的库中，是有指定重连的操作的。</p>
</li>
<li>
<p>丰富推送的内容。虽然推送的内容都是文本，但是文本的解析却是客户端维持的service来进行的，所以通过推送json的方式，实现了分别推送新闻、天气等富文本信息，并可以通过点击跳转到不同的页面。</p>
</li>
<li>
<p>分地区推送的需求，这个实现方式经过一些迭代，最早是通过用户注册地来实现的，后来改为了用户安装应用时上报的地区的方式。</p>
</li>
</ol>
<p>###4. 从1万到10万，必须做出的改变：
<code>行百里者半于九十</code></p>
<p>数据量到达10万的时候，一些问题也逐渐凸显。</p>
<ol>
<li>
<p><strong>Android ID重复的问题</strong> ：
从网上查询来的资料，大部分都是使用Android的系统参数<code>ANDROID_ID</code>来做推送的。然而实践表明，这个参数并不是可靠的。生产环境中使用这个参数有极大的几率重复。由于一个相同的设备id连接到Broker的时候，之前的连接就会断开，这就会导致相同设备ID的设备只有一个会收到推送的消息。
在续的改造过程中，我们将设备ID换成了自己生成的一套唯一随机的ID。</p>
</li>
<li>
<p><strong>错误的id字符</strong> ：
在查看MQTT的文档中，我们只注意到了设备ID需要在1~23位之间，却并没有注意到字符的限制。最初生成的id是base64的编码。在后面的测试中 ，总是发现推送到某些设备之后推送就断开了。经过检查发现，这是由于一些设备id中存在<code>+</code>符号导致的。
在Topic中，<code>+</code>和<code>#</code>会被当作通配符处理，导致出现 <em>Socket error</em> 的错误。
经过咨询，得到了以下的答案：</p>
</li>
</ol>
<blockquote>
<p>Roger Light (roger.light) said :
Are you saying that clients that have a client id with &lsquo;+&rsquo; in are rejected? This shouldn&rsquo;t happen. If you mean that clients are publishing to a topic with &lsquo;+&rsquo; in, then you are correct that this is not allowed.</p>
</blockquote>
<ol start="3">
<li>
<p><strong>从Broker中获取有用的信息</strong> ：
生产环境中需要通过从Broker中获取一些有用的信息用于监控推送的状态。在Mosquitto的配置中，可以把<code>log_type</code>设定为<code>all</code>来记录全部的log。
通过订阅Mosquitto的一个特定的Topic，可以获取到一些推送的统计信息：
<code>mosquitto_sub -h 192.168.0.1 -p 1883 -t $SYS/broker/# -v</code></p>
</li>
<li>
<p><strong>对于不在线的设备的处理（消息持久化）</strong> ：
IOS和Windows Phone的设备的推送服务由于是系统提供的服务，只要设备网络在线，都是可以及时收到消息的，对于Android的自建推送服务来说，显然无法保证这一点。然而通过消息持久化的配置，也可以实现以下策略：</p>
<ul>
<li>应用处于打开状态，设备在线的时候，可以及时的收到消息</li>
<li>应用退出、推送的Service在线的时候，可以收到推送消息</li>
<li>应用和Service都被关闭，下次应用启动的时候，可以收到一天内的推送消息</li>
</ul>
<p>基于以上的策略，可以在客户端和Broker之间配置消息持久化和订阅的持久化。配置过程中需要在以下几个地方注意：</p>
<ol>
<li>Web端发送消息的时候，QoS设定为1</li>
<li>Mosquitto的配置文件中，设定<code>persistence</code>为<code>true</code></li>
<li>客户端<code>MQTT_CLEAN_START</code>(Clean session)为<code>false</code>，即不在服务启动时清理session，<code>MQTT_QUALITIES_OF_SERVICE</code>(QoS)与Web端保持一致;</li>
</ol>
</li>
<li>
<p><strong>安全策略的控制</strong> ：
在Mosquitto的后端配置中，可以使用限定客户端前缀，使用ACL权限控制，配置SSL连接的方式进行安全控制。</p>
</li>
</ol>
<p>###5. 从10万到more，更多要做的事情&hellip;
<code>路遥知马力</code></p>
<ol>
<li>
<p><strong>推送时间的优化调整</strong> ：
实际环境中，一台4G内存，4核CPU的服务器，发送20万台设备的消息大概需要4分钟左右，推送服务器并没有什么压力，这个时间取决于Web端将所有的消息Publish到Broker服务器的时间。可以通过多线程的方式进行优化。</p>
</li>
<li>
<p><strong>及时清理失效的设备id</strong> ：
由于技术上的改造和迭代，一些设备ID在更新之后就不会再使用，服务端设定一定的策略来清理无效的设备ID可以减轻推送的压力。比如通过记录设备最后一次连接到Broker的时间，如果这个时间超出某个限制（一个月），就清理掉这个设备id。下次设备重新连入的时候还会再发送设备ID，这样即不会给服务器造成压力，也不会漏掉某些设备的推送。</p>
</li>
<li>
<p><strong>集群部署</strong> ：
Mosquitto支持集群部署的配置（Bridges），其原理也是将一个消息Puhlish到集群中的其它服务器，然后由其它服务器来发送。</p>
</li>
</ol>
<blockquote>
<p>A bridge is a way of connecting multiple MQTT brokers together.</p>
</blockquote>
<ol start="5">
<li><strong>如何让客户端的service始终在线</strong> ：
参考：</li>
</ol>
<blockquote>
<p>在android中，service被杀死后在没有被系统/安全软件禁止的条件下是能够自启动的，具体可自行网上搜索“android service onstartcommand START_STICKY”</p>
</blockquote>
<p>###6. Mosquitto的配置优化
我们的部分配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">allow_zero_length_clientid <span class="nb">false</span>
persistent_client_expiration 1d
max_connections -1
persistence <span class="nb">true</span>
log_type all
connection_messages <span class="nb">false</span>
allow_anonymous <span class="nb">false</span>
</code></pre></div><p>###7. 资源/资料收集</p>
<ol>
<li>Apache的<code>open source messaging and Integration Patterns server</code>，ActiceMQ，使用java编写，使用与管理很方便，目前发现的问题是内存使用量较大：<a href="http://activemq.apache.org/" title="">Apache ActiveMQ</a></li>
<li>Eclipse的客户端库：<a href="http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.c.git/" title="">Eclipse Paho</a></li>
<li>MQTT v3.1协议规范：<a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html" title="">MQTT V3.1 Protocol Specification</a></li>
<li>Mosquitto文档：<a href="http://mosquitto.org/documentation/" title="">Mosquitto Documentation</a></li>
</ol>
]]></content>
        </item>
        
    </channel>
</rss>
